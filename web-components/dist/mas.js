window.masPriceLiterals = {
    "total": 38,
    "offset": 0,
    "limit": 38,
    "data": [
        {
            "lang": "ar",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/الشهر} YEAR {/العام} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {كل شهر} YEAR {كل عام} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {لكل ترخيص} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {لكل ترخيص} other {}}",
            "freeLabel": "مجانًا",
            "freeAriaLabel": "مجانًا",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "أو بدلاً من ذلك بقيمة {alternativePrice}",
            "strikethroughAriaLabel": "بشكل منتظم بقيمة {strikethroughPrice}"
        },
        {
            "lang": "bg",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/мес.} YEAR {/год.} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {на месец} YEAR {на година} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {на лиценз} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {на лиценз} other {}}",
            "freeLabel": "Безплатно",
            "freeAriaLabel": "Безплатно",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Алтернативно на {alternativePrice}",
            "strikethroughAriaLabel": "Редовно на {strikethroughPrice}"
        },
        {
            "lang": "cs",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/měsíc} YEAR {/rok} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {za měsíc} YEAR {za rok} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {za licenci} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {za licenci} other {}}",
            "freeLabel": "Zdarma",
            "freeAriaLabel": "Zdarma",
            "taxExclusiveLabel": "{taxTerm, select, GST {bez daně ze zboží a služeb} VAT {bez DPH} TAX {bez daně} IVA {bez IVA} SST {bez SST} KDV {bez KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {včetně daně ze zboží a služeb} VAT {včetně DPH} TAX {včetně daně} IVA {včetně IVA} SST {včetně SST} KDV {včetně KDV} other {}}",
            "alternativePriceAriaLabel": "Případně za {alternativePrice}",
            "strikethroughAriaLabel": "Pravidelně za {strikethroughPrice}"
        },
        {
            "lang": "da",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/md} YEAR {/år} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {pr. måned} YEAR {pr. år} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {pr. licens} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {pr. licens} other {}}",
            "freeLabel": "Gratis",
            "freeAriaLabel": "Gratis",
            "taxExclusiveLabel": "{taxTerm, select, GST {ekskl. GST} VAT {ekskl. moms} TAX {ekskl. skat} IVA {ekskl. IVA} SST {ekskl. SST} KDV {ekskl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. moms} TAX {inkl. skat} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternativt til {alternativePrice}",
            "strikethroughAriaLabel": "Normalpris {strikethroughPrice}"
        },
        {
            "lang": "de",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/Monat} YEAR {/Jahr} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {pro Monat} YEAR {pro Jahr} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {pro Lizenz} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {pro Lizenz} other {}}",
            "freeLabel": "Kostenlos",
            "freeAriaLabel": "Kostenlos",
            "taxExclusiveLabel": "{taxTerm, select, GST {zzgl. GST} VAT {zzgl. MwSt.} TAX {zzgl. Steuern} IVA {zzgl. IVA} SST {zzgl. SST} KDV {zzgl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. MwSt.} TAX {inkl. Steuern} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternativ: {alternativePrice}",
            "strikethroughAriaLabel": "Regulär: {strikethroughPrice}"
        },
        {
            "lang": "en",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mo} YEAR {/yr} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per month} YEAR {per year} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {per license} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {per license} other {}}",
            "freeLabel": "Free",
            "freeAriaLabel": "Free",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternatively at {alternativePrice}",
            "strikethroughAriaLabel": "Regularly at {strikethroughPrice}"
        },
        {
            "lang": "et",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {kuus} YEAR {aastas} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {kuus} YEAR {aastas} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {litsentsi kohta} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {litsentsi kohta} other {}}",
            "freeLabel": "Tasuta",
            "freeAriaLabel": "Tasuta",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Teise võimalusena hinnaga {alternativePrice}",
            "strikethroughAriaLabel": "Tavahind {strikethroughPrice}"
        },
        {
            "lang": "fi",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/kk} YEAR {/v} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {kuukausittain} YEAR {vuosittain} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {käyttöoikeutta kohti} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {käyttöoikeutta kohti} other {}}",
            "freeLabel": "Maksuton",
            "freeAriaLabel": "Maksuton",
            "taxExclusiveLabel": "{taxTerm, select, GST {ilman GST:tä} VAT {ilman ALV:tä} TAX {ilman veroja} IVA {ilman IVA:ta} SST {ilman SST:tä} KDV {ilman KDV:tä} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {sis. GST:n} VAT {sis. ALV:n} TAX {sis. verot} IVA {sis. IVA:n} SST {sis. SST:n} KDV {sis. KDV:n} other {}}",
            "alternativePriceAriaLabel": "Vaihtoehtoisesti hintaan {alternativePrice}",
            "strikethroughAriaLabel": "Säännöllisesti hintaan {strikethroughPrice}"
        },
        {
            "lang": "fr",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mois} YEAR {/an} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {par mois} YEAR {par an} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {par licence} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {par licence} other {}}",
            "freeLabel": "Gratuit",
            "freeAriaLabel": "Gratuit",
            "taxExclusiveLabel": "{taxTerm, select, GST {hors TPS} VAT {hors TVA} TAX {hors taxes} IVA {hors IVA} SST {hors SST} KDV {hors KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {TPS comprise} VAT {TVA comprise} TAX {taxes comprises} IVA {IVA comprise} SST {SST comprise} KDV {KDV comprise} other {}}",
            "alternativePriceAriaLabel": "Autre prix {alternativePrice}",
            "strikethroughAriaLabel": "Prix habituel {strikethroughPrice}"
        },
        {
            "lang": "he",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/חודש} YEAR {/שנה} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {לחודש} YEAR {לשנה} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {לרישיון} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {לרישיון} other {}}",
            "freeLabel": "חינם",
            "freeAriaLabel": "חינם",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "לחלופין ב-{alternativePrice}",
            "strikethroughAriaLabel": "באופן קבוע ב-{strikethroughPrice}"
        },
        {
            "lang": "hu",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/hó} YEAR {/év} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {havonta} YEAR {évente} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {licencenként} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {licencenként} other {}}",
            "freeLabel": "Ingyenes",
            "freeAriaLabel": "Ingyenes",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Másik lehetőség: {alternativePrice}",
            "strikethroughAriaLabel": "Általában {strikethroughPrice} áron"
        },
        {
            "lang": "it",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mese} YEAR {/anno} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {al mese} YEAR {all'anno} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {per licenza} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {per licenza} other {}}",
            "freeLabel": "Gratuito",
            "freeAriaLabel": "Gratuito",
            "taxExclusiveLabel": "{taxTerm, select, GST {escl. GST} VAT {escl. IVA.} TAX {escl. imposte} IVA {escl. IVA} SST {escl. SST} KDV {escl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. IVA} TAX {incl. imposte} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "In alternativa a {alternativePrice}",
            "strikethroughAriaLabel": "Regolarmente a {strikethroughPrice}"
        },
        {
            "lang": "ja",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/月} YEAR {/年} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {毎月} YEAR {毎年} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {ライセンスごと} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {ライセンスごと} other {}}",
            "freeLabel": "無料",
            "freeAriaLabel": "無料",
            "taxExclusiveLabel": "{taxTerm, select, GST {GST 別} VAT {VAT 別} TAX {税別} IVA {IVA 別} SST {SST 別} KDV {KDV 別} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {GST 込} VAT {VAT 込} TAX {税込} IVA {IVA 込} SST {SST 込} KDV {KDV 込} other {}}",
            "alternativePriceAriaLabel": "特別価格 : {alternativePrice}",
            "strikethroughAriaLabel": "通常価格 : {strikethroughPrice}"
        },
        {
            "lang": "ko",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/월} YEAR {/년} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {월간} YEAR {연간} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {라이선스당} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {라이선스당} other {}}",
            "freeLabel": "무료",
            "freeAriaLabel": "무료",
            "taxExclusiveLabel": "{taxTerm, select, GST {GST 제외} VAT {VAT 제외} TAX {세금 제외} IVA {IVA 제외} SST {SST 제외} KDV {KDV 제외} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {GST 포함} VAT {VAT 포함} TAX {세금 포함} IVA {IVA 포함} SST {SST 포함} KDV {KDV 포함} other {}}",
            "alternativePriceAriaLabel": "또는 {alternativePrice}에",
            "strikethroughAriaLabel": "또는 {alternativePrice}에"
        },
        {
            "lang": "lt",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH { per mėn.} YEAR { per metus} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per mėn.} YEAR {per metus} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {už licenciją} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {už licenciją} other {}}",
            "freeLabel": "Nemokamai",
            "freeAriaLabel": "Nemokamai",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Arba už {alternativePrice}",
            "strikethroughAriaLabel": "Normaliai už {strikethroughPrice}"
        },
        {
            "lang": "lv",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {mēnesī} YEAR {gadā} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {mēnesī} YEAR {gadā} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {vienai licencei} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {vienai licencei} other {}}",
            "freeLabel": "Bezmaksas",
            "freeAriaLabel": "Bezmaksas",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternatīvi par {alternativePrice}",
            "strikethroughAriaLabel": "Regulāri par {strikethroughPrice}"
        },
        {
            "lang": "nb",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mnd.} YEAR {/år} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per måned} YEAR {per år} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {per lisens} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {per lisens} other {}}",
            "freeLabel": "Fri",
            "freeAriaLabel": "Fri",
            "taxExclusiveLabel": "{taxTerm, select, GST {ekskl. GST} VAT {ekskl. moms} TAX {ekskl. avgift} IVA {ekskl. IVA} SST {ekskl. SST} KDV {ekskl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. moms} TAX {inkl. avgift} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternativt til {alternativePrice}",
            "strikethroughAriaLabel": "Regelmessig til {strikethroughPrice}"
        },
        {
            "lang": "nl",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mnd} YEAR {/jr} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per maand} YEAR {per jaar} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {per licentie} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {per licentie} other {}}",
            "freeLabel": "Gratis",
            "freeAriaLabel": "Gratis",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. btw} TAX {excl. belasting} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. btw} TAX {incl. belasting} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Nu {alternativePrice}",
            "strikethroughAriaLabel": "Normaal {strikethroughPrice}"
        },
        {
            "lang": "pl",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH { / mies.} YEAR { / rok} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH { / miesiąc} YEAR { / rok} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {za licencję} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {za licencję} other {}}",
            "freeLabel": "Bezpłatne",
            "freeAriaLabel": "Bezpłatne",
            "taxExclusiveLabel": "{taxTerm, select, GST {bez GST} VAT {bez VAT} TAX {netto} IVA {bez IVA} SST {bez SST} KDV {bez KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {z GST} VAT {z VAT} TAX {brutto} IVA {z IVA} SST {z SST} KDV {z KDV} other {}}",
            "alternativePriceAriaLabel": "Lub za {alternativePrice}",
            "strikethroughAriaLabel": "Cena zwykła: {strikethroughPrice}"
        },
        {
            "lang": "pt",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mês} YEAR {/ano} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {por mês} YEAR {por ano} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {por licença} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {por licença} other {}}",
            "freeLabel": "Gratuito",
            "freeAriaLabel": "Gratuito",
            "taxExclusiveLabel": "{taxTerm, select, GST {ICMS não incluso} VAT {IVA não incluso} TAX {impostos não inclusos} IVA {IVA não incluso} SST { SST não incluso} KDV {KDV não incluso} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {ICMS incluso} VAT {IVA incluso} TAX {impostos inclusos} IVA {IVA incluso} SST {SST incluso} KDV {KDV incluso} other {}}",
            "alternativePriceAriaLabel": "Ou a {alternativePrice}",
            "strikethroughAriaLabel": "Preço normal: {strikethroughPrice}"
        },
        {
            "lang": "ro",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/lună} YEAR {/an} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {pe lună} YEAR {pe an} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {pe licență} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {pe licență} other {}}",
            "freeLabel": "Gratuit",
            "freeAriaLabel": "Gratuit",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternativ, la {alternativePrice}",
            "strikethroughAriaLabel": "În mod normal, la {strikethroughPrice}"
        },
        {
            "lang": "ru",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/мес.} YEAR {/г.} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {в месяц} YEAR {в год} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {за лицензию} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {за лицензию} other {}}",
            "freeLabel": "Бесплатно",
            "freeAriaLabel": "Бесплатно",
            "taxExclusiveLabel": "{taxTerm, select, GST {искл. налог на товары и услуги} VAT {искл. НДС} TAX {искл. налог} IVA {искл. ИВА} SST {искл. SST} KDV {искл. КДВ} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {вкл. налог на товары и услуги} VAT {вкл. НДС} TAX {вкл. налог} IVA {вкл. ИВА} SST {вкл. SST} KDV {вкл. КДВ} other {}}",
            "alternativePriceAriaLabel": "Альтернативный вариант за {alternativePrice}",
            "strikethroughAriaLabel": "Регулярно по цене {strikethroughPrice}"
        },
        {
            "lang": "sk",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mesiac} YEAR {/rok} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {za mesiac} YEAR {za rok} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {za licenciu} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {za licenciu} other {}}",
            "freeLabel": "Zadarmo",
            "freeAriaLabel": "Zadarmo",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Prípadne za {alternativePrice}",
            "strikethroughAriaLabel": "Pravidelne za {strikethroughPrice}"
        },
        {
            "lang": "sl",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mesec} YEAR {/leto} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {na mesec} YEAR {na leto} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {na licenco} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {na licenco} other {}}",
            "freeLabel": "Brezplačno",
            "freeAriaLabel": "Brezplačno",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "Druga možnost je: {alternativePrice}",
            "strikethroughAriaLabel": "Redno po {strikethroughPrice}"
        },
        {
            "lang": "sv",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mån} YEAR {/år} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per månad} YEAR {per år} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {per licens} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {per licens} other {}}",
            "freeLabel": "Kostnadsfritt",
            "freeAriaLabel": "Kostnadsfritt",
            "taxExclusiveLabel": "{taxTerm, select, GST {exkl. GST} VAT {exkl. moms} TAX {exkl. skatt} IVA {exkl. IVA} SST {exkl. SST} KDV {exkl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {inkl. GST} VAT {inkl. moms} TAX {inkl. skatt} IVA {inkl. IVA} SST {inkl. SST} KDV {inkl. KDV} other {}}",
            "alternativePriceAriaLabel": "Alternativt för {alternativePrice}",
            "strikethroughAriaLabel": "Normalpris {strikethroughPrice}"
        },
        {
            "lang": "tr",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/ay} YEAR {/yıl} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {(aylık)} YEAR {(yıllık)} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {(lisans başına)} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {(lisans başına)} other {}}",
            "freeLabel": "Ücretsiz",
            "freeAriaLabel": "Ücretsiz",
            "taxExclusiveLabel": "{taxTerm, select, GST {GST hariç} VAT {KDV hariç} TAX {vergi hariç} IVA {IVA hariç} SST {SST hariç} KDV {KDV hariç} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {GST dahil} VAT {KDV dahil} TAX {vergi dahil} IVA {IVA dahil} SST {SST dahil} KDV {KDV dahil} other {}}",
            "alternativePriceAriaLabel": "Ya da {alternativePrice}",
            "strikethroughAriaLabel": "Standart fiyat: {strikethroughPrice}"
        },
        {
            "lang": "uk",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/міс.} YEAR {/рік} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {на місяць} YEAR {на рік} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {за ліцензію} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {за ліцензію} other {}}",
            "freeLabel": "Безкоштовно",
            "freeAriaLabel": "Безкоштовно",
            "taxExclusiveLabel": "{taxTerm, select, GST {без GST} VAT {без ПДВ} TAX {без податку} IVA {без IVA} SST {без SST} KDV {без KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {разом із GST} VAT {разом із ПДВ} TAX {разом із податком} IVA {разом з IVA} SST {разом із SST} KDV {разом із KDV} other {}}",
            "alternativePriceAriaLabel": "Або за {alternativePrice}",
            "strikethroughAriaLabel": "Звичайна ціна {strikethroughPrice}"
        },
        {
            "lang": "zh-hans",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/月} YEAR {/年} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {每月} YEAR {每年} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {每个许可证} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {每个许可证} other {}}",
            "freeLabel": "免费",
            "freeAriaLabel": "免费",
            "taxExclusiveLabel": "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
            "alternativePriceAriaLabel": "或定价 {alternativePrice}",
            "strikethroughAriaLabel": "正常价 {strikethroughPrice}"
        },
        {
            "lang": "zh-hant",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/月} YEAR {/年} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {每月} YEAR {每年} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {每個授權} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {每個授權} other {}}",
            "freeLabel": "免費",
            "freeAriaLabel": "免費",
            "taxExclusiveLabel": "{taxTerm, select, GST {不含 GST} VAT {不含 VAT} TAX {不含稅} IVA {不含 IVA} SST {不含 SST} KDV {不含 KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {含 GST} VAT {含 VAT} TAX {含稅} IVA {含 IVA} SST {含 SST} KDV {含 KDV} other {}}",
            "alternativePriceAriaLabel": "或者在 {alternativePrice}",
            "strikethroughAriaLabel": "標準價格為 {strikethroughPrice}"
        },
        {
            "lang": "es",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/mes} YEAR {/año} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {al mes} YEAR {al año} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {por licencia} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {por licencia} other {}}",
            "freeLabel": "Gratuito",
            "freeAriaLabel": "Gratuito",
            "taxExclusiveLabel": "{taxTerm, select, GST {GST no incluido} VAT {IVA no incluido} TAX {Impuestos no incluidos} IVA {IVA no incluido} SST {SST no incluido} KDV {KDV no incluido} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {GST incluido} VAT {IVA incluido} TAX {Impuestos incluidos} IVA {IVA incluido} SST {SST incluido} KDV {KDV incluido} other {}}",
            "alternativePriceAriaLabel": "Alternativamente por {alternativePrice}",
            "strikethroughAriaLabel": "Normalmente a {strikethroughPrice}"
        },
        {
            "lang": "in",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/bulan} YEAR {/tahun} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per bulan} YEAR {per tahun} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {per lisensi} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {per lisensi} other {}}",
            "freeLabel": "Gratis",
            "freeAriaLabel": "Gratis",
            "taxExclusiveLabel": "{taxTerm, select, GST {tidak termasuk PBJ} VAT {tidak termasuk PPN} TAX {tidak termasuk pajak} IVA {tidak termasuk IVA} SST {tidak termasuk SST} KDV {tidak termasuk KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {termasuk PBJ} VAT {termasuk PPN} TAX {termasuk pajak} IVA {termasuk IVA} SST {termasuk SST} KDV {termasuk KDV} other {}}",
            "alternativePriceAriaLabel": "Atau seharga {alternativePrice}",
            "strikethroughAriaLabel": "Normalnya seharga {strikethroughPrice}"
        },
        {
            "lang": "vi",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/tháng} YEAR {/năm} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {mỗi tháng} YEAR {mỗi năm} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {mỗi giấy phép} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {mỗi giấy phép} other {}}",
            "freeLabel": "Miễn phí",
            "freeAriaLabel": "Miễn phí",
            "taxExclusiveLabel": "{taxTerm, select, GST {chưa bao gồm thuế hàng hóa và dịch vụ} VAT {chưa bao gồm thuế GTGT} TAX {chưa bao gồm thuế} IVA {chưa bao gồm IVA} SST {chưa bao gồm SST} KDV {chưa bao gồm KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {(đã bao gồm thuế hàng hóa và dịch vụ)} VAT {(đã bao gồm thuế GTGT)} TAX {(đã bao gồm thuế)} IVA {(đã bao gồm IVA)} SST {(đã bao gồm SST)} KDV {(đã bao gồm KDV)} other {}}",
            "alternativePriceAriaLabel": "Giá ưu đãi {alternativePrice}",
            "strikethroughAriaLabel": "Giá thông thường {strikethroughPrice}"
        },
        {
            "lang": "th",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/เดือน} YEAR {/ปี} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {ต่อเดือน} YEAR {ต่อปี} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {ต่อสิทธิ์การใช้งาน} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {ต่อสิทธิ์การใช้งาน} other {}}",
            "freeLabel": "ฟรี",
            "freeAriaLabel": "ฟรี",
            "taxExclusiveLabel": "{taxTerm, select, GST {ไม่รวมภาษี GST} VAT {ไม่รวม VAT} TAX {ไม่รวมภาษี} IVA {ไม่รวม IVA} SST {ไม่รวม SST} KDV {ไม่รวม KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {รวมภาษี GST} VAT {รวม VAT} TAX {รวมภาษี} IVA {รวม IVA} SST {รวม SST} KDV {รวม KDV} other {}}",
            "alternativePriceAriaLabel": "ราคาพิเศษ {alternativePrice}",
            "strikethroughAriaLabel": "ราคาปกติ {strikethroughPrice}"
        },
        {
            "lang": "el",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/μήνα} YEAR {/έτος} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {κάθε μήνα} YEAR {ανά έτος} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {ανά άδεια χρήσης} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {ανά άδεια χρήσης} other {}}",
            "freeLabel": "Δωρεάν",
            "freeAriaLabel": "Δωρεάν",
            "taxExclusiveLabel": "{taxTerm, select, GST {(μη συμπεριλαμβανομένου GST)} VAT {(μη συμπεριλαμβανομένου ΦΠΑ)} TAX {(μη συμπεριλαμβανομένου φόρο)} IVA {(μη συμπεριλαμβανομένου IVA)} SST {(μη συμπεριλαμβανομένου SST)} KDV {(μη συμπεριλαμβανομένου KDV)} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {(συμπεριλαμβανομένου του GST)} VAT {(συμπεριλαμβανομένου ΦΠΑ)} TAX {(συμπεριλαμβανομένου του φόρου)} IVA {(συμπεριλαμβανομένου του IVA)} SST {(συμπεριλαμβανομένου του SST)} KDV {(συμπεριλαμβανομένου του KDV)} other {}}",
            "alternativePriceAriaLabel": "Διαφορετικά, {alternativePrice}",
            "strikethroughAriaLabel": "Κανονική τιμή {strikethroughPrice}"
        },
        {
            "lang": "fil",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/buwan} YEAR {/taon} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per buwan} YEAR {per taon} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {kada lisensya} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {kada lisensya} other {}}",
            "freeLabel": "Libre",
            "freeAriaLabel": "Libre",
            "taxExclusiveLabel": "{taxTerm, select, GST {hindi kasama ang GST} VAT {hindi kasama ang VAT} TAX {hindi kasama ang Buwis} IVA {hindi kasama ang IVA} SST {hindi kasama ang SST} KDV {hindi kasama ang KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {kasama ang GST} VAT {kasama ang VAT} TAX {kasama ang Buwis} IVA {kasama ang IVA} SST {kasama ang SST} KDV {kasama ang KDV} other {}}",
            "alternativePriceAriaLabel": "Alternatibong nasa halagang {alternativePrice}",
            "strikethroughAriaLabel": "Regular na nasa halagang {strikethroughPrice}"
        },
        {
            "lang": "ms",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/bulan} YEAR {/tahun} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per bulan} YEAR {per tahun} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {setiap lesen} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {setiap lesen} other {}}",
            "freeLabel": "Percuma",
            "freeAriaLabel": "Percuma",
            "taxExclusiveLabel": "{taxTerm, select, GST {kecuali GST} VAT {kecuali VAT} TAX {kecuali Cukai} IVA {kecuali IVA} SST {kecuali SST} KDV {kecuali KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {termasuk GST} VAT {termasuk VAT} TAX {termasuk Cukai} IVA {termasuk IVA} SST {termasuk SST} KDV {termasuk KDV} other {}}",
            "alternativePriceAriaLabel": "Secara alternatif pada {alternativePrice}",
            "strikethroughAriaLabel": "Biasanya pada {strikethroughPrice}"
        },
        {
            "lang": "hi",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/माह} YEAR {/वर्ष} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {per माह} YEAR {per वर्ष} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {प्रति लाइसेंस} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {प्रति लाइसेंस} other {}}",
            "freeLabel": "फ़्री",
            "freeAriaLabel": "फ़्री",
            "taxExclusiveLabel": "{taxTerm, select, GST {GST अतिरिक्त} VAT {VAT अतिरिक्त} TAX {कर अतिरिक्त} IVA {IVA अतिरिक्त} SST {SST अतिरिक्त} KDV {KDV अतिरिक्त} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {GST सहित} VAT {VAT सहित} TAX {कर सहित} IVA {IVA सहित} SST {SST सहित} KDV {KDV सहित} other {}}",
            "alternativePriceAriaLabel": "वैकल्पिक रूप से इस पर {alternativePrice}",
            "strikethroughAriaLabel": "नियमित रूप से इस पर {strikethroughPrice}"
        },
        {
            "lang": "iw",
            "recurrenceLabel": "{recurrenceTerm, select, MONTH {/חודש} YEAR {/שנה} other {}}",
            "recurrenceAriaLabel": "{recurrenceTerm, select, MONTH {לחודש} YEAR {לשנה} other {}}",
            "perUnitLabel": "{perUnit, select, LICENSE {לרישיון} other {}}",
            "perUnitAriaLabel": "{perUnit, select, LICENSE {לרישיון} other {}}",
            "freeLabel": "חינם",
            "freeAriaLabel": "חינם",
            "taxExclusiveLabel": "{taxTerm, select, GST {ללא GST} VAT {ללא מע\"מ} TAX {ללא מס} IVA {ללא IVA} SST {ללא SST} KDV {ללא KDV} other {}}",
            "taxInclusiveLabel": "{taxTerm, select, GST {כולל GST} VAT {כולל מע\"מ} TAX {כולל מס} IVA {כולל IVA} SST {כולל SST} KDV {כולל KDV} other {}}",
            "alternativePriceAriaLabel": "לחלופין ב-{alternativePrice}",
            "strikethroughAriaLabel": "באופן קבוע ב-{strikethroughPrice}"
        }
    ],
    ":type": "sheet"
}
.data;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/@lit/reactive-element/css-tag.js
var t, e, s, n, o, r, i, S, c;
var init_css_tag = __esm({
  "node_modules/@lit/reactive-element/css-tag.js"() {
    t = window;
    e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
    s = Symbol();
    n = /* @__PURE__ */ new WeakMap();
    o = class {
      constructor(t3, e4, n5) {
        if (this._$cssResult$ = true, n5 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t3, this.t = e4;
      }
      get styleSheet() {
        let t3 = this.o;
        const s5 = this.t;
        if (e && void 0 === t3) {
          const e4 = void 0 !== s5 && 1 === s5.length;
          e4 && (t3 = n.get(s5)), void 0 === t3 && ((this.o = t3 = new CSSStyleSheet()).replaceSync(this.cssText), e4 && n.set(s5, t3));
        }
        return t3;
      }
      toString() {
        return this.cssText;
      }
    };
    r = (t3) => new o("string" == typeof t3 ? t3 : t3 + "", void 0, s);
    i = (t3, ...e4) => {
      const n5 = 1 === t3.length ? t3[0] : e4.reduce((e5, s5, n6) => e5 + ((t4) => {
        if (true === t4._$cssResult$) return t4.cssText;
        if ("number" == typeof t4) return t4;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + t4 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
      })(s5) + t3[n6 + 1], t3[0]);
      return new o(n5, t3, s);
    };
    S = (s5, n5) => {
      e ? s5.adoptedStyleSheets = n5.map((t3) => t3 instanceof CSSStyleSheet ? t3 : t3.styleSheet) : n5.forEach((e4) => {
        const n6 = document.createElement("style"), o5 = t.litNonce;
        void 0 !== o5 && n6.setAttribute("nonce", o5), n6.textContent = e4.cssText, s5.appendChild(n6);
      });
    };
    c = e ? (t3) => t3 : (t3) => t3 instanceof CSSStyleSheet ? ((t4) => {
      let e4 = "";
      for (const s5 of t4.cssRules) e4 += s5.cssText;
      return r(e4);
    })(t3) : t3;
  }
});

// node_modules/@lit/reactive-element/reactive-element.js
var s2, e2, r2, h, o2, n2, a, l, d, u;
var init_reactive_element = __esm({
  "node_modules/@lit/reactive-element/reactive-element.js"() {
    init_css_tag();
    init_css_tag();
    e2 = window;
    r2 = e2.trustedTypes;
    h = r2 ? r2.emptyScript : "";
    o2 = e2.reactiveElementPolyfillSupport;
    n2 = { toAttribute(t3, i3) {
      switch (i3) {
        case Boolean:
          t3 = t3 ? h : null;
          break;
        case Object:
        case Array:
          t3 = null == t3 ? t3 : JSON.stringify(t3);
      }
      return t3;
    }, fromAttribute(t3, i3) {
      let s5 = t3;
      switch (i3) {
        case Boolean:
          s5 = null !== t3;
          break;
        case Number:
          s5 = null === t3 ? null : Number(t3);
          break;
        case Object:
        case Array:
          try {
            s5 = JSON.parse(t3);
          } catch (t4) {
            s5 = null;
          }
      }
      return s5;
    } };
    a = (t3, i3) => i3 !== t3 && (i3 == i3 || t3 == t3);
    l = { attribute: true, type: String, converter: n2, reflect: false, hasChanged: a };
    d = "finalized";
    u = class extends HTMLElement {
      constructor() {
        super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this._$Eu();
      }
      static addInitializer(t3) {
        var i3;
        this.finalize(), (null !== (i3 = this.h) && void 0 !== i3 ? i3 : this.h = []).push(t3);
      }
      static get observedAttributes() {
        this.finalize();
        const t3 = [];
        return this.elementProperties.forEach((i3, s5) => {
          const e4 = this._$Ep(s5, i3);
          void 0 !== e4 && (this._$Ev.set(e4, s5), t3.push(e4));
        }), t3;
      }
      static createProperty(t3, i3 = l) {
        if (i3.state && (i3.attribute = false), this.finalize(), this.elementProperties.set(t3, i3), !i3.noAccessor && !this.prototype.hasOwnProperty(t3)) {
          const s5 = "symbol" == typeof t3 ? Symbol() : "__" + t3, e4 = this.getPropertyDescriptor(t3, s5, i3);
          void 0 !== e4 && Object.defineProperty(this.prototype, t3, e4);
        }
      }
      static getPropertyDescriptor(t3, i3, s5) {
        return { get() {
          return this[i3];
        }, set(e4) {
          const r4 = this[t3];
          this[i3] = e4, this.requestUpdate(t3, r4, s5);
        }, configurable: true, enumerable: true };
      }
      static getPropertyOptions(t3) {
        return this.elementProperties.get(t3) || l;
      }
      static finalize() {
        if (this.hasOwnProperty(d)) return false;
        this[d] = true;
        const t3 = Object.getPrototypeOf(this);
        if (t3.finalize(), void 0 !== t3.h && (this.h = [...t3.h]), this.elementProperties = new Map(t3.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
          const t4 = this.properties, i3 = [...Object.getOwnPropertyNames(t4), ...Object.getOwnPropertySymbols(t4)];
          for (const s5 of i3) this.createProperty(s5, t4[s5]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), true;
      }
      static finalizeStyles(i3) {
        const s5 = [];
        if (Array.isArray(i3)) {
          const e4 = new Set(i3.flat(1 / 0).reverse());
          for (const i4 of e4) s5.unshift(c(i4));
        } else void 0 !== i3 && s5.push(c(i3));
        return s5;
      }
      static _$Ep(t3, i3) {
        const s5 = i3.attribute;
        return false === s5 ? void 0 : "string" == typeof s5 ? s5 : "string" == typeof t3 ? t3.toLowerCase() : void 0;
      }
      _$Eu() {
        var t3;
        this._$E_ = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t3 = this.constructor.h) || void 0 === t3 || t3.forEach((t4) => t4(this));
      }
      addController(t3) {
        var i3, s5;
        (null !== (i3 = this._$ES) && void 0 !== i3 ? i3 : this._$ES = []).push(t3), void 0 !== this.renderRoot && this.isConnected && (null === (s5 = t3.hostConnected) || void 0 === s5 || s5.call(t3));
      }
      removeController(t3) {
        var i3;
        null === (i3 = this._$ES) || void 0 === i3 || i3.splice(this._$ES.indexOf(t3) >>> 0, 1);
      }
      _$Eg() {
        this.constructor.elementProperties.forEach((t3, i3) => {
          this.hasOwnProperty(i3) && (this._$Ei.set(i3, this[i3]), delete this[i3]);
        });
      }
      createRenderRoot() {
        var t3;
        const s5 = null !== (t3 = this.shadowRoot) && void 0 !== t3 ? t3 : this.attachShadow(this.constructor.shadowRootOptions);
        return S(s5, this.constructor.elementStyles), s5;
      }
      connectedCallback() {
        var t3;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t3 = this._$ES) || void 0 === t3 || t3.forEach((t4) => {
          var i3;
          return null === (i3 = t4.hostConnected) || void 0 === i3 ? void 0 : i3.call(t4);
        });
      }
      enableUpdating(t3) {
      }
      disconnectedCallback() {
        var t3;
        null === (t3 = this._$ES) || void 0 === t3 || t3.forEach((t4) => {
          var i3;
          return null === (i3 = t4.hostDisconnected) || void 0 === i3 ? void 0 : i3.call(t4);
        });
      }
      attributeChangedCallback(t3, i3, s5) {
        this._$AK(t3, s5);
      }
      _$EO(t3, i3, s5 = l) {
        var e4;
        const r4 = this.constructor._$Ep(t3, s5);
        if (void 0 !== r4 && true === s5.reflect) {
          const h3 = (void 0 !== (null === (e4 = s5.converter) || void 0 === e4 ? void 0 : e4.toAttribute) ? s5.converter : n2).toAttribute(i3, s5.type);
          this._$El = t3, null == h3 ? this.removeAttribute(r4) : this.setAttribute(r4, h3), this._$El = null;
        }
      }
      _$AK(t3, i3) {
        var s5;
        const e4 = this.constructor, r4 = e4._$Ev.get(t3);
        if (void 0 !== r4 && this._$El !== r4) {
          const t4 = e4.getPropertyOptions(r4), h3 = "function" == typeof t4.converter ? { fromAttribute: t4.converter } : void 0 !== (null === (s5 = t4.converter) || void 0 === s5 ? void 0 : s5.fromAttribute) ? t4.converter : n2;
          this._$El = r4, this[r4] = h3.fromAttribute(i3, t4.type), this._$El = null;
        }
      }
      requestUpdate(t3, i3, s5) {
        let e4 = true;
        void 0 !== t3 && (((s5 = s5 || this.constructor.getPropertyOptions(t3)).hasChanged || a)(this[t3], i3) ? (this._$AL.has(t3) || this._$AL.set(t3, i3), true === s5.reflect && this._$El !== t3 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t3, s5))) : e4 = false), !this.isUpdatePending && e4 && (this._$E_ = this._$Ej());
      }
      async _$Ej() {
        this.isUpdatePending = true;
        try {
          await this._$E_;
        } catch (t4) {
          Promise.reject(t4);
        }
        const t3 = this.scheduleUpdate();
        return null != t3 && await t3, !this.isUpdatePending;
      }
      scheduleUpdate() {
        return this.performUpdate();
      }
      performUpdate() {
        var t3;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Ei && (this._$Ei.forEach((t4, i4) => this[i4] = t4), this._$Ei = void 0);
        let i3 = false;
        const s5 = this._$AL;
        try {
          i3 = this.shouldUpdate(s5), i3 ? (this.willUpdate(s5), null === (t3 = this._$ES) || void 0 === t3 || t3.forEach((t4) => {
            var i4;
            return null === (i4 = t4.hostUpdate) || void 0 === i4 ? void 0 : i4.call(t4);
          }), this.update(s5)) : this._$Ek();
        } catch (t4) {
          throw i3 = false, this._$Ek(), t4;
        }
        i3 && this._$AE(s5);
      }
      willUpdate(t3) {
      }
      _$AE(t3) {
        var i3;
        null === (i3 = this._$ES) || void 0 === i3 || i3.forEach((t4) => {
          var i4;
          return null === (i4 = t4.hostUpdated) || void 0 === i4 ? void 0 : i4.call(t4);
        }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t3)), this.updated(t3);
      }
      _$Ek() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
      }
      get updateComplete() {
        return this.getUpdateComplete();
      }
      getUpdateComplete() {
        return this._$E_;
      }
      shouldUpdate(t3) {
        return true;
      }
      update(t3) {
        void 0 !== this._$EC && (this._$EC.forEach((t4, i3) => this._$EO(i3, this[i3], t4)), this._$EC = void 0), this._$Ek();
      }
      updated(t3) {
      }
      firstUpdated(t3) {
      }
    };
    u[d] = true, u.elementProperties = /* @__PURE__ */ new Map(), u.elementStyles = [], u.shadowRootOptions = { mode: "open" }, null == o2 || o2({ ReactiveElement: u }), (null !== (s2 = e2.reactiveElementVersions) && void 0 !== s2 ? s2 : e2.reactiveElementVersions = []).push("1.6.3");
  }
});

// node_modules/lit-html/lit-html.js
function P(t3, i3) {
  if (!Array.isArray(t3) || !t3.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== e3 ? e3.createHTML(i3) : i3;
}
function S2(t3, i3, s5 = t3, e4) {
  var o5, n5, l4, h3;
  if (i3 === T) return i3;
  let r4 = void 0 !== e4 ? null === (o5 = s5._$Co) || void 0 === o5 ? void 0 : o5[e4] : s5._$Cl;
  const u3 = d2(i3) ? void 0 : i3._$litDirective$;
  return (null == r4 ? void 0 : r4.constructor) !== u3 && (null === (n5 = null == r4 ? void 0 : r4._$AO) || void 0 === n5 || n5.call(r4, false), void 0 === u3 ? r4 = void 0 : (r4 = new u3(t3), r4._$AT(t3, s5, e4)), void 0 !== e4 ? (null !== (l4 = (h3 = s5)._$Co) && void 0 !== l4 ? l4 : h3._$Co = [])[e4] = r4 : s5._$Cl = r4), void 0 !== r4 && (i3 = S2(t3, r4._$AS(t3, i3.values), r4, e4)), i3;
}
var t2, i2, s3, e3, o3, n3, l2, h2, r3, u2, d2, c2, v, a2, f, _, m, p, g, $, y, w, x, b, T, A, E, C, V, N, M, R, k, H, I, L, z, Z, B, D;
var init_lit_html = __esm({
  "node_modules/lit-html/lit-html.js"() {
    i2 = window;
    s3 = i2.trustedTypes;
    e3 = s3 ? s3.createPolicy("lit-html", { createHTML: (t3) => t3 }) : void 0;
    o3 = "$lit$";
    n3 = `lit$${(Math.random() + "").slice(9)}$`;
    l2 = "?" + n3;
    h2 = `<${l2}>`;
    r3 = document;
    u2 = () => r3.createComment("");
    d2 = (t3) => null === t3 || "object" != typeof t3 && "function" != typeof t3;
    c2 = Array.isArray;
    v = (t3) => c2(t3) || "function" == typeof (null == t3 ? void 0 : t3[Symbol.iterator]);
    a2 = "[ 	\n\f\r]";
    f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    _ = /-->/g;
    m = />/g;
    p = RegExp(`>|${a2}(?:([^\\s"'>=/]+)(${a2}*=${a2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
    g = /'/g;
    $ = /"/g;
    y = /^(?:script|style|textarea|title)$/i;
    w = (t3) => (i3, ...s5) => ({ _$litType$: t3, strings: i3, values: s5 });
    x = w(1);
    b = w(2);
    T = Symbol.for("lit-noChange");
    A = Symbol.for("lit-nothing");
    E = /* @__PURE__ */ new WeakMap();
    C = r3.createTreeWalker(r3, 129, null, false);
    V = (t3, i3) => {
      const s5 = t3.length - 1, e4 = [];
      let l4, r4 = 2 === i3 ? "<svg>" : "", u3 = f;
      for (let i4 = 0; i4 < s5; i4++) {
        const s6 = t3[i4];
        let d3, c3, v2 = -1, a3 = 0;
        for (; a3 < s6.length && (u3.lastIndex = a3, c3 = u3.exec(s6), null !== c3); ) a3 = u3.lastIndex, u3 === f ? "!--" === c3[1] ? u3 = _ : void 0 !== c3[1] ? u3 = m : void 0 !== c3[2] ? (y.test(c3[2]) && (l4 = RegExp("</" + c3[2], "g")), u3 = p) : void 0 !== c3[3] && (u3 = p) : u3 === p ? ">" === c3[0] ? (u3 = null != l4 ? l4 : f, v2 = -1) : void 0 === c3[1] ? v2 = -2 : (v2 = u3.lastIndex - c3[2].length, d3 = c3[1], u3 = void 0 === c3[3] ? p : '"' === c3[3] ? $ : g) : u3 === $ || u3 === g ? u3 = p : u3 === _ || u3 === m ? u3 = f : (u3 = p, l4 = void 0);
        const w2 = u3 === p && t3[i4 + 1].startsWith("/>") ? " " : "";
        r4 += u3 === f ? s6 + h2 : v2 >= 0 ? (e4.push(d3), s6.slice(0, v2) + o3 + s6.slice(v2) + n3 + w2) : s6 + n3 + (-2 === v2 ? (e4.push(void 0), i4) : w2);
      }
      return [P(t3, r4 + (t3[s5] || "<?>") + (2 === i3 ? "</svg>" : "")), e4];
    };
    N = class _N {
      constructor({ strings: t3, _$litType$: i3 }, e4) {
        let h3;
        this.parts = [];
        let r4 = 0, d3 = 0;
        const c3 = t3.length - 1, v2 = this.parts, [a3, f2] = V(t3, i3);
        if (this.el = _N.createElement(a3, e4), C.currentNode = this.el.content, 2 === i3) {
          const t4 = this.el.content, i4 = t4.firstChild;
          i4.remove(), t4.append(...i4.childNodes);
        }
        for (; null !== (h3 = C.nextNode()) && v2.length < c3; ) {
          if (1 === h3.nodeType) {
            if (h3.hasAttributes()) {
              const t4 = [];
              for (const i4 of h3.getAttributeNames()) if (i4.endsWith(o3) || i4.startsWith(n3)) {
                const s5 = f2[d3++];
                if (t4.push(i4), void 0 !== s5) {
                  const t5 = h3.getAttribute(s5.toLowerCase() + o3).split(n3), i5 = /([.?@])?(.*)/.exec(s5);
                  v2.push({ type: 1, index: r4, name: i5[2], strings: t5, ctor: "." === i5[1] ? H : "?" === i5[1] ? L : "@" === i5[1] ? z : k });
                } else v2.push({ type: 6, index: r4 });
              }
              for (const i4 of t4) h3.removeAttribute(i4);
            }
            if (y.test(h3.tagName)) {
              const t4 = h3.textContent.split(n3), i4 = t4.length - 1;
              if (i4 > 0) {
                h3.textContent = s3 ? s3.emptyScript : "";
                for (let s5 = 0; s5 < i4; s5++) h3.append(t4[s5], u2()), C.nextNode(), v2.push({ type: 2, index: ++r4 });
                h3.append(t4[i4], u2());
              }
            }
          } else if (8 === h3.nodeType) if (h3.data === l2) v2.push({ type: 2, index: r4 });
          else {
            let t4 = -1;
            for (; -1 !== (t4 = h3.data.indexOf(n3, t4 + 1)); ) v2.push({ type: 7, index: r4 }), t4 += n3.length - 1;
          }
          r4++;
        }
      }
      static createElement(t3, i3) {
        const s5 = r3.createElement("template");
        return s5.innerHTML = t3, s5;
      }
    };
    M = class {
      constructor(t3, i3) {
        this._$AV = [], this._$AN = void 0, this._$AD = t3, this._$AM = i3;
      }
      get parentNode() {
        return this._$AM.parentNode;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      u(t3) {
        var i3;
        const { el: { content: s5 }, parts: e4 } = this._$AD, o5 = (null !== (i3 = null == t3 ? void 0 : t3.creationScope) && void 0 !== i3 ? i3 : r3).importNode(s5, true);
        C.currentNode = o5;
        let n5 = C.nextNode(), l4 = 0, h3 = 0, u3 = e4[0];
        for (; void 0 !== u3; ) {
          if (l4 === u3.index) {
            let i4;
            2 === u3.type ? i4 = new R(n5, n5.nextSibling, this, t3) : 1 === u3.type ? i4 = new u3.ctor(n5, u3.name, u3.strings, this, t3) : 6 === u3.type && (i4 = new Z(n5, this, t3)), this._$AV.push(i4), u3 = e4[++h3];
          }
          l4 !== (null == u3 ? void 0 : u3.index) && (n5 = C.nextNode(), l4++);
        }
        return C.currentNode = r3, o5;
      }
      v(t3) {
        let i3 = 0;
        for (const s5 of this._$AV) void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t3, s5, i3), i3 += s5.strings.length - 2) : s5._$AI(t3[i3])), i3++;
      }
    };
    R = class _R {
      constructor(t3, i3, s5, e4) {
        var o5;
        this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t3, this._$AB = i3, this._$AM = s5, this.options = e4, this._$Cp = null === (o5 = null == e4 ? void 0 : e4.isConnected) || void 0 === o5 || o5;
      }
      get _$AU() {
        var t3, i3;
        return null !== (i3 = null === (t3 = this._$AM) || void 0 === t3 ? void 0 : t3._$AU) && void 0 !== i3 ? i3 : this._$Cp;
      }
      get parentNode() {
        let t3 = this._$AA.parentNode;
        const i3 = this._$AM;
        return void 0 !== i3 && 11 === (null == t3 ? void 0 : t3.nodeType) && (t3 = i3.parentNode), t3;
      }
      get startNode() {
        return this._$AA;
      }
      get endNode() {
        return this._$AB;
      }
      _$AI(t3, i3 = this) {
        t3 = S2(this, t3, i3), d2(t3) ? t3 === A || null == t3 || "" === t3 ? (this._$AH !== A && this._$AR(), this._$AH = A) : t3 !== this._$AH && t3 !== T && this._(t3) : void 0 !== t3._$litType$ ? this.g(t3) : void 0 !== t3.nodeType ? this.$(t3) : v(t3) ? this.T(t3) : this._(t3);
      }
      k(t3) {
        return this._$AA.parentNode.insertBefore(t3, this._$AB);
      }
      $(t3) {
        this._$AH !== t3 && (this._$AR(), this._$AH = this.k(t3));
      }
      _(t3) {
        this._$AH !== A && d2(this._$AH) ? this._$AA.nextSibling.data = t3 : this.$(r3.createTextNode(t3)), this._$AH = t3;
      }
      g(t3) {
        var i3;
        const { values: s5, _$litType$: e4 } = t3, o5 = "number" == typeof e4 ? this._$AC(t3) : (void 0 === e4.el && (e4.el = N.createElement(P(e4.h, e4.h[0]), this.options)), e4);
        if ((null === (i3 = this._$AH) || void 0 === i3 ? void 0 : i3._$AD) === o5) this._$AH.v(s5);
        else {
          const t4 = new M(o5, this), i4 = t4.u(this.options);
          t4.v(s5), this.$(i4), this._$AH = t4;
        }
      }
      _$AC(t3) {
        let i3 = E.get(t3.strings);
        return void 0 === i3 && E.set(t3.strings, i3 = new N(t3)), i3;
      }
      T(t3) {
        c2(this._$AH) || (this._$AH = [], this._$AR());
        const i3 = this._$AH;
        let s5, e4 = 0;
        for (const o5 of t3) e4 === i3.length ? i3.push(s5 = new _R(this.k(u2()), this.k(u2()), this, this.options)) : s5 = i3[e4], s5._$AI(o5), e4++;
        e4 < i3.length && (this._$AR(s5 && s5._$AB.nextSibling, e4), i3.length = e4);
      }
      _$AR(t3 = this._$AA.nextSibling, i3) {
        var s5;
        for (null === (s5 = this._$AP) || void 0 === s5 || s5.call(this, false, true, i3); t3 && t3 !== this._$AB; ) {
          const i4 = t3.nextSibling;
          t3.remove(), t3 = i4;
        }
      }
      setConnected(t3) {
        var i3;
        void 0 === this._$AM && (this._$Cp = t3, null === (i3 = this._$AP) || void 0 === i3 || i3.call(this, t3));
      }
    };
    k = class {
      constructor(t3, i3, s5, e4, o5) {
        this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t3, this.name = i3, this._$AM = e4, this.options = o5, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = A;
      }
      get tagName() {
        return this.element.tagName;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t3, i3 = this, s5, e4) {
        const o5 = this.strings;
        let n5 = false;
        if (void 0 === o5) t3 = S2(this, t3, i3, 0), n5 = !d2(t3) || t3 !== this._$AH && t3 !== T, n5 && (this._$AH = t3);
        else {
          const e5 = t3;
          let l4, h3;
          for (t3 = o5[0], l4 = 0; l4 < o5.length - 1; l4++) h3 = S2(this, e5[s5 + l4], i3, l4), h3 === T && (h3 = this._$AH[l4]), n5 || (n5 = !d2(h3) || h3 !== this._$AH[l4]), h3 === A ? t3 = A : t3 !== A && (t3 += (null != h3 ? h3 : "") + o5[l4 + 1]), this._$AH[l4] = h3;
        }
        n5 && !e4 && this.j(t3);
      }
      j(t3) {
        t3 === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t3 ? t3 : "");
      }
    };
    H = class extends k {
      constructor() {
        super(...arguments), this.type = 3;
      }
      j(t3) {
        this.element[this.name] = t3 === A ? void 0 : t3;
      }
    };
    I = s3 ? s3.emptyScript : "";
    L = class extends k {
      constructor() {
        super(...arguments), this.type = 4;
      }
      j(t3) {
        t3 && t3 !== A ? this.element.setAttribute(this.name, I) : this.element.removeAttribute(this.name);
      }
    };
    z = class extends k {
      constructor(t3, i3, s5, e4, o5) {
        super(t3, i3, s5, e4, o5), this.type = 5;
      }
      _$AI(t3, i3 = this) {
        var s5;
        if ((t3 = null !== (s5 = S2(this, t3, i3, 0)) && void 0 !== s5 ? s5 : A) === T) return;
        const e4 = this._$AH, o5 = t3 === A && e4 !== A || t3.capture !== e4.capture || t3.once !== e4.once || t3.passive !== e4.passive, n5 = t3 !== A && (e4 === A || o5);
        o5 && this.element.removeEventListener(this.name, this, e4), n5 && this.element.addEventListener(this.name, this, t3), this._$AH = t3;
      }
      handleEvent(t3) {
        var i3, s5;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s5 = null === (i3 = this.options) || void 0 === i3 ? void 0 : i3.host) && void 0 !== s5 ? s5 : this.element, t3) : this._$AH.handleEvent(t3);
      }
    };
    Z = class {
      constructor(t3, i3, s5) {
        this.element = t3, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s5;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t3) {
        S2(this, t3);
      }
    };
    B = i2.litHtmlPolyfillSupport;
    null == B || B(N, R), (null !== (t2 = i2.litHtmlVersions) && void 0 !== t2 ? t2 : i2.litHtmlVersions = []).push("2.8.0");
    D = (t3, i3, s5) => {
      var e4, o5;
      const n5 = null !== (e4 = null == s5 ? void 0 : s5.renderBefore) && void 0 !== e4 ? e4 : i3;
      let l4 = n5._$litPart$;
      if (void 0 === l4) {
        const t4 = null !== (o5 = null == s5 ? void 0 : s5.renderBefore) && void 0 !== o5 ? o5 : null;
        n5._$litPart$ = l4 = new R(i3.insertBefore(u2(), t4), t4, void 0, null != s5 ? s5 : {});
      }
      return l4._$AI(t3), l4;
    };
  }
});

// node_modules/lit-element/lit-element.js
var l3, o4, s4, n4;
var init_lit_element = __esm({
  "node_modules/lit-element/lit-element.js"() {
    init_reactive_element();
    init_reactive_element();
    init_lit_html();
    init_lit_html();
    s4 = class extends u {
      constructor() {
        super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
      }
      createRenderRoot() {
        var t3, e4;
        const i3 = super.createRenderRoot();
        return null !== (t3 = (e4 = this.renderOptions).renderBefore) && void 0 !== t3 || (e4.renderBefore = i3.firstChild), i3;
      }
      update(t3) {
        const i3 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t3), this._$Do = D(i3, this.renderRoot, this.renderOptions);
      }
      connectedCallback() {
        var t3;
        super.connectedCallback(), null === (t3 = this._$Do) || void 0 === t3 || t3.setConnected(true);
      }
      disconnectedCallback() {
        var t3;
        super.disconnectedCallback(), null === (t3 = this._$Do) || void 0 === t3 || t3.setConnected(false);
      }
      render() {
        return T;
      }
    };
    s4.finalized = true, s4._$litElement$ = true, null === (l3 = globalThis.litElementHydrateSupport) || void 0 === l3 || l3.call(globalThis, { LitElement: s4 });
    n4 = globalThis.litElementPolyfillSupport;
    null == n4 || n4({ LitElement: s4 });
    (null !== (o4 = globalThis.litElementVersions) && void 0 !== o4 ? o4 : globalThis.litElementVersions = []).push("3.3.3");
  }
});

// node_modules/lit-html/is-server.js
var init_is_server = __esm({
  "node_modules/lit-html/is-server.js"() {
  }
});

// node_modules/lit/index.js
var init_lit = __esm({
  "node_modules/lit/index.js"() {
    init_reactive_element();
    init_lit_html();
    init_lit_element();
    init_is_server();
  }
});

// src/mas-mnemonic.js
var mas_mnemonic_exports = {};
__export(mas_mnemonic_exports, {
  default: () => MasMnemonic
});
function hasSpectrumTooltip() {
  return customElements.get("sp-tooltip") !== void 0 && customElements.get("overlay-trigger") !== void 0 && document.querySelector("sp-theme") !== null;
}
var MasMnemonic;
var init_mas_mnemonic = __esm({
  "src/mas-mnemonic.js"() {
    init_lit();
    MasMnemonic = class extends s4 {
      constructor() {
        super();
        this.content = "";
        this.placement = "top";
        this.variant = "info";
        this.size = "xs";
      }
      get effectiveContent() {
        return this.tooltipText || this.mnemonicText || this.content || "";
      }
      get effectivePlacement() {
        return this.tooltipPlacement || this.mnemonicPlacement || this.placement || "top";
      }
      renderIcon() {
        if (!this.src) return x`<slot></slot>`;
        return x`<merch-icon
            src="${this.src}"
            size="${this.size}"
        ></merch-icon>`;
      }
      render() {
        const content = this.effectiveContent;
        const placement = this.effectivePlacement;
        if (!content) {
          return this.renderIcon();
        }
        const useSpectrum = hasSpectrumTooltip();
        if (useSpectrum) {
          return x`
                <overlay-trigger placement="${placement}">
                    <span slot="trigger">${this.renderIcon()}</span>
                    <sp-tooltip
                        placement="${placement}"
                        variant="${this.variant}"
                    >
                        ${content}
                    </sp-tooltip>
                </overlay-trigger>
            `;
        } else {
          return x`
                <span
                    class="css-tooltip ${placement}"
                    data-tooltip="${content}"
                    tabindex="0"
                    role="img"
                    aria-label="${content}"
                >
                    ${this.renderIcon()}
                </span>
            `;
        }
      }
    };
    __publicField(MasMnemonic, "properties", {
      content: { type: String },
      placement: { type: String },
      variant: { type: String },
      // Icon-based tooltip properties
      src: { type: String },
      size: { type: String },
      tooltipText: { type: String, attribute: "tooltip-text" },
      tooltipPlacement: { type: String, attribute: "tooltip-placement" },
      // Support studio's mnemonic attribute names
      mnemonicText: { type: String, attribute: "mnemonic-text" },
      mnemonicPlacement: { type: String, attribute: "mnemonic-placement" }
    });
    __publicField(MasMnemonic, "styles", i`
        :host {
            display: contents;
            overflow: visible;
        }

        /* CSS tooltip styles - these are local fallbacks, main styles in global.css.js */
        .css-tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .css-tooltip[data-tooltip]::before {
            content: attr(data-tooltip);
            position: absolute;
            z-index: 999;
            background: var(--spectrum-gray-800, #323232);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            white-space: normal;
            width: max-content;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
            text-align: center;
        }

        .css-tooltip[data-tooltip]::after {
            content: '';
            position: absolute;
            z-index: 999;
            width: 0;
            height: 0;
            border: 6px solid transparent;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .css-tooltip:hover[data-tooltip]::before,
        .css-tooltip:hover[data-tooltip]::after,
        .css-tooltip:focus[data-tooltip]::before,
        .css-tooltip:focus[data-tooltip]::after {
            opacity: 1;
        }

        /* Position variants */
        .css-tooltip.top[data-tooltip]::before {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 16px;
        }

        .css-tooltip.top[data-tooltip]::after {
            top: -80%;
            left: 50%;
            transform: translateX(-50%);
            border-color: var(--spectrum-gray-800, #323232) transparent
                transparent transparent;
        }

        .css-tooltip.bottom[data-tooltip]::before {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px;
        }

        .css-tooltip.bottom[data-tooltip]::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 5px;
            border-bottom-color: var(--spectrum-gray-800, #323232);
        }

        .css-tooltip.left[data-tooltip]::before {
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 10px;
        }

        .css-tooltip.left[data-tooltip]::after {
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 5px;
            border-left-color: var(--spectrum-gray-800, #323232);
        }

        .css-tooltip.right[data-tooltip]::before {
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 10px;
        }

        .css-tooltip.right[data-tooltip]::after {
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 5px;
            border-right-color: var(--spectrum-gray-800, #323232);
        }
    `);
    customElements.define("mas-mnemonic", MasMnemonic);
  }
});

// src/lana.js
var config = {
  clientId: "merch-at-scale",
  delimiter: "\xB6",
  ignoredProperties: ["analytics", "literals", "element"],
  serializableTypes: ["Array", "Object"],
  sampleRate: 1,
  tags: "acom",
  isProdDomain: false
};
var PAGE_LIMIT = 1e3;
function isError(value) {
  return value instanceof Error || typeof value?.originatingRequest === "string";
}
function serializeValue(value) {
  if (value == null) return void 0;
  const type = typeof value;
  if (type === "function") {
    return value.name ? `function ${value.name}` : "function";
  }
  if (type === "object") {
    if (value instanceof Error) return value.message;
    if (typeof value.originatingRequest === "string") {
      const { message, originatingRequest, status } = value;
      return [message, status, originatingRequest].filter(Boolean).join(" ");
    }
    const objectType = value[Symbol.toStringTag] ?? Object.getPrototypeOf(value).constructor.name;
    if (!config.serializableTypes.includes(objectType)) return objectType;
  }
  return value;
}
function serializeParam(key, value) {
  if (config.ignoredProperties.includes(key)) return void 0;
  return serializeValue(value);
}
var lanaAppender = {
  append(entry) {
    if (entry.level !== "error") return;
    const { message, params } = entry;
    const errors = [];
    const values = [];
    let payload = message;
    params.forEach((param) => {
      if (param != null) {
        (isError(param) ? errors : values).push(param);
      }
    });
    if (errors.length) {
      payload += " " + errors.map(serializeValue).join(" ");
    }
    const { pathname, search } = window.location;
    let page = `${config.delimiter}page=${pathname}${search}`;
    if (page.length > PAGE_LIMIT) {
      page = `${page.slice(0, PAGE_LIMIT)}<trunc>`;
    }
    payload += page;
    if (values.length) {
      payload += `${config.delimiter}facts=`;
      payload += JSON.stringify(values, serializeParam);
    }
    window.lana?.log(payload, config);
  }
};
function updateConfig(newConfig) {
  Object.assign(
    config,
    Object.fromEntries(
      Object.entries(newConfig).filter(
        ([key, value]) => key in config && value !== "" && value !== null && value !== void 0 && !Number.isNaN(value)
        // Correctly exclude NaN
      )
    )
  );
}

// src/constants.js
var constants_exports = {};
__export(constants_exports, {
  CLASS_NAME_FAILED: () => CLASS_NAME_FAILED,
  CLASS_NAME_HIDDEN: () => CLASS_NAME_HIDDEN,
  CLASS_NAME_PENDING: () => CLASS_NAME_PENDING,
  CLASS_NAME_RESOLVED: () => CLASS_NAME_RESOLVED,
  CheckoutWorkflow: () => CheckoutWorkflow,
  CheckoutWorkflowStep: () => CheckoutWorkflowStep,
  Commitment: () => Commitment,
  ERROR_MESSAGE_BAD_REQUEST: () => ERROR_MESSAGE_BAD_REQUEST,
  ERROR_MESSAGE_MISSING_LITERALS_URL: () => ERROR_MESSAGE_MISSING_LITERALS_URL,
  ERROR_MESSAGE_OFFER_NOT_FOUND: () => ERROR_MESSAGE_OFFER_NOT_FOUND,
  EVENT_AEM_ERROR: () => EVENT_AEM_ERROR,
  EVENT_AEM_LOAD: () => EVENT_AEM_LOAD,
  EVENT_MAS_ERROR: () => EVENT_MAS_ERROR,
  EVENT_MAS_READY: () => EVENT_MAS_READY,
  EVENT_MERCH_ADDON_AND_QUANTITY_UPDATE: () => EVENT_MERCH_ADDON_AND_QUANTITY_UPDATE,
  EVENT_MERCH_CARD_ACTION_MENU_TOGGLE: () => EVENT_MERCH_CARD_ACTION_MENU_TOGGLE,
  EVENT_MERCH_CARD_COLLECTION_LITERALS_CHANGED: () => EVENT_MERCH_CARD_COLLECTION_LITERALS_CHANGED,
  EVENT_MERCH_CARD_COLLECTION_SHOWMORE: () => EVENT_MERCH_CARD_COLLECTION_SHOWMORE,
  EVENT_MERCH_CARD_COLLECTION_SIDENAV_ATTACHED: () => EVENT_MERCH_CARD_COLLECTION_SIDENAV_ATTACHED,
  EVENT_MERCH_CARD_COLLECTION_SORT: () => EVENT_MERCH_CARD_COLLECTION_SORT,
  EVENT_MERCH_CARD_QUANTITY_CHANGE: () => EVENT_MERCH_CARD_QUANTITY_CHANGE,
  EVENT_MERCH_OFFER_READY: () => EVENT_MERCH_OFFER_READY,
  EVENT_MERCH_OFFER_SELECT_READY: () => EVENT_MERCH_OFFER_SELECT_READY,
  EVENT_MERCH_QUANTITY_SELECTOR_CHANGE: () => EVENT_MERCH_QUANTITY_SELECTOR_CHANGE,
  EVENT_MERCH_SEARCH_CHANGE: () => EVENT_MERCH_SEARCH_CHANGE,
  EVENT_MERCH_SIDENAV_SELECT: () => EVENT_MERCH_SIDENAV_SELECT,
  EVENT_MERCH_STOCK_CHANGE: () => EVENT_MERCH_STOCK_CHANGE,
  EVENT_MERCH_STORAGE_CHANGE: () => EVENT_MERCH_STORAGE_CHANGE,
  EVENT_OFFER_SELECTED: () => EVENT_OFFER_SELECTED,
  EVENT_TYPE_FAILED: () => EVENT_TYPE_FAILED,
  EVENT_TYPE_READY: () => EVENT_TYPE_READY,
  EVENT_TYPE_RESOLVED: () => EVENT_TYPE_RESOLVED,
  Env: () => Env,
  FF_DEFAULTS: () => FF_DEFAULTS,
  HEADER_X_REQUEST_ID: () => HEADER_X_REQUEST_ID,
  LOG_NAMESPACE: () => LOG_NAMESPACE,
  Landscape: () => Landscape,
  MARK_DURATION_SUFFIX: () => MARK_DURATION_SUFFIX,
  MARK_START_SUFFIX: () => MARK_START_SUFFIX,
  MODAL_TYPE_3_IN_1: () => MODAL_TYPE_3_IN_1,
  NAMESPACE: () => NAMESPACE,
  PARAM_AOS_API_KEY: () => PARAM_AOS_API_KEY,
  PARAM_ENV: () => PARAM_ENV,
  PARAM_LANDSCAPE: () => PARAM_LANDSCAPE,
  PARAM_MAS_PREVIEW: () => PARAM_MAS_PREVIEW,
  PARAM_WCS_API_KEY: () => PARAM_WCS_API_KEY,
  PROVIDER_ENVIRONMENT: () => PROVIDER_ENVIRONMENT,
  SELECTOR_MAS_CHECKOUT_LINK: () => SELECTOR_MAS_CHECKOUT_LINK,
  SELECTOR_MAS_ELEMENT: () => SELECTOR_MAS_ELEMENT,
  SELECTOR_MAS_INLINE_PRICE: () => SELECTOR_MAS_INLINE_PRICE,
  SELECTOR_MAS_SP_BUTTON: () => SELECTOR_MAS_SP_BUTTON,
  SELECTOR_MAS_UPT_LINK: () => SELECTOR_MAS_UPT_LINK,
  SORT_ORDER: () => SORT_ORDER,
  STATE_FAILED: () => STATE_FAILED,
  STATE_PENDING: () => STATE_PENDING,
  STATE_RESOLVED: () => STATE_RESOLVED,
  SUPPORTED_COUNTRIES: () => SUPPORTED_COUNTRIES,
  SUPPORTED_LANGUAGES: () => SUPPORTED_LANGUAGES,
  SUPPORTED_LANGUAGE_COUNTRY: () => SUPPORTED_LANGUAGE_COUNTRY,
  TAG_NAME_SERVICE: () => TAG_NAME_SERVICE,
  TEMPLATE_PRICE: () => TEMPLATE_PRICE,
  TEMPLATE_PRICE_ANNUAL: () => TEMPLATE_PRICE_ANNUAL,
  TEMPLATE_PRICE_LEGAL: () => TEMPLATE_PRICE_LEGAL,
  TEMPLATE_PRICE_STRIKETHROUGH: () => TEMPLATE_PRICE_STRIKETHROUGH,
  Term: () => Term,
  WCS_PROD_URL: () => WCS_PROD_URL,
  WCS_STAGE_URL: () => WCS_STAGE_URL
});
var Commitment = Object.freeze({
  MONTH: "MONTH",
  YEAR: "YEAR",
  TWO_YEARS: "TWO_YEARS",
  THREE_YEARS: "THREE_YEARS",
  PERPETUAL: "PERPETUAL",
  TERM_LICENSE: "TERM_LICENSE",
  ACCESS_PASS: "ACCESS_PASS",
  THREE_MONTHS: "THREE_MONTHS",
  SIX_MONTHS: "SIX_MONTHS"
});
var Term = Object.freeze({
  ANNUAL: "ANNUAL",
  MONTHLY: "MONTHLY",
  TWO_YEARS: "TWO_YEARS",
  THREE_YEARS: "THREE_YEARS",
  P1D: "P1D",
  P1Y: "P1Y",
  P3Y: "P3Y",
  P10Y: "P10Y",
  P15Y: "P15Y",
  P3D: "P3D",
  P7D: "P7D",
  P30D: "P30D",
  HALF_YEARLY: "HALF_YEARLY",
  QUARTERLY: "QUARTERLY"
});
var NAMESPACE = "merch";
var CLASS_NAME_HIDDEN = "hidden";
var EVENT_TYPE_READY = "wcms:commerce:ready";
var TAG_NAME_SERVICE = "mas-commerce-service";
var SELECTOR_MAS_INLINE_PRICE = 'span[is="inline-price"][data-wcs-osi]';
var SELECTOR_MAS_CHECKOUT_LINK = 'a[is="checkout-link"][data-wcs-osi],button[is="checkout-button"][data-wcs-osi]';
var SELECTOR_MAS_SP_BUTTON = "sp-button[data-wcs-osi]";
var SELECTOR_MAS_UPT_LINK = 'a[is="upt-link"]';
var SELECTOR_MAS_ELEMENT = `${SELECTOR_MAS_INLINE_PRICE},${SELECTOR_MAS_CHECKOUT_LINK},${SELECTOR_MAS_UPT_LINK}`;
var EVENT_MERCH_OFFER_READY = "merch-offer:ready";
var EVENT_MERCH_OFFER_SELECT_READY = "merch-offer-select:ready";
var EVENT_MERCH_CARD_ACTION_MENU_TOGGLE = "merch-card:action-menu-toggle";
var EVENT_OFFER_SELECTED = "merch-offer:selected";
var EVENT_MERCH_STOCK_CHANGE = "merch-stock:change";
var EVENT_MERCH_STORAGE_CHANGE = "merch-storage:change";
var EVENT_MERCH_QUANTITY_SELECTOR_CHANGE = "merch-quantity-selector:change";
var EVENT_MERCH_CARD_QUANTITY_CHANGE = "merch-card-quantity:change";
var EVENT_MERCH_ADDON_AND_QUANTITY_UPDATE = "merch-modal:addon-and-quantity-update";
var EVENT_MERCH_SEARCH_CHANGE = "merch-search:change";
var EVENT_MERCH_CARD_COLLECTION_SORT = "merch-card-collection:sort";
var EVENT_MERCH_CARD_COLLECTION_LITERALS_CHANGED = "merch-card-collection:literals-changed";
var EVENT_MERCH_CARD_COLLECTION_SIDENAV_ATTACHED = "merch-card-collection:sidenav-attached";
var EVENT_MERCH_CARD_COLLECTION_SHOWMORE = "merch-card-collection:showmore";
var EVENT_MERCH_SIDENAV_SELECT = "merch-sidenav:select";
var EVENT_AEM_LOAD = "aem:load";
var EVENT_AEM_ERROR = "aem:error";
var EVENT_MAS_READY = "mas:ready";
var EVENT_MAS_ERROR = "mas:error";
var CLASS_NAME_FAILED = "placeholder-failed";
var CLASS_NAME_PENDING = "placeholder-pending";
var CLASS_NAME_RESOLVED = "placeholder-resolved";
var ERROR_MESSAGE_BAD_REQUEST = "Bad WCS request";
var ERROR_MESSAGE_OFFER_NOT_FOUND = "Commerce offer not found";
var ERROR_MESSAGE_MISSING_LITERALS_URL = "Literals URL not provided";
var EVENT_TYPE_FAILED = "mas:failed";
var EVENT_TYPE_RESOLVED = "mas:resolved";
var LOG_NAMESPACE = "mas/commerce";
var PARAM_MAS_PREVIEW = "mas.preview";
var PARAM_ENV = "commerce.env";
var PARAM_LANDSCAPE = "commerce.landscape";
var PARAM_AOS_API_KEY = "commerce.aosKey";
var PARAM_WCS_API_KEY = "commerce.wcsKey";
var WCS_PROD_URL = "https://www.adobe.com/web_commerce_artifact";
var WCS_STAGE_URL = "https://www.stage.adobe.com/web_commerce_artifact_stage";
var STATE_FAILED = "failed";
var STATE_PENDING = "pending";
var STATE_RESOLVED = "resolved";
var Landscape = {
  DRAFT: "DRAFT",
  PUBLISHED: "PUBLISHED"
};
var HEADER_X_REQUEST_ID = "X-Request-Id";
var CheckoutWorkflowStep = Object.freeze({
  SEGMENTATION: "segmentation",
  BUNDLE: "bundle",
  COMMITMENT: "commitment",
  RECOMMENDATION: "recommendation",
  EMAIL: "email",
  PAYMENT: "payment",
  CHANGE_PLAN_TEAM_PLANS: "change-plan/team-upgrade/plans",
  CHANGE_PLAN_TEAM_PAYMENT: "change-plan/team-upgrade/payment"
});
var CheckoutWorkflow = "UCv3";
var Env = Object.freeze({
  STAGE: "STAGE",
  PRODUCTION: "PRODUCTION",
  LOCAL: "LOCAL"
});
var PROVIDER_ENVIRONMENT = {
  PRODUCTION: "PRODUCTION"
};
var MODAL_TYPE_3_IN_1 = {
  TWP: "twp",
  D2P: "d2p",
  CRM: "crm"
};
var MARK_START_SUFFIX = ":start";
var MARK_DURATION_SUFFIX = ":duration";
var TEMPLATE_PRICE = "price";
var TEMPLATE_PRICE_STRIKETHROUGH = "price-strikethrough";
var TEMPLATE_PRICE_ANNUAL = "annual";
var TEMPLATE_PRICE_LEGAL = "legal";
var FF_DEFAULTS = "mas-ff-defaults";
var SORT_ORDER = {
  alphabetical: "alphabetical",
  authored: "authored"
};
var SUPPORTED_LANGUAGE_COUNTRY = [
  "en_US",
  "ar_DZ",
  "ar_EG",
  "ar_SA",
  "bg_BG",
  "cs_CZ",
  "da_DK",
  "de_AT",
  "de_CH",
  "de_DE",
  "de_LU",
  "el_GR",
  "en_AU",
  "en_AZ",
  "en_BE",
  "en_CA",
  "en_DZ",
  "en_EG",
  "en_GB",
  "en_GR",
  "en_ID",
  "en_IE",
  "en_IN",
  "en_LU",
  "en_MT",
  "en_MU",
  "en_MY",
  "en_NG",
  "en_NZ",
  "en_SA",
  "en_SG",
  "en_TH",
  "en_ZA",
  "es_AR",
  "es_CL",
  "es_CO",
  "es_CR",
  "es_DO",
  "es_EC",
  "es_ES",
  "es_GT",
  "es_MX",
  "es_PE",
  "es_US",
  "et_EE",
  "fi_FI",
  "fr_BE",
  "fr_CH",
  "fr_FR",
  "fr_LU",
  "hi_IN",
  "hu_HU",
  "in_ID",
  "it_CH",
  "it_IT",
  "iw_IL",
  "ja_JP",
  "ko_KR",
  "lt_LT",
  "lv_LV",
  "ms_MY",
  "nb_NO",
  "nl_BE",
  "nl_NL",
  "pl_PL",
  "pt_BR",
  "pt_PT",
  "ro_RO",
  "ru_AZ",
  "ru_RU",
  "sk_SK",
  "sl_SI",
  "sv_SE",
  "th_TH",
  "tr_TR",
  "uk_UA",
  "zh-Hans_CN",
  "zh-Hant_HK",
  "zh-Hant_TW"
];
var SUPPORTED_LANGUAGES = [
  "en",
  "ar",
  "bg",
  "cs",
  "da",
  "de",
  "el",
  "es",
  "et",
  "fi",
  "fr",
  "hi",
  "hu",
  "in",
  "it",
  "iw",
  "ja",
  "ko",
  "lt",
  "lv",
  "ms",
  "nb",
  "nl",
  "pl",
  "pt",
  "ro",
  "ru",
  "sk",
  "sl",
  "sv",
  "th",
  "tr",
  "uk",
  "zh-Hans",
  "zh-Hant",
  "fr-ca",
  "he",
  "no",
  "zh-hant",
  "fil",
  "id",
  "vi",
  "en-gb",
  "es-419"
];
var SUPPORTED_COUNTRIES = [
  "AE",
  "AR",
  "AT",
  "AU",
  "AZ",
  "BE",
  "BG",
  "BR",
  "CA",
  "CH",
  "CL",
  "CN",
  "CO",
  "CR",
  "CY",
  "CZ",
  "DE",
  "DK",
  "DO",
  "DZ",
  "EC",
  "EE",
  "EG",
  "ES",
  "FI",
  "FR",
  "GB",
  "GE",
  "GR",
  "GT",
  "HK",
  "HU",
  "ID",
  "IE",
  "IL",
  "IN",
  "IT",
  "JP",
  "KR",
  "KW",
  "LA",
  "LT",
  "LU",
  "LV",
  "MT",
  "MU",
  "MX",
  "MY",
  "NG",
  "NL",
  "NO",
  "NZ",
  "PE",
  "PH",
  "PL",
  "PR",
  "PT",
  "QA",
  "RO",
  "RU",
  "SA",
  "SE",
  "SG",
  "SI",
  "SK",
  "TH",
  "TR",
  "TW",
  "UA",
  "US",
  "VN",
  "ZA"
];

// ../node_modules/@dexter/tacocat-core/src/utilities.js
var namespace = "tacocat.js";
var equalsCaseInsensitive = (value1, value2) => String(value1 ?? "").toLowerCase() == String(value2 ?? "").toLowerCase();
var escapeHtml = (html) => `${html ?? ""}`.replace(
  /[&<>'"]/g,
  (tag) => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;"
  })[tag] ?? tag
) ?? "";
function getParameter(key, defaults = {}, { metadata = true, search = true, storage = true } = {}) {
  let param;
  if (search && param == null) {
    const params = new URLSearchParams(window.location.search);
    const searchKey = isString(search) ? search : key;
    param = params.get(searchKey);
  }
  if (storage && param == null) {
    const storageKey = isString(storage) ? storage : key;
    param = window.sessionStorage.getItem(storageKey) ?? window.localStorage.getItem(storageKey);
  }
  if (metadata && param == null) {
    const metadataKey = toKebabCase(isString(metadata) ? metadata : key);
    const element = document.documentElement.querySelector(
      `meta[name="${metadataKey}"]`
    );
    param = element?.content;
  }
  return param == null ? defaults[key] : param;
}
var isBoolean = (value) => typeof value === "boolean";
var isFunction = (value) => typeof value === "function";
var isNumber = (value) => typeof value === "number";
var isObject = (value) => value != null && typeof value === "object";
var isString = (value) => typeof value === "string";
var isNotEmptyString = (value) => isString(value) && value;
var isPositiveFiniteNumber = (value) => isNumber(value) && Number.isFinite(value) && value > 0;
function omitProperties(target, test = (value) => value == null || value === "") {
  if (target != null) {
    Object.entries(target).forEach(([key, value]) => {
      if (test(value)) delete target[key];
    });
  }
  return target;
}
function toBoolean(value, defaultValue) {
  if (isBoolean(value)) return value;
  const string = String(value);
  if (string === "1" || string === "true") return true;
  if (string === "0" || string === "false") return false;
  return defaultValue;
}
function toEnumeration(value, enumeration, defaultValue) {
  const values = Object.values(enumeration);
  return values.find((candidate) => equalsCaseInsensitive(candidate, value)) ?? defaultValue ?? values[0];
}
function toKebabCase(value = "") {
  return String(value).replace(
    /(\p{Lowercase_Letter})(\p{Uppercase_Letter})/gu,
    (_2, p1, p2) => `${p1}-${p2}`
  ).replace(/\W+/gu, "-").toLowerCase();
}
function toPositiveFiniteInteger(value, defaultValue = 1) {
  if (!isNumber(value)) {
    value = Number.parseInt(value, 10);
  }
  if (!Number.isNaN(value) && value > 0 && Number.isFinite(value)) {
    return value;
  }
  return defaultValue;
}

// ../node_modules/@dexter/tacocat-core/src/log.js
var epoch = Date.now();
var suffix = () => `(+${Date.now() - epoch}ms)`;
var loggers = /* @__PURE__ */ new Set();
var isDebugEnabled = toBoolean(
  getParameter("tacocat.debug", {}, { metadata: false }),
  false
);
function createLog(source) {
  const prefix = `[${namespace}/${source}]`;
  const assert = (condition, message, ...args) => {
    if (!condition) {
      error(message, ...args);
      return false;
    }
    return true;
  };
  const debug = isDebugEnabled ? (message, ...args) => {
    console.debug(`${prefix} ${message}`, ...args, suffix());
  } : () => {
  };
  const error = (message, ...args) => {
    const prefixedMessage = `${prefix} ${message}`;
    loggers.forEach(
      ([errorLogger]) => errorLogger(prefixedMessage, ...args)
    );
  };
  const warn = (message, ...args) => {
    const prefixedMessage = `${prefix} ${message}`;
    loggers.forEach(
      ([, warnLogger]) => warnLogger(prefixedMessage, ...args)
    );
  };
  return { assert, debug, error, warn };
}
function registerLogger(errorLogger, warnLogger) {
  const logger = [errorLogger, warnLogger];
  loggers.add(logger);
  return () => {
    loggers.delete(logger);
  };
}
registerLogger(
  (message, ...args) => {
    console.error(message, ...args, suffix());
  },
  (message, ...args) => {
    console.warn(message, ...args, suffix());
  }
);

// ../node_modules/@dexter/tacocat-core/src/promotion.js
var NO_PROMO_TEXT = "no promo";
var CLASS = "promo-tag";
var PROMO_VARIANT = "yellow";
var NOPROMO_VARIANT = "neutral";
var fullPromoText = (promo, old, isOverriden) => {
  const promoText = (promo2) => promo2 || NO_PROMO_TEXT;
  const suffix2 = isOverriden ? ` (was "${promoText(old)}")` : "";
  return `${promoText(promo)}${suffix2}`;
};
var PROMO_CONTEXT_CANCEL_VALUE = "cancel-context";
var computePromoStatus = (overriden, configured) => {
  const localPromoUnset = overriden === PROMO_CONTEXT_CANCEL_VALUE;
  const localPromoSet = !localPromoUnset && overriden?.length > 0;
  const isOverriden = (localPromoSet || localPromoUnset) && //in case configured equals override, we consider no override
  (configured && configured != overriden || //in case it does not have been configured, if overriden to cancel,
  // we consider no override
  !configured && !localPromoUnset);
  const isPromo = isOverriden && localPromoSet || !isOverriden && !!configured;
  const effectivePromoCode = isPromo ? overriden || configured : void 0;
  return {
    effectivePromoCode,
    overridenPromoCode: overriden,
    className: isPromo ? CLASS : `${CLASS} no-promo`,
    text: fullPromoText(effectivePromoCode, configured, isOverriden),
    variant: isPromo ? PROMO_VARIANT : NOPROMO_VARIANT,
    isOverriden
  };
};

// ../node_modules/@pandora/data-models-odm/esm/businessDimensions.js
var OfferType;
(function(OfferType2) {
  OfferType2["BASE"] = "BASE";
  OfferType2["TRIAL"] = "TRIAL";
  OfferType2["PROMOTION"] = "PROMOTION";
})(OfferType || (OfferType = {}));
var Commitment2;
(function(Commitment3) {
  Commitment3["MONTH"] = "MONTH";
  Commitment3["YEAR"] = "YEAR";
  Commitment3["TWO_YEARS"] = "TWO_YEARS";
  Commitment3["THREE_YEARS"] = "THREE_YEARS";
  Commitment3["PERPETUAL"] = "PERPETUAL";
  Commitment3["TERM_LICENSE"] = "TERM_LICENSE";
  Commitment3["ACCESS_PASS"] = "ACCESS_PASS";
  Commitment3["THREE_MONTHS"] = "THREE_MONTHS";
  Commitment3["SIX_MONTHS"] = "SIX_MONTHS";
})(Commitment2 || (Commitment2 = {}));
var Term2;
(function(Term3) {
  Term3["ANNUAL"] = "ANNUAL";
  Term3["MONTHLY"] = "MONTHLY";
  Term3["TWO_YEARS"] = "TWO_YEARS";
  Term3["THREE_YEARS"] = "THREE_YEARS";
  Term3["P1D"] = "P1D";
  Term3["P1Y"] = "P1Y";
  Term3["P3Y"] = "P3Y";
  Term3["P10Y"] = "P10Y";
  Term3["P15Y"] = "P15Y";
  Term3["P3D"] = "P3D";
  Term3["P7D"] = "P7D";
  Term3["P30D"] = "P30D";
  Term3["HALF_YEARLY"] = "HALF_YEARLY";
  Term3["QUARTERLY"] = "QUARTERLY";
})(Term2 || (Term2 = {}));
var CustomerSegment;
(function(CustomerSegment2) {
  CustomerSegment2["INDIVIDUAL"] = "INDIVIDUAL";
  CustomerSegment2["TEAM"] = "TEAM";
  CustomerSegment2["ENTERPRISE"] = "ENTERPRISE";
})(CustomerSegment || (CustomerSegment = {}));
var MarketSegment;
(function(MarketSegment2) {
  MarketSegment2["COM"] = "COM";
  MarketSegment2["EDU"] = "EDU";
  MarketSegment2["GOV"] = "GOV";
})(MarketSegment || (MarketSegment = {}));
var SalesChannel;
(function(SalesChannel2) {
  SalesChannel2["DIRECT"] = "DIRECT";
  SalesChannel2["INDIRECT"] = "INDIRECT";
})(SalesChannel || (SalesChannel = {}));
var BuyingProgram;
(function(BuyingProgram2) {
  BuyingProgram2["ENTERPRISE_PRODUCT"] = "ENTERPRISE_PRODUCT";
  BuyingProgram2["ETLA"] = "ETLA";
  BuyingProgram2["RETAIL"] = "RETAIL";
  BuyingProgram2["VIP"] = "VIP";
  BuyingProgram2["VIPMP"] = "VIPMP";
  BuyingProgram2["FREE"] = "FREE";
})(BuyingProgram || (BuyingProgram = {}));

// ../node_modules/@dexter/tacocat-core/src/wcsUtils.js
var ABM = "ABM";
var PUF = "PUF";
var M2M = "M2M";
var PERPETUAL = "PERPETUAL";
var P3Y = "P3Y";
var TAX_INCLUSIVE_DETAILS = "TAX_INCLUSIVE_DETAILS";
var TAX_EXCLUSIVE = "TAX_EXCLUSIVE";
var PlanType = {
  ABM,
  PUF,
  M2M,
  PERPETUAL,
  P3Y
};
var planTypes = {
  [ABM]: { commitment: Commitment2.YEAR, term: Term2.MONTHLY },
  [PUF]: { commitment: Commitment2.YEAR, term: Term2.ANNUAL },
  [M2M]: { commitment: Commitment2.MONTH, term: Term2.MONTHLY },
  [PERPETUAL]: { commitment: Commitment2.PERPETUAL, term: void 0 },
  [P3Y]: { commitment: Commitment2.THREE_MONTHS, term: Term2.P3Y }
};
var errorValueNotOffer = "Value is not an offer";
var applyPlanType = (offer) => {
  if (typeof offer !== "object") return errorValueNotOffer;
  const { commitment, term } = offer;
  const planType = getPlanType(commitment, term);
  return { ...offer, planType };
};
var getPlanType = (commitment, term) => {
  switch (commitment) {
    case void 0:
      return errorValueNotOffer;
    case "":
      return "";
    case Commitment2.YEAR:
      return term === Term2.MONTHLY ? ABM : term === Term2.ANNUAL ? PUF : "";
    case Commitment2.MONTH:
      return term === Term2.MONTHLY ? M2M : "";
    case Commitment2.PERPETUAL:
      return PERPETUAL;
    case Commitment2.TERM_LICENSE:
      return term === Term2.P3Y ? P3Y : "";
    default:
      return "";
  }
};
function forceTaxExclusivePrice(offer) {
  const { priceDetails } = offer;
  const {
    price: price2,
    priceWithoutDiscount,
    priceWithoutTax,
    priceWithoutDiscountAndTax,
    taxDisplay
  } = priceDetails;
  if (taxDisplay !== TAX_INCLUSIVE_DETAILS) return offer;
  const amendedOffer = {
    ...offer,
    priceDetails: {
      ...priceDetails,
      price: priceWithoutTax ?? price2,
      priceWithoutDiscount: priceWithoutDiscountAndTax ?? priceWithoutDiscount,
      taxDisplay: TAX_EXCLUSIVE
    }
  };
  if (amendedOffer.offerType === "TRIAL" && amendedOffer.priceDetails.price === 0) {
    amendedOffer.priceDetails.price = amendedOffer.priceDetails.priceWithoutDiscount;
  }
  return amendedOffer;
}

// src/utilities.js
var MAS_COMMERCE_SERVICE = "mas-commerce-service";
var FETCH_INFO_HEADERS = {
  requestId: HEADER_X_REQUEST_ID,
  etag: "Etag",
  lastModified: "Last-Modified",
  serverTiming: "server-timing"
};
function selectOffers(offers, { country, forceTaxExclusive }) {
  let selected;
  if (offers.length < 2) selected = offers;
  else {
    const language = country === "GB" ? "EN" : "MULT";
    offers.sort(
      (a3, b2) => a3.language === language ? -1 : b2.language === language ? 1 : 0
    );
    offers.sort((a3, b2) => {
      if (!a3.term && b2.term) return -1;
      if (a3.term && !b2.term) return 1;
      return 0;
    });
    selected = [offers[0]];
  }
  if (forceTaxExclusive) {
    selected = selected.map(forceTaxExclusivePrice);
  }
  return selected;
}
var setImmediate = (getConfig) => window.setTimeout(getConfig);
function toQuantity(value, defaultValue = 1) {
  if (value == null) return [defaultValue];
  let quantity = (Array.isArray(value) ? value : String(value).split(",")).map(toPositiveFiniteInteger).filter(isPositiveFiniteNumber);
  if (!quantity.length) quantity = [defaultValue];
  return quantity;
}
function toOfferSelectorIds(value) {
  if (value == null) return [];
  const ids = Array.isArray(value) ? value : String(value).split(",");
  return ids.filter(isNotEmptyString);
}
function getService() {
  return document.getElementsByTagName(MAS_COMMERCE_SERVICE)?.[0];
}
function getLogHeaders(response) {
  const logHeaders = {};
  if (!response?.headers) return logHeaders;
  const headers = response.headers;
  for (const [key, value] of Object.entries(FETCH_INFO_HEADERS)) {
    let headerValue = headers.get(value);
    if (headerValue) {
      headerValue = headerValue.replace(/[,;]/g, "|");
      headerValue = headerValue.replace(/[| ]+/g, "|");
      logHeaders[key] = headerValue;
    }
  }
  return logHeaders;
}

// src/log.js
var HostEnv = {
  LOCAL: "local",
  PROD: "prod",
  STAGE: "stage"
};
var LogLevels = {
  DEBUG: "debug",
  ERROR: "error",
  INFO: "info",
  WARN: "warn"
};
var appenders = /* @__PURE__ */ new Set();
var filters = /* @__PURE__ */ new Set();
var loggerIndexes = /* @__PURE__ */ new Map();
var consoleAppender = {
  append({ level, message, params, timestamp, source }) {
    console[level](
      `${timestamp}ms [${source}] %c${message}`,
      "font-weight: bold;",
      ...params
    );
  }
};
var debugFilter = { filter: ({ level }) => level !== LogLevels.DEBUG };
var quietFilter = { filter: () => false };
function createEntry(level, message, namespace2, params, source) {
  return {
    level,
    message,
    namespace: namespace2,
    get params() {
      if (params.length === 1 && isFunction(params[0])) {
        params = params[0]();
        if (!Array.isArray(params)) params = [params];
      }
      return params;
    },
    source,
    timestamp: performance.now().toFixed(3)
  };
}
function handleEntry(entry) {
  if ([...filters].every((filter) => filter(entry))) {
    appenders.forEach((appender) => appender(entry));
  }
}
function createLog2(namespace2) {
  const index = (loggerIndexes.get(namespace2) ?? 0) + 1;
  loggerIndexes.set(namespace2, index);
  const id = `${namespace2} #${index}`;
  const log2 = {
    id,
    namespace: namespace2,
    module: (name) => createLog2(`${log2.namespace}/${name}`),
    updateConfig
  };
  Object.values(LogLevels).forEach((level) => {
    log2[level] = (message, ...params) => handleEntry(createEntry(level, message, namespace2, params, id));
  });
  return Object.seal(log2);
}
function use(...plugins) {
  plugins.forEach((plugin) => {
    const { append, filter } = plugin;
    if (isFunction(filter)) filters.add(filter);
    if (isFunction(append)) appenders.add(append);
  });
}
function init(env = {}) {
  const { name } = env;
  const debug = toBoolean(
    getParameter("commerce.debug", { search: true, storage: true }),
    name === HostEnv.LOCAL
  );
  if (debug) use(consoleAppender);
  else use(debugFilter);
  if (name === HostEnv.PROD) use(lanaAppender);
  return Log;
}
function reset() {
  appenders.clear();
  filters.clear();
}
var Log = {
  ...createLog2(LOG_NAMESPACE),
  Level: LogLevels,
  Plugins: { consoleAppender, debugFilter, quietFilter, lanaAppender },
  init,
  reset,
  use
};

// src/mas-error.js
var MasError = class _MasError extends Error {
  /**
   * Creates a new MasError instance
   * @param {string} message - The error message
   * @param {Object} context - Additional context information about the error
   * @param {unknown} cause - The original error that caused this error
   */
  constructor(message, context, cause) {
    super(message, { cause });
    this.name = "MasError";
    if (context.response) {
      const requestId = context.response.headers?.get(HEADER_X_REQUEST_ID);
      if (requestId) {
        context.requestId = requestId;
      }
      if (context.response.status) {
        context.status = context.response.status;
        context.statusText = context.response.statusText;
      }
      if (context.response.url) {
        context.url = context.response.url;
      }
    }
    delete context.response;
    this.context = context;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _MasError);
    }
  }
  /**
   * Returns a string representation of the error including context
   * @returns {string} String representation of the error
   */
  toString() {
    const contextStr = Object.entries(this.context || {}).map(([key, value]) => `${key}: ${JSON.stringify(value)}`).join(", ");
    let errorString = `${this.name}: ${this.message}`;
    if (contextStr) {
      errorString += ` (${contextStr})`;
    }
    if (this.cause) {
      errorString += `
Caused by: ${this.cause}`;
    }
    return errorString;
  }
};

// src/mas-element.js
var StateClassName = {
  [STATE_FAILED]: CLASS_NAME_FAILED,
  [STATE_PENDING]: CLASS_NAME_PENDING,
  [STATE_RESOLVED]: CLASS_NAME_RESOLVED
};
var StateEventType = {
  [STATE_FAILED]: EVENT_TYPE_FAILED,
  [STATE_RESOLVED]: EVENT_TYPE_RESOLVED
};
var _service;
var MasElement = class {
  constructor(wrapperElement) {
    __privateAdd(this, _service);
    __publicField(this, "changes", /* @__PURE__ */ new Map());
    __publicField(this, "connected", false);
    __publicField(this, "error");
    __publicField(this, "log");
    __publicField(this, "options");
    __publicField(this, "promises", []);
    __publicField(this, "state", STATE_PENDING);
    __publicField(this, "timer", null);
    __publicField(this, "value");
    __publicField(this, "version", 0);
    __publicField(this, "wrapperElement");
    this.wrapperElement = wrapperElement;
    this.log = Log.module("mas-element");
  }
  update() {
    [STATE_FAILED, STATE_PENDING, STATE_RESOLVED].forEach((state) => {
      this.wrapperElement.classList.toggle(
        StateClassName[state],
        state === this.state
      );
    });
  }
  notify() {
    if (this.state === STATE_RESOLVED || this.state === STATE_FAILED) {
      if (this.state === STATE_RESOLVED) {
        this.promises.forEach(
          ({ resolve }) => resolve(this.wrapperElement)
        );
      } else if (this.state === STATE_FAILED) {
        this.promises.forEach(({ reject }) => reject(this.error));
      }
      this.promises = [];
    }
    let detail = this.error;
    if (this.error instanceof MasError) {
      detail = {
        message: this.error.message,
        ...this.error.context
      };
    }
    this.wrapperElement.dispatchEvent(
      new CustomEvent(StateEventType[this.state], {
        bubbles: true,
        detail
      })
    );
  }
  /**
   * Adds name/value of the updated attribute to the `changes` map,
   * requests placeholder update.
   */
  attributeChangedCallback(name, _2, value) {
    this.changes.set(name, value);
    this.requestUpdate();
  }
  /**
   * Triggers when this component is connected to DOM.
   * Subscribes to the `ready` event of the commerce service,
   * requests placeholder update.
   */
  connectedCallback() {
    __privateSet(this, _service, getService());
    this.requestUpdate(true);
  }
  /**
   * Triggers when this component is disconnected from DOM.
   * Runs and then erases all disposers.
   */
  disconnectedCallback() {
    if (this.connected) {
      this.connected = false;
      this.log?.debug("Disconnected:", { element: this.wrapperElement });
    }
  }
  /**
   * Returns a promise resolving to this placeholder
   * when its value is resolved or rejected.
   * If placeholder is not pending for completion of an async operation
   * the returned promise is already resolved or rejected.
   */
  onceSettled() {
    const { error, promises, state } = this;
    if (STATE_RESOLVED === state)
      return Promise.resolve(this.wrapperElement);
    if (STATE_FAILED === state) return Promise.reject(error);
    return new Promise((resolve, reject) => {
      promises.push({ resolve, reject });
    });
  }
  /**
   * Sets component state to "RESOLVED".
   * Updates its class list and stored value, notifies observers and fires "RESOLVED" event.
   */
  toggleResolved(version, value, options) {
    if (version !== this.version) return false;
    if (options !== void 0) this.options = options;
    this.state = STATE_RESOLVED;
    this.value = value;
    this.update();
    this.log?.debug("Resolved:", { element: this.wrapperElement, value });
    setImmediate(() => this.notify());
    return true;
  }
  /**
   * Sets component state to "FAILED".
   * Updates its class list and stored error, notifies observers and fires "FAILED" event.
   */
  toggleFailed(version, error, options) {
    if (version !== this.version) return false;
    if (options !== void 0) this.options = options;
    this.error = error;
    this.state = STATE_FAILED;
    this.update();
    const wcName = this.wrapperElement.getAttribute("is");
    this.log?.error(`${wcName}: Failed to render: ${error.message}`, {
      element: this.wrapperElement,
      ...error.context,
      ...__privateGet(this, _service)?.duration
    });
    setImmediate(() => this.notify());
    return true;
  }
  /**
   * Sets component state to "PENDING".
   * Increments its version, updates CSS classes, notifies observers and fires "PENDING" event.
   */
  togglePending(options) {
    this.version++;
    if (options) this.options = options;
    this.state = STATE_PENDING;
    this.update();
    this.log?.debug("Pending:", {
      osi: this.wrapperElement?.options?.wcsOsi
    });
    return this.version;
  }
  /**
   * Queues task to update this component.
   * Skips rendering if update is not forced and no changes were accumulated since the previous update.
   * Calls `render` method to perform the update.
   * Restores previous state of the component if the `render` method returned `false`.
   */
  requestUpdate(force = false) {
    if (!this.wrapperElement.isConnected || !getService()) return;
    if (this.timer) return;
    const { error, options, state, value, version } = this;
    this.state = STATE_PENDING;
    this.timer = setImmediate(async () => {
      this.timer = null;
      let changes = null;
      if (this.changes.size) {
        changes = Object.fromEntries(this.changes.entries());
        this.changes.clear();
      }
      if (this.connected) {
        this.log?.debug("Updated:", {
          element: this.wrapperElement,
          changes
        });
      } else {
        this.connected = true;
        this.log?.debug("Connected:", {
          element: this.wrapperElement,
          changes
        });
      }
      if (changes || force) {
        try {
          const result = await this.wrapperElement.render?.();
          if (result === false && this.state === STATE_PENDING && this.version === version) {
            this.state = state;
            this.error = error;
            this.value = value;
            this.update();
            this.notify();
          }
        } catch (error2) {
          this.toggleFailed(this.version, error2, options);
        }
      }
    });
  }
};
_service = new WeakMap();
function cleanupDataset(dataset = {}) {
  Object.entries(dataset).forEach(([key, value]) => {
    const remove = value == null || value === "" || value?.length === 0;
    if (remove) delete dataset[key];
  });
  return dataset;
}
function createMasElement(Class, dataset = {}) {
  const { tag, is } = Class;
  const element = document.createElement(tag, { is });
  element.setAttribute("is", is);
  Object.assign(element.dataset, cleanupDataset(dataset));
  return element;
}
function updateMasElement(element, dataset = {}) {
  if (element instanceof HTMLElement) {
    Object.assign(element.dataset, cleanupDataset(dataset));
    return element;
  }
  return null;
}

// src/checkout-mixin.js
var CLASS_NAME_DOWNLOAD = "download";
var CLASS_NAME_UPGRADE = "upgrade";
var CHECKOUT_PARAM_VALUE_MAPPING = {
  e: "EDU",
  t: "TEAM"
};
function createCheckoutElement(Class, options = {}, innerHTML = "") {
  const service = getService();
  if (!service) return null;
  const {
    checkoutMarketSegment,
    checkoutWorkflow,
    checkoutWorkflowStep,
    entitlement,
    upgrade,
    modal,
    perpetual,
    promotionCode,
    quantity,
    wcsOsi,
    extraOptions,
    analyticsId
  } = service.collectCheckoutOptions(options);
  const element = createMasElement(Class, {
    checkoutMarketSegment,
    checkoutWorkflow,
    checkoutWorkflowStep,
    entitlement,
    upgrade,
    modal,
    perpetual,
    promotionCode,
    quantity,
    wcsOsi,
    extraOptions,
    analyticsId
  });
  if (innerHTML)
    element.innerHTML = `<span style="pointer-events: none;">${innerHTML}</span>`;
  return element;
}
function CheckoutMixin(Base) {
  return class CheckoutBase extends Base {
    constructor() {
      super(...arguments);
      /* c8 ignore next 1 */
      __publicField(this, "checkoutActionHandler");
      __publicField(this, "masElement", new MasElement(this));
    }
    attributeChangedCallback(name, oldValue, value) {
      this.masElement.attributeChangedCallback(name, oldValue, value);
    }
    connectedCallback() {
      this.masElement.connectedCallback();
      this.addEventListener("click", this.clickHandler);
    }
    disconnectedCallback() {
      this.masElement.disconnectedCallback();
      this.removeEventListener("click", this.clickHandler);
    }
    onceSettled() {
      return this.masElement.onceSettled();
    }
    get value() {
      return this.masElement.value;
    }
    get options() {
      return this.masElement.options;
    }
    get marketSegment() {
      const value = this.options?.ms ?? this.value?.[0].marketSegments?.[0];
      return CHECKOUT_PARAM_VALUE_MAPPING[value] ?? value;
    }
    get customerSegment() {
      const value = this.options?.cs ?? this.value?.[0]?.customerSegment;
      return CHECKOUT_PARAM_VALUE_MAPPING[value] ?? value;
    }
    get is3in1Modal() {
      return Object.values(MODAL_TYPE_3_IN_1).includes(
        this.getAttribute("data-modal")
      );
    }
    get isOpen3in1Modal() {
      const masFF3in1 = document.querySelector("meta[name=mas-ff-3in1]");
      return this.is3in1Modal && (!masFF3in1 || masFF3in1.content !== "off");
    }
    requestUpdate(force = false) {
      return this.masElement.requestUpdate(force);
    }
    static get observedAttributes() {
      return [
        "data-checkout-workflow",
        "data-checkout-workflow-step",
        "data-extra-options",
        "data-ims-country",
        "data-perpetual",
        "data-promotion-code",
        "data-quantity",
        "data-template",
        "data-wcs-osi",
        "data-entitlement",
        "data-upgrade",
        "data-modal"
      ];
    }
    async render(overrides = {}) {
      const service = getService();
      if (!service) return false;
      if (!this.dataset.imsCountry) {
        service.imsCountryPromise.then((countryCode) => {
          if (countryCode) this.dataset.imsCountry = countryCode;
        });
      }
      overrides.imsCountry = null;
      const options = service.collectCheckoutOptions(overrides, this);
      if (!options.wcsOsi.length) return false;
      let extraOptions;
      try {
        extraOptions = JSON.parse(options.extraOptions ?? "{}");
      } catch (e4) {
        this.masElement.log?.error(
          "cannot parse exta checkout options",
          e4
        );
      }
      const version = this.masElement.togglePending(options);
      this.setCheckoutUrl("");
      const promises = service.resolveOfferSelectors(options);
      let offers = await Promise.all(promises);
      offers = offers.map((offer) => selectOffers(offer, options));
      options.country = this.dataset.imsCountry || options.country;
      const checkoutAction = await service.buildCheckoutAction?.(
        offers.flat(),
        { ...extraOptions, ...options },
        this
      );
      return this.renderOffers(
        offers.flat(),
        options,
        {},
        checkoutAction,
        version
      );
    }
    /**
     * Renders checkout link href for provided offers into this component.
     * @param {Commerce.Wcs.Offer[]} offers
     * @param {Commerce.Checkout.Options} options
     * @param {Commerce.Checkout.AnyOptions} overrides
     * @param {Commerce.Checkout.CheckoutAction} checkoutAction
     * @param {number} version
     */
    renderOffers(offers, options, overrides = {}, checkoutAction = void 0, version = void 0) {
      const service = getService();
      if (!service) return false;
      const extraOptions = JSON.parse(this.dataset.extraOptions ?? "{}");
      options = { ...extraOptions, ...options, ...overrides };
      version ?? (version = this.masElement.togglePending(options));
      if (this.checkoutActionHandler) {
        this.checkoutActionHandler = void 0;
      }
      if (checkoutAction) {
        this.classList.remove(CLASS_NAME_DOWNLOAD, CLASS_NAME_UPGRADE);
        this.masElement.toggleResolved(version, offers, options);
        const { url, text, className, handler } = checkoutAction;
        if (url) {
          this.setCheckoutUrl(url);
        }
        if (text) this.firstElementChild.innerHTML = text;
        if (className) this.classList.add(...className.split(" "));
        if (handler) {
          this.setCheckoutUrl("#");
          this.checkoutActionHandler = handler.bind(this);
        }
      }
      if (offers.length) {
        if (this.masElement.toggleResolved(version, offers, options)) {
          if (!this.classList.contains(CLASS_NAME_DOWNLOAD) && !this.classList.contains(CLASS_NAME_UPGRADE)) {
            const url = service.buildCheckoutURL(offers, options);
            this.setCheckoutUrl(
              options.modal === "true" ? "#" : url
            );
          }
          return true;
        }
      } else {
        const error = new Error(
          `Not provided: ${options?.wcsOsi ?? "-"}`
        );
        if (this.masElement.toggleFailed(version, error, options)) {
          this.setCheckoutUrl("#");
          return true;
        }
      }
    }
    setCheckoutUrl() {
    }
    clickHandler(e4) {
    }
    updateOptions(options = {}) {
      const service = getService();
      if (!service) return false;
      const {
        checkoutMarketSegment,
        checkoutWorkflow,
        checkoutWorkflowStep,
        entitlement,
        upgrade,
        modal,
        perpetual,
        promotionCode,
        quantity,
        wcsOsi
      } = service.collectCheckoutOptions(options);
      updateMasElement(this, {
        checkoutMarketSegment,
        checkoutWorkflow,
        checkoutWorkflowStep,
        entitlement,
        upgrade,
        modal,
        perpetual,
        promotionCode,
        quantity,
        wcsOsi
      });
      return true;
    }
  };
}

// src/checkout-link.js
var _CheckoutLink = class _CheckoutLink extends CheckoutMixin(HTMLAnchorElement) {
  static createCheckoutLink(options = {}, innerHTML = "") {
    return createCheckoutElement(_CheckoutLink, options, innerHTML);
  }
  setCheckoutUrl(value) {
    this.setAttribute("href", value);
  }
  get isCheckoutLink() {
    return true;
  }
  clickHandler(e4) {
    if (this.checkoutActionHandler) {
      this.checkoutActionHandler?.(e4);
      return;
    }
  }
};
__publicField(_CheckoutLink, "is", "checkout-link");
__publicField(_CheckoutLink, "tag", "a");
var CheckoutLink = _CheckoutLink;
if (!window.customElements.get(CheckoutLink.is)) {
  window.customElements.define(CheckoutLink.is, CheckoutLink, {
    extends: CheckoutLink.tag
  });
}

// src/buildCheckoutUrl.js
var AF_DRAFT_LANDSCAPE = "p_draft_landscape";
var UCV3_PREFIX = "/store/";
var PARAMETERS = /* @__PURE__ */ new Map([
  ["countrySpecific", "cs"],
  ["customerSegment", "cs"],
  ["quantity", "q"],
  ["authCode", "code"],
  ["checkoutPromoCode", "apc"],
  ["rurl", "rUrl"],
  ["curl", "cUrl"],
  ["ctxrturl", "ctxRtUrl"],
  ["country", "co"],
  ["language", "lang"],
  ["clientId", "cli"],
  ["context", "ctx"],
  ["productArrangementCode", "pa"],
  ["addonProductArrangementCode", "ao"],
  ["offerType", "ot"],
  ["marketSegment", "ms"]
]);
var ALLOWED_KEYS = /* @__PURE__ */ new Set([
  "af",
  "ai",
  "ao",
  "apc",
  "appctxid",
  "cli",
  "co",
  "cs",
  "csm",
  "ctx",
  "ctxRtUrl",
  "DCWATC",
  "dp",
  // Enable digital payments for iframe context
  "fr",
  // represents the commerce app redirecting to UC
  "gsp",
  "ijt",
  "lang",
  "lo",
  "mal",
  "ms",
  "mv",
  "mv2",
  "nglwfdata",
  "ot",
  "otac",
  "pa",
  "pcid",
  // Unified Paywall configuration ID for analytics
  "promoid",
  "q",
  "rf",
  "sc",
  "scl",
  "sdid",
  "sid",
  // x-adobe-clientsession
  "spint",
  "svar",
  "th",
  "thm",
  "trackingid",
  "usid",
  "workflowid",
  "context.guid",
  "so.ca",
  "so.su",
  "so.tr",
  "so.va"
]);
var REQUIRED_KEYS = ["env", "workflowStep", "clientId", "country"];
var mapParameterName = (field) => PARAMETERS.get(field) ?? field;
function addParameters(inputParameters, resultParameters, allowedKeys) {
  for (const [key, value] of Object.entries(inputParameters)) {
    const mappedKey = mapParameterName(key);
    if (value != null && allowedKeys.has(mappedKey)) {
      resultParameters.set(mappedKey, value);
    }
  }
}
function getHostName(env) {
  switch (env) {
    case PROVIDER_ENVIRONMENT.PRODUCTION:
      return "https://commerce.adobe.com";
    default:
      return "https://commerce-stg.adobe.com";
  }
}
function setItemsParameter(items, parameters) {
  for (const idx in items) {
    const item = items[idx];
    for (const [key, value] of Object.entries(item)) {
      if (value == null) continue;
      const parameterName = mapParameterName(key);
      parameters.set(`items[${idx}][${parameterName}]`, value);
    }
  }
}
function add3in1Parameters({ url, modal, is3in1 }) {
  if (!is3in1 || !url?.searchParams) return url;
  url.searchParams.set("rtc", "t");
  url.searchParams.set("lo", "sl");
  const existingAf = url.searchParams.get("af");
  url.searchParams.set(
    "af",
    [existingAf, "uc_new_user_iframe", "uc_new_system_close"].filter(Boolean).join(",")
  );
  if (url.searchParams.get("cli") !== "doc_cloud") {
    url.searchParams.set(
      "cli",
      modal === MODAL_TYPE_3_IN_1.CRM ? "creative" : "mini_plans"
    );
  }
  return url;
}
function buildCheckoutUrl(checkoutData) {
  validateCheckoutData(checkoutData);
  const {
    env,
    items,
    workflowStep,
    marketSegment,
    customerSegment,
    offerType,
    productArrangementCode,
    landscape,
    modal,
    is3in1,
    preselectPlan,
    ...rest
  } = checkoutData;
  let url = new URL(getHostName(env));
  url.pathname = `${UCV3_PREFIX}${workflowStep}`;
  if (workflowStep !== CheckoutWorkflowStep.SEGMENTATION && workflowStep !== CheckoutWorkflowStep.CHANGE_PLAN_TEAM_PLANS) {
    setItemsParameter(items, url.searchParams);
  }
  addParameters({ ...rest }, url.searchParams, ALLOWED_KEYS);
  if (landscape === Landscape.DRAFT) {
    addParameters(
      { af: AF_DRAFT_LANDSCAPE },
      url.searchParams,
      ALLOWED_KEYS
    );
  }
  if (workflowStep === CheckoutWorkflowStep.SEGMENTATION) {
    const segmentationParameters = {
      marketSegment,
      offerType,
      customerSegment,
      productArrangementCode,
      quantity: items?.[0]?.quantity,
      addonProductArrangementCode: productArrangementCode ? items?.find(
        (item) => item.productArrangementCode !== productArrangementCode
      )?.productArrangementCode : items?.[1]?.productArrangementCode
    };
    if (preselectPlan?.toLowerCase() === "edu") {
      url.searchParams.set("ms", "EDU");
    } else if (preselectPlan?.toLowerCase() === "team") {
      url.searchParams.set("cs", "TEAM");
    }
    addParameters(segmentationParameters, url.searchParams, ALLOWED_KEYS);
    if (url.searchParams.get("ot") === "PROMOTION")
      url.searchParams.delete("ot");
    url = add3in1Parameters({
      url,
      modal,
      is3in1
    });
  }
  return url.toString();
}
function validateCheckoutData(checkoutData) {
  for (const key of REQUIRED_KEYS) {
    if (!checkoutData[key]) {
      throw new Error(
        'Argument "checkoutData" is not valid, missing: ' + key
      );
    }
  }
  if (checkoutData.workflowStep !== CheckoutWorkflowStep.SEGMENTATION && checkoutData.workflowStep !== CheckoutWorkflowStep.CHANGE_PLAN_TEAM_PLANS && !checkoutData.items) {
    throw new Error('Argument "checkoutData" is not valid, missing: items');
  }
  return true;
}

// src/defaults.js
var Defaults = Object.freeze({
  checkoutClientId: "adobe_com",
  checkoutWorkflowStep: CheckoutWorkflowStep.EMAIL,
  country: "US",
  displayOldPrice: false,
  displayPerUnit: false,
  displayRecurrence: true,
  displayTax: false,
  displayPlanType: false,
  env: Env.PRODUCTION,
  forceTaxExclusive: false,
  language: "en",
  entitlement: false,
  extraOptions: {},
  modal: false,
  promotionCode: "",
  quantity: 1,
  alternativePrice: false,
  wcsApiKey: "wcms-commerce-ims-ro-user-milo",
  wcsURL: "https://www.adobe.com/web_commerce_artifact",
  landscape: Landscape.PUBLISHED
});

// src/checkout.js
function Checkout({ settings, providers }) {
  function collectCheckoutOptions(overrides, placeholder) {
    const {
      checkoutClientId,
      checkoutWorkflowStep: defaultWorkflowStep,
      country: defaultCountry,
      language: defaultLanguage,
      promotionCode: defaultPromotionCode,
      quantity: defaultQuantity,
      preselectPlan,
      env
    } = settings;
    let options = {
      checkoutClientId,
      checkoutWorkflowStep: defaultWorkflowStep,
      country: defaultCountry,
      language: defaultLanguage,
      promotionCode: defaultPromotionCode,
      quantity: defaultQuantity,
      preselectPlan,
      env
    };
    if (placeholder) {
      for (const provider of providers.checkout) {
        provider(placeholder, options);
      }
    }
    const {
      checkoutMarketSegment,
      checkoutWorkflowStep = defaultWorkflowStep,
      imsCountry: imsCountry2,
      country = imsCountry2 ?? defaultCountry,
      language = defaultLanguage,
      quantity = defaultQuantity,
      entitlement,
      upgrade,
      modal,
      perpetual,
      promotionCode = defaultPromotionCode,
      wcsOsi,
      extraOptions,
      ...rest
    } = Object.assign(options, placeholder?.dataset ?? {}, overrides ?? {});
    const workflowStep = toEnumeration(
      checkoutWorkflowStep,
      CheckoutWorkflowStep,
      Defaults.checkoutWorkflowStep
    );
    options = omitProperties({
      ...rest,
      extraOptions,
      checkoutClientId,
      checkoutMarketSegment,
      country,
      quantity: toQuantity(quantity, Defaults.quantity),
      checkoutWorkflowStep: workflowStep,
      language,
      entitlement: toBoolean(entitlement),
      upgrade: toBoolean(upgrade),
      modal,
      perpetual: toBoolean(perpetual),
      promotionCode: computePromoStatus(promotionCode).effectivePromoCode,
      wcsOsi: toOfferSelectorIds(wcsOsi),
      preselectPlan
    });
    return options;
  }
  function buildCheckoutURL(offers, options) {
    if (!Array.isArray(offers) || !offers.length || !options) {
      return "";
    }
    const { env, landscape } = settings;
    const {
      checkoutClientId: clientId,
      checkoutMarketSegment,
      checkoutWorkflowStep: workflowStep,
      country,
      promotionCode: checkoutPromoCode,
      quantity: optionsQuantity,
      preselectPlan,
      ms,
      cs,
      ...rest
    } = collectCheckoutOptions(options);
    const masFF3in1 = document.querySelector("meta[name=mas-ff-3in1]");
    const is3in1 = Object.values(MODAL_TYPE_3_IN_1).includes(options.modal) && (!masFF3in1 || masFF3in1.content !== "off");
    const context = window.frameElement || is3in1 ? "if" : "fp";
    const [
      {
        productArrangementCode,
        marketSegments: [offerMarketSegment],
        customerSegment: offerCustomerSegment,
        offerType
      }
    ] = offers;
    let marketSegment = ms ?? offerMarketSegment ?? checkoutMarketSegment;
    let customerSegment = cs ?? offerCustomerSegment;
    if (preselectPlan?.toLowerCase() === "edu") {
      marketSegment = "EDU";
    } else if (preselectPlan?.toLowerCase() === "team") {
      customerSegment = "TEAM";
    }
    const data = {
      is3in1,
      checkoutPromoCode,
      clientId,
      context,
      country,
      env,
      items: [],
      marketSegment,
      customerSegment,
      offerType,
      productArrangementCode,
      workflowStep,
      landscape,
      ...rest
    };
    const quantity = optionsQuantity[0] > 1 ? optionsQuantity[0] : void 0;
    if (offers.length === 1) {
      const { offerId } = offers[0];
      data.items.push({ id: offerId, quantity });
    } else {
      data.items.push(
        ...offers.map(({ offerId, productArrangementCode: productArrangementCode2 }) => ({
          id: offerId,
          quantity,
          ...is3in1 ? { productArrangementCode: productArrangementCode2 } : {}
        }))
      );
    }
    return buildCheckoutUrl(data);
  }
  const { createCheckoutLink } = CheckoutLink;
  return {
    CheckoutLink,
    CheckoutWorkflowStep,
    buildCheckoutURL,
    collectCheckoutOptions,
    createCheckoutLink
  };
}

// src/ims.js
function imsReady({ interval = 200, maxAttempts = 25 } = {}) {
  const log2 = Log.module("ims");
  return new Promise((resolve) => {
    log2.debug("Waing for IMS to be ready");
    let count = 0;
    function poll() {
      if (window.adobeIMS?.initialized) {
        resolve();
      } else if (++count > maxAttempts) {
        log2.debug("Timeout");
        resolve();
      } else {
        setTimeout(poll, interval);
      }
    }
    poll();
  });
}
function imsSignedIn(imsReadyPromise) {
  return imsReadyPromise.then(
    () => window.adobeIMS?.isSignedInUser() ?? false
  );
}
function imsCountry(imsSignedInPromise) {
  const log2 = Log.module("ims");
  return imsSignedInPromise.then((signedIn) => {
    if (!signedIn) return null;
    return window.adobeIMS.getProfile().then(
      ({ countryCode }) => {
        log2.debug("Got user country:", countryCode);
        return countryCode;
      },
      (error) => {
        log2.error("Unable to get user country:", error);
        return void 0;
      }
    );
  });
}
function Ims({}) {
  const imsReadyPromise = imsReady();
  const imsSignedInPromise = imsSignedIn(imsReadyPromise);
  const imsCountryPromise = imsCountry(imsSignedInPromise);
  return { imsReadyPromise, imsSignedInPromise, imsCountryPromise };
}

// src/literals.js
var priceLiterals = window.masPriceLiterals;
function getPriceLiterals(settings) {
  if (Array.isArray(priceLiterals)) {
    const find = (language) => priceLiterals.find(
      (candidate) => equalsCaseInsensitive(candidate.lang, language)
    );
    const literals = find(settings.language) ?? find(Defaults.language);
    if (literals) return Object.freeze(literals);
  }
  return {};
}

// ../node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s5, i3 = 1, n5 = arguments.length; i3 < n5; i3++) {
      s5 = arguments[i3];
      for (var p2 in s5) if (Object.prototype.hasOwnProperty.call(s5, p2)) t3[p2] = s5[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l4 = from.length, ar; i3 < l4; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../node_modules/@formatjs/icu-messageformat-parser/lib/error.js
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// ../node_modules/@formatjs/icu-messageformat-parser/lib/types.js
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// ../node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// ../node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match) {
    var len = match.length;
    switch (match[0]) {
      // Era
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      // Year
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      // Quarter
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      // Month
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      // Week
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      // Weekday
      case "E":
        result.weekday = len === 4 ? "short" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      // Period
      case "a":
        result.hour12 = true;
        break;
      case "b":
      // am, pm, noon, midnight
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      // Hour
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      // Minute
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      // Second
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      // Zone
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      // 1..3, 4, 5: The ISO8601 varios formats
      case "O":
      // 1, 4: miliseconds in day short, long
      case "v":
      // 1, 4: generic non-location format
      case "V":
      // 1, 2, 3, 4: time zone ID or city
      case "X":
      // 1, 2, 3, 4: The ISO8601 varios formats
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// ../node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// ../node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x2) {
    return x2.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// ../node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js
var timeData = {
  "AX": [
    "H"
  ],
  "BQ": [
    "H"
  ],
  "CP": [
    "H"
  ],
  "CZ": [
    "H"
  ],
  "DK": [
    "H"
  ],
  "FI": [
    "H"
  ],
  "ID": [
    "H"
  ],
  "IS": [
    "H"
  ],
  "ML": [
    "H"
  ],
  "NE": [
    "H"
  ],
  "RU": [
    "H"
  ],
  "SE": [
    "H"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "AS": [
    "h",
    "H"
  ],
  "BT": [
    "h",
    "H"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "GH": [
    "h",
    "H"
  ],
  "IN": [
    "h",
    "H"
  ],
  "LS": [
    "h",
    "H"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PW": [
    "h",
    "H"
  ],
  "SO": [
    "h",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WS": [
    "h",
    "H"
  ],
  "001": [
    "H",
    "h"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "AR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CL": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CU": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BO": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-EC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-PE": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "GT": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "HN": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MX": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "NI": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "PY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "SV": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "UY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "JP": [
    "H",
    "h",
    "K"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BO": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "EC": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "PE": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ]
};

// ../node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}

// ../node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith;
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n5) {
  return typeof n5 === "number" && isFinite(n5) && Math.floor(n5) === n5 && Math.abs(n5) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s5, search, position) {
    return s5.startsWith(search, position);
  }
) : (
  // For IE11
  function startsWith3(s5, search, position) {
    return s5.slice(position, position + search.length) === search;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    var elements = "";
    var length = codePoints.length;
    var i3 = 0;
    var code;
    while (length > i3) {
      code = codePoints[i3++];
      if (code > 1114111)
        throw RangeError(code + " is not a valid code point");
      elements += code < 65536 ? String.fromCharCode(code) : String.fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries) {
      var obj = {};
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _a2 = entries_1[_i], k2 = _a2[0], v2 = _a2[1];
        obj[k2] = v2;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s5, index) {
    return s5.codePointAt(index);
  }
) : (
  // IE 11
  function codePointAt3(s5, index) {
    var size = s5.length;
    if (index < 0 || index >= size) {
      return void 0;
    }
    var first = s5.charCodeAt(index);
    var second;
    return first < 55296 || first > 56319 || index + 1 === size || (second = s5.charCodeAt(index + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s5) {
    return s5.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s5) {
    return s5.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s5) {
    return s5.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s5) {
    return s5.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s5, flag) {
  return new RegExp(s5, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s5, index) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index;
    var match = IDENTIFIER_PREFIX_RE_1.exec(s5);
    return (_a2 = match[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s5, index) {
    var match = [];
    while (true) {
      var c3 = codePointAt(s5, index);
      if (c3 === void 0 || _isWhiteSpace(c3) || _isPatternSyntax(c3)) {
        break;
      }
      match.push(c3);
      index += c3 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser = (
  /** @class */
  function() {
    function Parser2(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser2.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser2.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char = this.char();
        if (char === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char === 125 && nestingLevel > 0) {
          break;
        } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position, this.clonePosition())
          });
        } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser2.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser2.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start = this.clonePosition();
      var value = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location = createLocation(start, this.clonePosition());
      return {
        val: { type: TYPE.literal, value, location },
        err: null
      };
    };
    Parser2.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser2.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        // '{', '<', '>', '}'
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser2.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch);
      }
    };
    Parser2.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value = this.parseIdentifierIfPossible().value;
      if (!value) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        // Simple argument: `{name}`
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        // Argument with options: `{name, format, ...}`
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location = createLocation(startingPosition, endPosition);
      return { value, location };
    };
    Parser2.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
      var _a2;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type, value, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value,
              location: location_1,
              style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser2.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser2.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser2.prototype.parseNumberSkeletonFromString = function(skeleton, location) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e4) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser2.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a2;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser2.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) {
      } else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location);
      }
      return { val: decimal, err: null };
    };
    Parser2.prototype.offset = function() {
      return this.position.offset;
    };
    Parser2.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser2.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser2.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code = codePointAt(this.message, offset);
      if (code === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code;
    };
    Parser2.prototype.error = function(kind, location) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location
        }
      };
    };
    Parser2.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code = this.char();
      if (code === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code < 65536 ? 1 : 2;
      }
    };
    Parser2.prototype.bumpIf = function(prefix) {
      if (startsWith(this.message, prefix, this.offset())) {
        for (var i3 = 0; i3 < prefix.length; i3++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser2.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index = this.message.indexOf(pattern, currentOffset);
      if (index >= 0) {
        this.bumpTo(index);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser2.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser2.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser2.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser2;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c3) {
  return c3 === 45 || c3 === 46 || c3 >= 48 && c3 <= 57 || c3 === 95 || c3 >= 97 && c3 <= 122 || c3 >= 65 && c3 <= 90 || c3 == 183 || c3 >= 192 && c3 <= 214 || c3 >= 216 && c3 <= 246 || c3 >= 248 && c3 <= 893 || c3 >= 895 && c3 <= 8191 || c3 >= 8204 && c3 <= 8205 || c3 >= 8255 && c3 <= 8256 || c3 >= 8304 && c3 <= 8591 || c3 >= 11264 && c3 <= 12271 || c3 >= 12289 && c3 <= 55295 || c3 >= 63744 && c3 <= 64975 || c3 >= 65008 && c3 <= 65533 || c3 >= 65536 && c3 <= 983039;
}
function _isWhiteSpace(c3) {
  return c3 >= 9 && c3 <= 13 || c3 === 32 || c3 === 133 || c3 >= 8206 && c3 <= 8207 || c3 === 8232 || c3 === 8233;
}
function _isPatternSyntax(c3) {
  return c3 >= 33 && c3 <= 35 || c3 === 36 || c3 >= 37 && c3 <= 39 || c3 === 40 || c3 === 41 || c3 === 42 || c3 === 43 || c3 === 44 || c3 === 45 || c3 >= 46 && c3 <= 47 || c3 >= 58 && c3 <= 59 || c3 >= 60 && c3 <= 62 || c3 >= 63 && c3 <= 64 || c3 === 91 || c3 === 92 || c3 === 93 || c3 === 94 || c3 === 96 || c3 === 123 || c3 === 124 || c3 === 125 || c3 === 126 || c3 === 161 || c3 >= 162 && c3 <= 165 || c3 === 166 || c3 === 167 || c3 === 169 || c3 === 171 || c3 === 172 || c3 === 174 || c3 === 176 || c3 === 177 || c3 === 182 || c3 === 187 || c3 === 191 || c3 === 215 || c3 === 247 || c3 >= 8208 && c3 <= 8213 || c3 >= 8214 && c3 <= 8215 || c3 === 8216 || c3 === 8217 || c3 === 8218 || c3 >= 8219 && c3 <= 8220 || c3 === 8221 || c3 === 8222 || c3 === 8223 || c3 >= 8224 && c3 <= 8231 || c3 >= 8240 && c3 <= 8248 || c3 === 8249 || c3 === 8250 || c3 >= 8251 && c3 <= 8254 || c3 >= 8257 && c3 <= 8259 || c3 === 8260 || c3 === 8261 || c3 === 8262 || c3 >= 8263 && c3 <= 8273 || c3 === 8274 || c3 === 8275 || c3 >= 8277 && c3 <= 8286 || c3 >= 8592 && c3 <= 8596 || c3 >= 8597 && c3 <= 8601 || c3 >= 8602 && c3 <= 8603 || c3 >= 8604 && c3 <= 8607 || c3 === 8608 || c3 >= 8609 && c3 <= 8610 || c3 === 8611 || c3 >= 8612 && c3 <= 8613 || c3 === 8614 || c3 >= 8615 && c3 <= 8621 || c3 === 8622 || c3 >= 8623 && c3 <= 8653 || c3 >= 8654 && c3 <= 8655 || c3 >= 8656 && c3 <= 8657 || c3 === 8658 || c3 === 8659 || c3 === 8660 || c3 >= 8661 && c3 <= 8691 || c3 >= 8692 && c3 <= 8959 || c3 >= 8960 && c3 <= 8967 || c3 === 8968 || c3 === 8969 || c3 === 8970 || c3 === 8971 || c3 >= 8972 && c3 <= 8991 || c3 >= 8992 && c3 <= 8993 || c3 >= 8994 && c3 <= 9e3 || c3 === 9001 || c3 === 9002 || c3 >= 9003 && c3 <= 9083 || c3 === 9084 || c3 >= 9085 && c3 <= 9114 || c3 >= 9115 && c3 <= 9139 || c3 >= 9140 && c3 <= 9179 || c3 >= 9180 && c3 <= 9185 || c3 >= 9186 && c3 <= 9254 || c3 >= 9255 && c3 <= 9279 || c3 >= 9280 && c3 <= 9290 || c3 >= 9291 && c3 <= 9311 || c3 >= 9472 && c3 <= 9654 || c3 === 9655 || c3 >= 9656 && c3 <= 9664 || c3 === 9665 || c3 >= 9666 && c3 <= 9719 || c3 >= 9720 && c3 <= 9727 || c3 >= 9728 && c3 <= 9838 || c3 === 9839 || c3 >= 9840 && c3 <= 10087 || c3 === 10088 || c3 === 10089 || c3 === 10090 || c3 === 10091 || c3 === 10092 || c3 === 10093 || c3 === 10094 || c3 === 10095 || c3 === 10096 || c3 === 10097 || c3 === 10098 || c3 === 10099 || c3 === 10100 || c3 === 10101 || c3 >= 10132 && c3 <= 10175 || c3 >= 10176 && c3 <= 10180 || c3 === 10181 || c3 === 10182 || c3 >= 10183 && c3 <= 10213 || c3 === 10214 || c3 === 10215 || c3 === 10216 || c3 === 10217 || c3 === 10218 || c3 === 10219 || c3 === 10220 || c3 === 10221 || c3 === 10222 || c3 === 10223 || c3 >= 10224 && c3 <= 10239 || c3 >= 10240 && c3 <= 10495 || c3 >= 10496 && c3 <= 10626 || c3 === 10627 || c3 === 10628 || c3 === 10629 || c3 === 10630 || c3 === 10631 || c3 === 10632 || c3 === 10633 || c3 === 10634 || c3 === 10635 || c3 === 10636 || c3 === 10637 || c3 === 10638 || c3 === 10639 || c3 === 10640 || c3 === 10641 || c3 === 10642 || c3 === 10643 || c3 === 10644 || c3 === 10645 || c3 === 10646 || c3 === 10647 || c3 === 10648 || c3 >= 10649 && c3 <= 10711 || c3 === 10712 || c3 === 10713 || c3 === 10714 || c3 === 10715 || c3 >= 10716 && c3 <= 10747 || c3 === 10748 || c3 === 10749 || c3 >= 10750 && c3 <= 11007 || c3 >= 11008 && c3 <= 11055 || c3 >= 11056 && c3 <= 11076 || c3 >= 11077 && c3 <= 11078 || c3 >= 11079 && c3 <= 11084 || c3 >= 11085 && c3 <= 11123 || c3 >= 11124 && c3 <= 11125 || c3 >= 11126 && c3 <= 11157 || c3 === 11158 || c3 >= 11159 && c3 <= 11263 || c3 >= 11776 && c3 <= 11777 || c3 === 11778 || c3 === 11779 || c3 === 11780 || c3 === 11781 || c3 >= 11782 && c3 <= 11784 || c3 === 11785 || c3 === 11786 || c3 === 11787 || c3 === 11788 || c3 === 11789 || c3 >= 11790 && c3 <= 11798 || c3 === 11799 || c3 >= 11800 && c3 <= 11801 || c3 === 11802 || c3 === 11803 || c3 === 11804 || c3 === 11805 || c3 >= 11806 && c3 <= 11807 || c3 === 11808 || c3 === 11809 || c3 === 11810 || c3 === 11811 || c3 === 11812 || c3 === 11813 || c3 === 11814 || c3 === 11815 || c3 === 11816 || c3 === 11817 || c3 >= 11818 && c3 <= 11822 || c3 === 11823 || c3 >= 11824 && c3 <= 11833 || c3 >= 11834 && c3 <= 11835 || c3 >= 11836 && c3 <= 11839 || c3 === 11840 || c3 === 11841 || c3 === 11842 || c3 >= 11843 && c3 <= 11855 || c3 >= 11856 && c3 <= 11857 || c3 === 11858 || c3 >= 11859 && c3 <= 11903 || c3 >= 12289 && c3 <= 12291 || c3 === 12296 || c3 === 12297 || c3 === 12298 || c3 === 12299 || c3 === 12300 || c3 === 12301 || c3 === 12302 || c3 === 12303 || c3 === 12304 || c3 === 12305 || c3 >= 12306 && c3 <= 12307 || c3 === 12308 || c3 === 12309 || c3 === 12310 || c3 === 12311 || c3 === 12312 || c3 === 12313 || c3 === 12314 || c3 === 12315 || c3 === 12316 || c3 === 12317 || c3 >= 12318 && c3 <= 12319 || c3 === 12320 || c3 === 12336 || c3 === 64830 || c3 === 64831 || c3 >= 65093 && c3 <= 65094;
}

// ../node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// ../node_modules/@formatjs/fast-memoize/lib/index.js
function memoize(fn, options) {
  var cache2 = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn, {
    cache: cache2,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn, cache2, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache2.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.call(this, arg);
    cache2.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn, cache2, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache2.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.apply(this, args);
    cache2.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn, context, strategy, cache2, serialize) {
  return strategy.bind(context, fn, cache2, serialize);
}
function strategyDefault(fn, options) {
  var strategy = fn.length === 1 ? monadic : variadic;
  return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
  return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
  return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// ../node_modules/intl-messageformat/lib/src/error.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg, code, originalMessage) {
      var _this = _super.call(this, msg) || this;
      _this.code = code;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value, type, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);

// ../node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p2) {
        return p2.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c3) {
        return {
          type: typeof c3 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c3
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// ../node_modules/intl-messageformat/lib/src/core.js
function mergeConfig(c1, c22) {
  if (!c22) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c22 || {}), Object.keys(c1).reduce(function(all, k2) {
    all[k2] = __assign(__assign({}, c1[k2]), c22[k2] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k2) {
    all[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache2) {
  if (cache2 === void 0) {
    cache2 = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache2.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache2.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache2.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      var _this = this;
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values) {
        var parts = _this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all, part) {
          if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
            all.push(part.value);
          } else {
            all[all.length - 1] += part.value;
          }
          return all;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        return {
          locale: _this.resolvedLocale.toString()
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        this.ast = IntlMessageFormat2.__parse(message, {
          ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
          locale: this.resolvedLocale
        });
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);

// ../node_modules/intl-messageformat/lib/index.js
var lib_default = IntlMessageFormat;

// src/price/numberFormat.js
var maskRegex = /[0-9\-+#]/;
var notMaskRegex = /[^\d\-+#]/g;
function getIndex(mask) {
  return mask.search(maskRegex);
}
function processMask(mask = "#.##") {
  const maskObj = {};
  const len = mask.length;
  const start = getIndex(mask);
  maskObj.prefix = start > 0 ? mask.substring(0, start) : "";
  const end = getIndex(mask.split("").reverse().join(""));
  const offset = len - end;
  const substr = mask.substring(offset, offset + 1);
  const indx = offset + (substr === "." || substr === "," ? 1 : 0);
  maskObj.suffix = end > 0 ? mask.substring(indx, len) : "";
  maskObj.mask = mask.substring(start, indx);
  maskObj.maskHasNegativeSign = maskObj.mask.charAt(0) === "-";
  maskObj.maskHasPositiveSign = maskObj.mask.charAt(0) === "+";
  let result = maskObj.mask.match(notMaskRegex);
  maskObj.decimal = result && result[result.length - 1] || ".";
  maskObj.separator = result && result[1] && result[0] || ",";
  result = maskObj.mask.split(maskObj.decimal);
  maskObj.integer = result[0];
  maskObj.fraction = result[1];
  return maskObj;
}
function processValue(value, maskObj, options) {
  let isNegative = false;
  const valObj = {
    value
  };
  if (value < 0) {
    isNegative = true;
    valObj.value = -valObj.value;
  }
  valObj.sign = isNegative ? "-" : "";
  valObj.value = Number(valObj.value).toFixed(
    maskObj.fraction && maskObj.fraction.length
  );
  valObj.value = Number(valObj.value).toString();
  const posTrailZero = maskObj.fraction && maskObj.fraction.lastIndexOf("0");
  let [valInteger = "0", valFraction = ""] = valObj.value.split(".");
  if (!valFraction || valFraction && valFraction.length <= posTrailZero) {
    valFraction = posTrailZero < 0 ? "" : Number("0." + valFraction).toFixed(posTrailZero + 1).replace("0.", "");
  }
  valObj.integer = valInteger;
  valObj.fraction = valFraction;
  addSeparators(valObj, maskObj);
  if (valObj.result === "0" || valObj.result === "") {
    isNegative = false;
    valObj.sign = "";
  }
  if (!isNegative && maskObj.maskHasPositiveSign) {
    valObj.sign = "+";
  } else if (isNegative && maskObj.maskHasPositiveSign) {
    valObj.sign = "-";
  } else if (isNegative) {
    valObj.sign = options && options.enforceMaskSign && !maskObj.maskHasNegativeSign ? "" : "-";
  }
  return valObj;
}
function addSeparators(valObj, maskObj) {
  valObj.result = "";
  const szSep = maskObj.integer.split(maskObj.separator);
  const maskInteger = szSep.join("");
  const posLeadZero = maskInteger && maskInteger.indexOf("0");
  if (posLeadZero > -1) {
    while (valObj.integer.length < maskInteger.length - posLeadZero) {
      valObj.integer = "0" + valObj.integer;
    }
  } else if (Number(valObj.integer) === 0) {
    valObj.integer = "";
  }
  const posSeparator = szSep[1] && szSep[szSep.length - 1].length;
  if (posSeparator) {
    const len = valObj.integer.length;
    const offset = len % posSeparator;
    for (let indx = 0; indx < len; indx++) {
      valObj.result += valObj.integer.charAt(indx);
      if (!((indx - offset + 1) % posSeparator) && indx < len - posSeparator) {
        valObj.result += maskObj.separator;
      }
    }
  } else {
    valObj.result = valObj.integer;
  }
  valObj.result += maskObj.fraction && valObj.fraction ? maskObj.decimal + valObj.fraction : "";
  return valObj;
}
function formatNumber(mask, value, options = {}) {
  if (!mask || isNaN(Number(value))) {
    return value;
  }
  const maskObj = processMask(mask);
  const valObj = processValue(value, maskObj, options);
  return maskObj.prefix + valObj.sign + valObj.result + maskObj.suffix;
}
var numberFormat_default = formatNumber;

// src/price/utilities.js
var DECIMAL_POINT = ".";
var DECIMAL_COMMA = ",";
var SPACE_START_PATTERN = /^\s+/;
var SPACE_END_PATTERN = /\s+$/;
var NBSP = "&nbsp;";
var getAnnualPrice = (price2) => price2 * 12;
var isPromotionActive = (promotion, instant) => {
  const {
    start,
    end,
    displaySummary: {
      amount,
      duration,
      minProductQuantity,
      outcomeType
    } = {}
  } = promotion;
  if (!(amount && duration && outcomeType && minProductQuantity)) {
    return false;
  }
  const now = instant ? new Date(instant) : /* @__PURE__ */ new Date();
  if (!start || !end) {
    return false;
  }
  const startDate = new Date(start);
  const endDate = new Date(end);
  return now >= startDate && now <= endDate;
};
var RecurrenceTerm = {
  MONTH: "MONTH",
  YEAR: "YEAR"
};
var opticalPriceDivisors = {
  [Term.ANNUAL]: 12,
  [Term.MONTHLY]: 1,
  [Term.THREE_YEARS]: 36,
  [Term.TWO_YEARS]: 24
};
var opticalPriceRoundingRule = (accept, round) => ({ accept, round });
var opticalPriceRoundingRules = [
  opticalPriceRoundingRule(
    // optical price for the term is a multiple of the initial price
    ({ divisor, price: price2 }) => price2 % divisor == 0,
    ({ divisor, price: price2 }) => price2 / divisor
  ),
  opticalPriceRoundingRule(
    // round optical price up to 2 decimals
    ({ usePrecision }) => usePrecision,
    ({ divisor, price: price2 }) => Math.round(price2 / divisor * 100) / 100
  ),
  opticalPriceRoundingRule(
    // round optical price up to integer
    () => true,
    ({ divisor, price: price2 }) => Math.ceil(Math.floor(price2 * 100 / divisor) / 100)
  )
];
var recurrenceTerms = {
  [Commitment.YEAR]: {
    [Term.MONTHLY]: RecurrenceTerm.MONTH,
    [Term.ANNUAL]: RecurrenceTerm.YEAR
  },
  [Commitment.MONTH]: {
    [Term.MONTHLY]: RecurrenceTerm.MONTH
  }
};
var currencyIsFirstChar = (formatString, currencySymbol) => formatString.indexOf(`'${currencySymbol}'`) === 0;
var extractNumberMask = (formatString, usePrecision = true) => {
  let numberMask = formatString.replace(/'.*?'/, "").trim();
  const decimalsDelimiter = findDecimalsDelimiter(numberMask);
  const hasDecimalDelimiter = !!decimalsDelimiter;
  if (!hasDecimalDelimiter) {
    numberMask = numberMask.replace(
      /\s?(#.*0)(?!\s)?/,
      "$&" + getPossibleDecimalsDelimiter(formatString)
    );
  } else if (!usePrecision) {
    numberMask = numberMask.replace(/[,\.]0+/, decimalsDelimiter);
  }
  return numberMask;
};
var getCurrencySymbolDetails = (formatString) => {
  const currencySymbol = findCurrencySymbol(formatString);
  const isCurrencyFirst = currencyIsFirstChar(formatString, currencySymbol);
  const formatStringWithoutSymbol = formatString.replace(/'.*?'/, "");
  const hasCurrencySpace = SPACE_START_PATTERN.test(formatStringWithoutSymbol) || SPACE_END_PATTERN.test(formatStringWithoutSymbol);
  return { currencySymbol, isCurrencyFirst, hasCurrencySpace };
};
var makeSpacesAroundNonBreaking = (text) => {
  return text.replace(SPACE_START_PATTERN, NBSP).replace(SPACE_END_PATTERN, NBSP);
};
var getPossibleDecimalsDelimiter = (formatString) => formatString.match(/#(.?)#/)?.[1] === DECIMAL_POINT ? DECIMAL_COMMA : DECIMAL_POINT;
var findCurrencySymbol = (formatString) => formatString.match(/'(.*?)'/)?.[1] ?? "";
var findDecimalsDelimiter = (formatString) => formatString.match(/0(.?)0/)?.[1] ?? "";
function formatPrice({ formatString, price: price2, usePrecision, isIndianPrice = false }, recurrenceTerm, transformPrice = (formattedPrice) => formattedPrice) {
  const { currencySymbol, isCurrencyFirst, hasCurrencySpace } = getCurrencySymbolDetails(formatString);
  const decimalsDelimiter = usePrecision ? findDecimalsDelimiter(formatString) : "";
  const numberMask = extractNumberMask(formatString, usePrecision);
  const fractionDigits = usePrecision ? 2 : 0;
  const transformedPrice = transformPrice(price2, { currencySymbol });
  const formattedPrice = isIndianPrice ? transformedPrice.toLocaleString("hi-IN", {
    minimumFractionDigits: fractionDigits,
    maximumFractionDigits: fractionDigits
  }) : numberFormat_default(numberMask, transformedPrice);
  const decimalIndex = usePrecision ? formattedPrice.lastIndexOf(decimalsDelimiter) : formattedPrice.length;
  const integer = formattedPrice.substring(0, decimalIndex);
  const decimals = formattedPrice.substring(decimalIndex + 1);
  const accessiblePrice = formatString.replace(/'.*?'/, "SYMBOL").replace(/#.*0/, formattedPrice).replace(/SYMBOL/, currencySymbol);
  return {
    accessiblePrice,
    currencySymbol,
    decimals,
    decimalsDelimiter,
    hasCurrencySpace,
    integer,
    isCurrencyFirst,
    recurrenceTerm
  };
}
var formatOpticalPrice = (data) => {
  const { commitment, term, usePrecision } = data;
  const divisor = opticalPriceDivisors[term] ?? 1;
  return formatPrice(
    data,
    divisor > 1 ? RecurrenceTerm.MONTH : recurrenceTerms[commitment]?.[term],
    (price2) => {
      const priceData = {
        divisor,
        price: price2,
        usePrecision
      };
      const { round } = opticalPriceRoundingRules.find(
        ({ accept }) => accept(priceData)
      );
      if (!round)
        throw new Error(
          `Missing rounding rule for: ${JSON.stringify(priceData)}`
        );
      return round(priceData);
    }
  );
};
var formatRegularPrice = ({ commitment, term, ...data }) => formatPrice(data, recurrenceTerms[commitment]?.[term]);
var formatAnnualPrice = (data) => {
  const {
    commitment,
    instant,
    price: price2,
    originalPrice,
    priceWithoutDiscount,
    promotion,
    quantity = 1,
    term
  } = data;
  if (commitment === Commitment.YEAR && term === Term.MONTHLY) {
    if (!promotion) {
      return formatPrice(data, RecurrenceTerm.YEAR, getAnnualPrice);
    }
    const {
      displaySummary: {
        outcomeType,
        duration,
        minProductQuantity = 1
      } = {}
    } = promotion;
    switch (outcomeType) {
      case "PERCENTAGE_DISCOUNT": {
        if (quantity >= minProductQuantity && isPromotionActive(promotion, instant)) {
          const durationInMonths = parseInt(
            duration.replace("P", "").replace("M", "")
          );
          if (isNaN(durationInMonths)) return getAnnualPrice(price2);
          const discountPrice = quantity * originalPrice * durationInMonths;
          const regularPrice = quantity * priceWithoutDiscount * (12 - durationInMonths);
          const totalPrice = Math.round((discountPrice + regularPrice) * 100) / 100;
          return formatPrice(
            { ...data, price: totalPrice },
            RecurrenceTerm.YEAR
          );
        }
      }
      default:
        return formatPrice(
          data,
          RecurrenceTerm.YEAR,
          () => getAnnualPrice(priceWithoutDiscount ?? price2)
        );
    }
  }
  return formatPrice(data, recurrenceTerms[commitment]?.[term]);
};

// src/price/template.js
var defaultLiterals = {
  recurrenceLabel: "{recurrenceTerm, select, MONTH {/mo} YEAR {/yr} other {}}",
  recurrenceAriaLabel: "{recurrenceTerm, select, MONTH {per month} YEAR {per year} other {}}",
  perUnitLabel: "{perUnit, select, LICENSE {per license} other {}}",
  perUnitAriaLabel: "{perUnit, select, LICENSE {per license} other {}}",
  freeLabel: "Free",
  freeAriaLabel: "Free",
  taxExclusiveLabel: "{taxTerm, select, GST {excl. GST} VAT {excl. VAT} TAX {excl. tax} IVA {excl. IVA} SST {excl. SST} KDV {excl. KDV} other {}}",
  taxInclusiveLabel: "{taxTerm, select, GST {incl. GST} VAT {incl. VAT} TAX {incl. tax} IVA {incl. IVA} SST {incl. SST} KDV {incl. KDV} other {}}",
  alternativePriceAriaLabel: "Alternatively at",
  strikethroughAriaLabel: "Regularly at",
  planTypeLabel: "{planType, select, ABM {Annual, billed monthly} other {}}"
};
var log = createLog("ConsonantTemplates/price");
var htmlPattern = /<\/?[^>]+(>|$)/g;
var cssClassNames = {
  container: "price",
  containerOptical: "price-optical",
  containerStrikethrough: "price-strikethrough",
  containerAlternative: "price-alternative",
  containerAnnual: "price-annual",
  containerAnnualPrefix: "price-annual-prefix",
  containerAnnualSuffix: "price-annual-suffix",
  disabled: "disabled",
  currencySpace: "price-currency-space",
  currencySymbol: "price-currency-symbol",
  decimals: "price-decimals",
  decimalsDelimiter: "price-decimals-delimiter",
  integer: "price-integer",
  recurrence: "price-recurrence",
  taxInclusivity: "price-tax-inclusivity",
  unitType: "price-unit-type"
};
var literalKeys = {
  perUnitLabel: "perUnitLabel",
  perUnitAriaLabel: "perUnitAriaLabel",
  recurrenceLabel: "recurrenceLabel",
  recurrenceAriaLabel: "recurrenceAriaLabel",
  taxExclusiveLabel: "taxExclusiveLabel",
  taxInclusiveLabel: "taxInclusiveLabel",
  strikethroughAriaLabel: "strikethroughAriaLabel",
  alternativePriceAriaLabel: "alternativePriceAriaLabel"
};
var WCS_TAX_DISPLAY_EXCLUSIVE = "TAX_EXCLUSIVE";
var renderAttributes = (attributes) => isObject(attributes) ? Object.entries(attributes).filter(
  ([, value]) => isString(value) || isNumber(value) || value === true
).reduce(
  (html, [key, value]) => html + ` ${key}${value === true ? "" : '="' + escapeHtml(value) + '"'}`,
  ""
) : "";
var renderSpan = (cssClass, content, attributes, convertSpaces = false) => {
  return `<span class="${cssClass}${content ? "" : " " + cssClassNames.disabled}"${renderAttributes(attributes)}>${convertSpaces ? makeSpacesAroundNonBreaking(content) : content ?? ""}</span>`;
};
function formatLiteral(literals, locale, key, parameters) {
  const literal = literals[key];
  if (literal == void 0) {
    return "";
  }
  try {
    return new lib_default(
      literal.replace(htmlPattern, ""),
      locale
    ).format(parameters);
  } catch {
    log.error("Failed to format literal:", literal);
    return "";
  }
}
function renderContainer(cssClass, {
  accessibleLabel,
  altAccessibleLabel,
  currencySymbol,
  decimals,
  decimalsDelimiter,
  hasCurrencySpace,
  integer,
  isCurrencyFirst,
  recurrenceLabel,
  perUnitLabel,
  taxInclusivityLabel
}, attributes = {}) {
  const currencyMarkup = renderSpan(
    cssClassNames.currencySymbol,
    currencySymbol
  );
  const currencySpaceMarkup = renderSpan(
    cssClassNames.currencySpace,
    hasCurrencySpace ? "&nbsp;" : ""
  );
  let markup = "";
  if (accessibleLabel)
    markup = `<sr-only class="strikethrough-aria-label">${accessibleLabel}</sr-only>`;
  else if (altAccessibleLabel)
    markup = `<sr-only class="alt-aria-label">${altAccessibleLabel}</sr-only>`;
  if (isCurrencyFirst) markup += currencyMarkup + currencySpaceMarkup;
  markup += renderSpan(cssClassNames.integer, integer);
  markup += renderSpan(cssClassNames.decimalsDelimiter, decimalsDelimiter);
  markup += renderSpan(cssClassNames.decimals, decimals);
  if (!isCurrencyFirst) markup += currencySpaceMarkup + currencyMarkup;
  markup += renderSpan(cssClassNames.recurrence, recurrenceLabel, null, true);
  markup += renderSpan(cssClassNames.unitType, perUnitLabel, null, true);
  markup += renderSpan(
    cssClassNames.taxInclusivity,
    taxInclusivityLabel,
    true
  );
  return renderSpan(cssClass, markup, {
    ...attributes
  });
}
var createPriceTemplate = ({
  isAlternativePrice = false,
  displayOptical = false,
  displayStrikethrough = false,
  displayAnnual = false,
  instant = void 0
} = {}) => ({
  country,
  displayFormatted = true,
  displayRecurrence = true,
  displayPerUnit = false,
  displayTax = false,
  language,
  literals: priceLiterals2 = {},
  quantity = 1,
  space = false
  // add a space between price literals
} = {}, {
  commitment,
  offerSelectorIds,
  formatString,
  price: price2,
  priceWithoutDiscount,
  taxDisplay,
  taxTerm,
  term,
  usePrecision,
  promotion
} = {}, attributes = {}) => {
  Object.entries({
    country,
    formatString,
    language,
    price: price2
  }).forEach(([key, value]) => {
    if (value == null) {
      throw new Error(
        `Argument "${key}" is missing for osi ${offerSelectorIds?.toString()}, country ${country}, language ${language}`
      );
    }
  });
  const literals = {
    ...defaultLiterals,
    ...priceLiterals2
  };
  const locale = `${language.toLowerCase()}-${country.toUpperCase()}`;
  const displayPrice = displayStrikethrough && priceWithoutDiscount ? priceWithoutDiscount : price2;
  let method = displayOptical ? formatOpticalPrice : formatRegularPrice;
  if (displayAnnual) {
    method = formatAnnualPrice;
  }
  const { accessiblePrice, recurrenceTerm, ...formattedPrice } = method({
    commitment,
    formatString,
    instant,
    isIndianPrice: country === "IN",
    originalPrice: price2,
    priceWithoutDiscount,
    price: displayOptical ? price2 : displayPrice,
    promotion,
    quantity,
    term,
    usePrecision
  });
  let accessibleLabel = "", altAccessibleLabel = "";
  let recurrenceLabel = "";
  if (toBoolean(displayRecurrence) && recurrenceTerm) {
    recurrenceLabel = formatLiteral(
      literals,
      locale,
      literalKeys.recurrenceLabel,
      {
        recurrenceTerm
      }
    );
  }
  let perUnitLabel = "";
  if (toBoolean(displayPerUnit)) {
    if (space) {
      perUnitLabel += " ";
    }
    perUnitLabel += formatLiteral(
      literals,
      locale,
      literalKeys.perUnitLabel,
      {
        perUnit: "LICENSE"
      }
    );
  }
  let taxInclusivityLabel = "";
  if (toBoolean(displayTax) && taxTerm) {
    if (space) {
      taxInclusivityLabel += " ";
    }
    taxInclusivityLabel += formatLiteral(
      literals,
      locale,
      taxDisplay === WCS_TAX_DISPLAY_EXCLUSIVE ? literalKeys.taxExclusiveLabel : literalKeys.taxInclusiveLabel,
      { taxTerm }
    );
  }
  if (displayStrikethrough) {
    accessibleLabel = formatLiteral(
      literals,
      locale,
      literalKeys.strikethroughAriaLabel,
      {
        strikethroughPrice: accessibleLabel
      }
    );
  }
  if (isAlternativePrice) {
    altAccessibleLabel = formatLiteral(
      literals,
      locale,
      literalKeys.alternativePriceAriaLabel,
      {
        alternativePrice: altAccessibleLabel
      }
    );
  }
  let cssClass = cssClassNames.container;
  if (displayOptical) {
    cssClass += " " + cssClassNames.containerOptical;
  }
  if (displayStrikethrough) {
    cssClass += " " + cssClassNames.containerStrikethrough;
  }
  if (isAlternativePrice) {
    cssClass += " " + cssClassNames.containerAlternative;
  }
  if (displayAnnual) {
    cssClass += " " + cssClassNames.containerAnnual;
  }
  if (toBoolean(displayFormatted)) {
    return renderContainer(
      cssClass,
      {
        ...formattedPrice,
        accessibleLabel,
        altAccessibleLabel,
        recurrenceLabel,
        perUnitLabel,
        taxInclusivityLabel
      },
      attributes
    );
  }
  const {
    currencySymbol,
    decimals,
    decimalsDelimiter,
    hasCurrencySpace,
    integer,
    isCurrencyFirst
  } = formattedPrice;
  const unformattedPrice = [integer, decimalsDelimiter, decimals];
  if (isCurrencyFirst) {
    unformattedPrice.unshift(hasCurrencySpace ? "\xA0" : "");
    unformattedPrice.unshift(currencySymbol);
  } else {
    unformattedPrice.push(hasCurrencySpace ? "\xA0" : "");
    unformattedPrice.push(currencySymbol);
  }
  unformattedPrice.push(
    recurrenceLabel,
    perUnitLabel,
    taxInclusivityLabel
  );
  const content = unformattedPrice.join("");
  return renderSpan(cssClass, content, attributes);
};
var createPromoPriceTemplate = () => (context, value, attributes) => {
  const displayOldPrice = context.displayOldPrice === void 0 || toBoolean(context.displayOldPrice);
  const shouldDisplayOldPrice = displayOldPrice && value.priceWithoutDiscount && value.priceWithoutDiscount != value.price;
  return `${shouldDisplayOldPrice ? createPriceTemplate({
    displayStrikethrough: true
  })(context, value, attributes) + "&nbsp;" : ""}${createPriceTemplate({ isAlternativePrice: shouldDisplayOldPrice })(context, value, attributes)}`;
};
var createPromoPriceWithAnnualTemplate = () => (context, value, attributes) => {
  let { instant } = context;
  try {
    if (!instant) {
      instant = new URLSearchParams(document.location.search).get(
        "instant"
      );
    }
    if (instant) {
      instant = new Date(instant);
    }
  } catch (e4) {
    instant = void 0;
  }
  const ctxStAnnual = {
    ...context,
    displayTax: false,
    displayPerUnit: false
  };
  const displayOldPrice = context.displayOldPrice === void 0 || toBoolean(context.displayOldPrice);
  const shouldDisplayOldPrice = displayOldPrice && value.priceWithoutDiscount && value.priceWithoutDiscount != value.price;
  return `${shouldDisplayOldPrice ? createPriceTemplate({
    displayStrikethrough: true
  })(ctxStAnnual, value, attributes) + "&nbsp;" : ""}${createPriceTemplate({ isAlternativePrice: shouldDisplayOldPrice })(context, value, attributes)}${renderSpan(cssClassNames.containerAnnualPrefix, "&nbsp;(")}${createPriceTemplate(
    {
      displayAnnual: true,
      instant
    }
  )(
    ctxStAnnual,
    value,
    attributes
  )}${renderSpan(cssClassNames.containerAnnualSuffix, ")")}`;
};
var createPriceWithAnnualTemplate = () => (context, value, attributes) => {
  const ctxAnnual = {
    ...context,
    displayTax: false,
    displayPerUnit: false
  };
  return `${createPriceTemplate({ isAlternativePrice: context.displayOldPrice })(context, value, attributes)}${renderSpan(cssClassNames.containerAnnualPrefix, "&nbsp;(")}${createPriceTemplate(
    {
      displayAnnual: true
    }
  )(
    ctxAnnual,
    value,
    attributes
  )}${renderSpan(cssClassNames.containerAnnualSuffix, ")")}`;
};

// src/price/legal.js
var cssClassNames2 = {
  ...cssClassNames,
  containerLegal: "price-legal",
  planType: "price-plan-type"
};
var literalKeys2 = {
  ...literalKeys,
  planTypeLabel: "planTypeLabel"
};
function renderContainer2(cssClass, { perUnitLabel, taxInclusivityLabel, planTypeLabel }, attributes = {}) {
  let markup = "";
  markup += renderSpan(cssClassNames2.unitType, perUnitLabel, null, true);
  if (taxInclusivityLabel && planTypeLabel) {
    taxInclusivityLabel += ". ";
  }
  markup += renderSpan(
    cssClassNames2.taxInclusivity,
    taxInclusivityLabel,
    true
  );
  markup += renderSpan(cssClassNames2.planType, planTypeLabel, null);
  return renderSpan(cssClass, markup, {
    ...attributes
  });
}
var legalTemplate = ({
  country,
  displayPerUnit = false,
  displayTax = false,
  displayPlanType = false,
  language,
  literals: priceLiterals2 = {}
} = {}, { taxDisplay, taxTerm, planType } = {}, attributes = {}) => {
  const literals = {
    ...defaultLiterals,
    ...priceLiterals2
  };
  const locale = `${language.toLowerCase()}-${country.toUpperCase()}`;
  let perUnitLabel = "";
  if (toBoolean(displayPerUnit)) {
    perUnitLabel = formatLiteral(
      literals,
      locale,
      literalKeys2.perUnitLabel,
      {
        perUnit: "LICENSE"
      }
    );
  }
  let taxInclusivityLabel = "";
  if (country === "US" && language === "en") {
    displayTax = false;
  }
  if (toBoolean(displayTax) && taxTerm) {
    taxInclusivityLabel = formatLiteral(
      literals,
      locale,
      taxDisplay === WCS_TAX_DISPLAY_EXCLUSIVE ? literalKeys2.taxExclusiveLabel : literalKeys2.taxInclusiveLabel,
      { taxTerm }
    );
  }
  let planTypeLabel = "";
  if (toBoolean(displayPlanType) && planType) {
    planTypeLabel = formatLiteral(
      literals,
      locale,
      literalKeys2.planTypeLabel,
      {
        planType
      }
    );
  }
  let cssClass = cssClassNames2.container;
  cssClass += " " + cssClassNames2.containerLegal;
  return renderContainer2(
    cssClass,
    {
      perUnitLabel,
      taxInclusivityLabel,
      planTypeLabel
    },
    attributes
  );
};

// src/price/index.js
var price = createPriceTemplate();
var pricePromo = createPromoPriceTemplate();
var priceOptical = createPriceTemplate({
  displayOptical: true
});
var priceStrikethrough = createPriceTemplate({
  displayStrikethrough: true
});
var priceAnnual = createPriceTemplate({
  displayAnnual: true
});
var priceOpticalAlternative = createPriceTemplate({
  displayOptical: true,
  isAlternativePrice: true
});
var priceAlternative = createPriceTemplate({
  isAlternativePrice: true
});
var priceWithAnnual = createPriceWithAnnualTemplate();
var pricePromoWithAnnual = createPromoPriceWithAnnualTemplate();
var legal = legalTemplate;

// src/discount/template.js
var getDiscount = (price2, priceWithoutDiscount) => {
  if (!isPositiveFiniteNumber(price2) || !isPositiveFiniteNumber(priceWithoutDiscount))
    return;
  return Math.floor(
    (priceWithoutDiscount - price2) / priceWithoutDiscount * 100
  );
};
var createDiscountTemplate = () => (context, value) => {
  const { price: price2, priceWithoutDiscount } = value;
  const discount2 = getDiscount(price2, priceWithoutDiscount);
  return discount2 === void 0 ? `<span class="no-discount"></span>` : `<span class="discount">${discount2}%</span>`;
};

// src/discount/index.js
var discount = createDiscountTemplate();

// src/inline-price.js
var INDIVIDUAL = "INDIVIDUAL_COM";
var BUSINESS = "TEAM_COM";
var STUDENT = "INDIVIDUAL_EDU";
var UNIVERSITY = "TEAM_EDU";
var DISPLAY_ALL_TAX_COUNTRIES = [
  "GB_en",
  "AU_en",
  "FR_fr",
  "AT_de",
  "BE_en",
  "BE_fr",
  "BE_nl",
  "BG_bg",
  "CH_de",
  "CH_fr",
  "CH_it",
  "CZ_cs",
  "DE_de",
  "DK_da",
  "EE_et",
  "EG_ar",
  "EG_en",
  "ES_es",
  "FI_fi",
  "GR_el",
  "GR_en",
  "HU_hu",
  "IE_en",
  "IT_it",
  "LU_de",
  "LU_en",
  "LU_fr",
  "NL_nl",
  "NO_nb",
  "PL_pl",
  "PT_pt",
  "RO_ro",
  "SE_sv",
  "SI_sl",
  "SK_sk",
  "TR_tr",
  "UA_uk",
  "ID_en",
  "ID_in",
  "IN_en",
  "IN_hi",
  "JP_ja",
  "MY_en",
  "MY_ms",
  "NZ_en",
  "TH_en",
  "TH_th"
];
var DISPLAY_TAX_MAP = {
  [INDIVIDUAL]: [
    "MU_en",
    "LT_lt",
    "LV_lv",
    "NG_en",
    "SA_ar",
    "SA_en",
    "SG_en",
    "KR_ko"
  ],
  [BUSINESS]: ["MU_en", "LT_lt", "LV_lv", "NG_en", "CO_es", "KR_ko"],
  [STUDENT]: ["LT_lt", "LV_lv", "SA_en", "SG_en"],
  [UNIVERSITY]: ["SG_en", "KR_ko"]
};
var TAX_EXCLUDED_MAP = {
  ["MU_en"]: [false, false, false, false],
  ["NG_en"]: [false, false, false, false],
  ["AU_en"]: [false, false, false, false],
  ["JP_ja"]: [false, false, false, false],
  ["NZ_en"]: [false, false, false, false],
  ["TH_en"]: [false, false, false, false],
  ["TH_th"]: [false, false, false, false],
  ["CO_es"]: [false, true, false, false],
  ["AT_de"]: [false, false, false, true],
  ["SG_en"]: [false, false, false, true]
};
var TAX_EXCLUDED_MAP_INDEX = [INDIVIDUAL, BUSINESS, STUDENT, UNIVERSITY];
var defaultTaxExcluded = (segment) => [BUSINESS, UNIVERSITY].includes(segment);
var resolveTaxExclusive = (country, language, customerSegment, marketSegment) => {
  const locale = `${country}_${language}`;
  const segment = `${customerSegment}_${marketSegment}`;
  const val = TAX_EXCLUDED_MAP[locale];
  if (val) {
    const index = TAX_EXCLUDED_MAP_INDEX.indexOf(segment);
    return val[index];
  }
  return defaultTaxExcluded(segment);
};
var resolveDisplayTaxForGeoAndSegment = (country, language, customerSegment, marketSegment) => {
  const locale = `${country}_${language}`;
  if (DISPLAY_ALL_TAX_COUNTRIES.includes(country) || DISPLAY_ALL_TAX_COUNTRIES.includes(locale)) {
    return true;
  }
  const segmentConfig = DISPLAY_TAX_MAP[`${customerSegment}_${marketSegment}`];
  if (!segmentConfig) {
    return Defaults.displayTax;
  }
  if (segmentConfig.includes(country) || segmentConfig.includes(locale)) {
    return true;
  }
  return Defaults.displayTax;
};
var resolvePriceTaxFlags = async (country, language, customerSegment, marketSegment) => {
  const displayTax = resolveDisplayTaxForGeoAndSegment(
    country,
    language,
    customerSegment,
    marketSegment
  );
  return {
    displayTax,
    forceTaxExclusive: displayTax ? resolveTaxExclusive(
      country,
      language,
      customerSegment,
      marketSegment
    ) : Defaults.forceTaxExclusive
  };
};
var _InlinePrice = class _InlinePrice extends HTMLSpanElement {
  constructor() {
    super();
    __publicField(this, "masElement", new MasElement(this));
    this.handleClick = this.handleClick.bind(this);
  }
  static get observedAttributes() {
    return [
      "data-display-old-price",
      "data-display-per-unit",
      "data-display-recurrence",
      "data-display-tax",
      "data-display-plan-type",
      "data-display-annual",
      "data-perpetual",
      "data-promotion-code",
      "data-force-tax-exclusive",
      "data-template",
      "data-wcs-osi"
    ];
  }
  static createInlinePrice(options) {
    const service = getService();
    if (!service) return null;
    const {
      displayOldPrice,
      displayPerUnit,
      displayRecurrence,
      displayTax,
      displayPlanType,
      displayAnnual,
      forceTaxExclusive,
      perpetual,
      promotionCode,
      quantity,
      alternativePrice,
      template,
      wcsOsi
    } = service.collectPriceOptions(options);
    const element = createMasElement(_InlinePrice, {
      displayOldPrice,
      displayPerUnit,
      displayRecurrence,
      displayTax,
      displayPlanType,
      displayAnnual,
      forceTaxExclusive,
      perpetual,
      promotionCode,
      quantity,
      alternativePrice,
      template,
      wcsOsi
    });
    return element;
  }
  get isInlinePrice() {
    return true;
  }
  attributeChangedCallback(name, _2, value) {
    this.masElement.attributeChangedCallback(name, _2, value);
  }
  connectedCallback() {
    this.masElement.connectedCallback();
    this.addEventListener("click", this.handleClick);
  }
  disconnectedCallback() {
    this.masElement.disconnectedCallback();
    this.removeEventListener("click", this.handleClick);
  }
  handleClick(event) {
    if (event.target === this) return;
    event.stopImmediatePropagation();
    this.dispatchEvent(
      new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        view: window
      })
    );
  }
  onceSettled() {
    return this.masElement.onceSettled();
  }
  get value() {
    return this.masElement.value;
  }
  get options() {
    return this.masElement.options;
  }
  get isFailed() {
    return this.masElement.state === STATE_FAILED;
  }
  requestUpdate(force = false) {
    return this.masElement.requestUpdate(force);
  }
  /**
   * Resolves associated osi via Wcs and renders price offer.
   * @param {Record<string, any>} overrides
   */
  async render(overrides = {}) {
    if (!this.isConnected) return false;
    const service = getService();
    if (!service) return false;
    const priceOptions = service.collectPriceOptions(overrides, this);
    const options = {
      ...service.settings,
      ...priceOptions
    };
    if (!options.wcsOsi.length) return false;
    try {
      const version = this.masElement.togglePending({});
      this.innerHTML = "";
      const [offerSelectors] = await service.resolveOfferSelectors(options);
      let offers = selectOffers(await offerSelectors, options);
      let [offer] = offers;
      if (service.featureFlags[FF_DEFAULTS]) {
        if (priceOptions.displayPerUnit === void 0) {
          options.displayPerUnit = offer.customerSegment !== "INDIVIDUAL";
        }
        if (priceOptions.displayTax === void 0 || priceOptions.forceTaxExclusive === void 0) {
          const { country, language } = options;
          const [marketSegment = ""] = offer.marketSegments;
          const flags = await resolvePriceTaxFlags(
            country,
            language,
            offer.customerSegment,
            marketSegment
          );
          if (priceOptions.displayTax === void 0) {
            options.displayTax = flags?.displayTax || options.displayTax;
          }
          if (priceOptions.forceTaxExclusive === void 0) {
            options.forceTaxExclusive = flags?.forceTaxExclusive || options.forceTaxExclusive;
          }
          if (options.forceTaxExclusive) {
            offers = selectOffers(offers, options);
          }
        }
      } else {
        if (priceOptions.displayOldPrice === void 0) {
          options.displayOldPrice = true;
        }
      }
      return this.renderOffers(offers, options, version);
    } catch (error) {
      this.innerHTML = "";
      throw error;
    }
  }
  // TODO: can be extended to accept array of offers and compute subtotal price
  /**
   * Renders price offer as HTML of this component
   * using consonant price template functions
   * @param {Offer[]} offers
   * @param {Record<string, any>} options
   * @param {number} version
   */
  renderOffers(offers, options, version = void 0) {
    if (!this.isConnected) return;
    const service = getService();
    if (!service) return false;
    version ?? (version = this.masElement.togglePending());
    if (offers.length) {
      if (this.masElement.toggleResolved(version, offers, options)) {
        this.innerHTML = service.buildPriceHTML(offers, this.options);
        const parentEl = this.closest("p, h3, div");
        if (!parentEl || !parentEl.querySelector(
          'span[data-template="strikethrough"]'
        ) || parentEl.querySelector(".alt-aria-label"))
          return true;
        const inlinePrices = parentEl?.querySelectorAll(
          'span[is="inline-price"]'
        );
        if (inlinePrices.length > 1 && inlinePrices.length === parentEl.querySelectorAll(
          'span[data-template="strikethrough"]'
        ).length * 2) {
          inlinePrices.forEach((price2) => {
            if (price2.dataset.template !== "strikethrough" && price2.options && !price2.options.alternativePrice && !price2.isFailed) {
              price2.options.alternativePrice = true;
              price2.innerHTML = service.buildPriceHTML(
                offers,
                price2.options
              );
            }
          });
        }
        return true;
      }
    } else {
      const error = new Error(
        `Not provided: ${this.options?.wcsOsi ?? "-"}`
      );
      if (this.masElement.toggleFailed(version, error, this.options)) {
        this.innerHTML = "";
        return true;
      }
    }
    return false;
  }
};
__publicField(_InlinePrice, "is", "inline-price");
__publicField(_InlinePrice, "tag", "span");
var InlinePrice = _InlinePrice;
if (!window.customElements.get(InlinePrice.is)) {
  window.customElements.define(InlinePrice.is, InlinePrice, {
    extends: InlinePrice.tag
  });
}

// src/price.js
function Price({ literals, providers, settings }) {
  function collectPriceOptions(overrides, placeholder = null) {
    let options = {
      country: settings.country,
      language: settings.language,
      locale: settings.locale,
      literals: { ...literals.price }
    };
    if (placeholder && providers?.price) {
      for (const provider of providers.price) {
        provider(placeholder, options);
      }
    }
    const {
      displayOldPrice,
      displayPerUnit,
      displayRecurrence,
      displayTax,
      displayPlanType,
      forceTaxExclusive,
      perpetual,
      displayAnnual,
      promotionCode,
      quantity,
      alternativePrice,
      wcsOsi,
      ...rest
    } = Object.assign(options, placeholder?.dataset ?? {}, overrides ?? {});
    options = omitProperties(
      Object.assign({
        ...options,
        ...rest,
        displayOldPrice: toBoolean(displayOldPrice),
        displayPerUnit: toBoolean(displayPerUnit),
        displayRecurrence: toBoolean(displayRecurrence),
        displayTax: toBoolean(displayTax),
        displayPlanType: toBoolean(displayPlanType),
        forceTaxExclusive: toBoolean(forceTaxExclusive),
        perpetual: toBoolean(perpetual),
        displayAnnual: toBoolean(displayAnnual),
        promotionCode: computePromoStatus(promotionCode).effectivePromoCode,
        quantity: toQuantity(quantity, Defaults.quantity),
        alternativePrice: toBoolean(alternativePrice),
        wcsOsi: toOfferSelectorIds(wcsOsi)
      })
    );
    return options;
  }
  function buildPriceHTML(offers, options) {
    if (!Array.isArray(offers) || !offers.length || !options) {
      return "";
    }
    const { template } = options;
    let method;
    switch (template) {
      // TODO: use price template name constants, export them from `consonant-templates`
      case "discount":
        method = discount;
        break;
      case "strikethrough":
        method = priceStrikethrough;
        break;
      case "annual":
        method = priceAnnual;
        break;
      case "legal":
        method = legal;
        break;
      default:
        if (options.template === "optical" && options.alternativePrice) {
          method = priceOpticalAlternative;
        } else if (options.template === "optical") {
          method = priceOptical;
        } else if (options.displayAnnual && offers[0].planType === "ABM") {
          method = options.promotionCode ? pricePromoWithAnnual : priceWithAnnual;
        } else if (options.alternativePrice) {
          method = priceAlternative;
        } else {
          method = options.promotionCode ? pricePromo : price;
        }
    }
    let [offer] = offers;
    offer = { ...offer, ...offer.priceDetails };
    return method({ ...settings, ...options }, offer);
  }
  const createInlinePrice = InlinePrice.createInlinePrice;
  return {
    InlinePrice,
    buildPriceHTML,
    collectPriceOptions,
    createInlinePrice
  };
}

// src/settings.js
function getLocaleSettings({
  locale = void 0,
  country = void 0,
  language = void 0
} = {}) {
  language ?? (language = locale?.split("_")?.[0] || Defaults.language);
  country ?? (country = locale?.split("_")?.[1] || Defaults.country);
  locale ?? (locale = SUPPORTED_LANGUAGE_COUNTRY.includes(`${language}_${country}`) ? `${language}_${country}` : `${Defaults.language}_${Defaults.country}`);
  return { locale, country, language };
}
function getSettings(config2 = {}, service) {
  const ffDefaults = service.featureFlags[FF_DEFAULTS];
  const { commerce = {} } = config2;
  let env = Env.PRODUCTION;
  let wcsURL = WCS_PROD_URL;
  const checkoutClientId = getParameter("checkoutClientId", commerce) ?? Defaults.checkoutClientId;
  const checkoutWorkflowStep = toEnumeration(
    getParameter("checkoutWorkflowStep", commerce),
    CheckoutWorkflowStep,
    Defaults.checkoutWorkflowStep
  );
  const displayOldPrice = Defaults.displayOldPrice;
  const displayPerUnit = Defaults.displayPerUnit;
  const displayRecurrence = toBoolean(
    getParameter("displayRecurrence", commerce),
    Defaults.displayRecurrence
  );
  const displayTax = toBoolean(
    getParameter("displayTax", commerce),
    Defaults.displayTax
  );
  const displayPlanType = toBoolean(
    getParameter("displayPlanType", commerce),
    Defaults.displayPlanType
  );
  const entitlement = toBoolean(
    getParameter("entitlement", commerce),
    Defaults.entitlement
  );
  const modal = toBoolean(getParameter("modal", commerce), Defaults.modal);
  const forceTaxExclusive = toBoolean(
    getParameter("forceTaxExclusive", commerce),
    Defaults.forceTaxExclusive
  );
  const promotionCode = getParameter("promotionCode", commerce) ?? Defaults.promotionCode;
  const quantity = toQuantity(getParameter("quantity", commerce));
  const wcsApiKey = getParameter("wcsApiKey", commerce) ?? Defaults.wcsApiKey;
  let isStage = commerce?.env === "stage";
  let landscape = Landscape.PUBLISHED;
  const allowOverride = ["true", ""].includes(commerce.allowOverride);
  if (allowOverride) {
    isStage = (getParameter(PARAM_ENV, commerce, {
      metadata: false
    })?.toLowerCase() ?? commerce?.env) === "stage";
    landscape = toEnumeration(
      getParameter(PARAM_LANDSCAPE, commerce),
      Landscape,
      landscape
    );
  }
  if (isStage) {
    env = Env.STAGE;
    wcsURL = WCS_STAGE_URL;
  }
  const previewParam = getParameter(PARAM_MAS_PREVIEW) ?? config2.preview;
  const preview = typeof previewParam != "undefined" && previewParam !== "off" && previewParam !== "false";
  let previewSettings = {};
  if (preview) previewSettings = { preview };
  const masIOUrl = getParameter("mas-io-url") ?? config2.masIOUrl ?? `https://www${env === Env.STAGE ? ".stage" : ""}.adobe.com/mas/io`;
  const preselectPlan = getParameter("preselect-plan") ?? void 0;
  return {
    ...getLocaleSettings(config2),
    ...previewSettings,
    displayOldPrice,
    checkoutClientId,
    checkoutWorkflowStep,
    displayPerUnit,
    displayRecurrence,
    displayTax,
    displayPlanType,
    entitlement,
    extraOptions: Defaults.extraOptions,
    modal,
    env,
    forceTaxExclusive,
    promotionCode,
    quantity,
    alternativePrice: Defaults.alternativePrice,
    wcsApiKey,
    wcsURL,
    landscape,
    masIOUrl,
    ...preselectPlan && { preselectPlan }
    // only add if defined
  };
}

// src/utils/mas-fetch.js
async function masFetch(resource, options = {}, retries = 2, baseDelay = 100) {
  let lastError;
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const response = await fetch(resource, options);
      response.retryCount = attempt;
      return response;
    } catch (error) {
      lastError = error;
      lastError.retryCount = attempt;
      if (attempt > retries) break;
      await new Promise(
        (resolve) => setTimeout(resolve, baseDelay * (attempt + 1))
      );
    }
  }
  throw lastError;
}

// src/utils.js
var MAS_COMMERCE_SERVICE2 = "mas-commerce-service";
function debounce(func, delay) {
  let debounceTimer;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => func.apply(context, args), delay);
  };
}
function createTag(tag, attributes = {}, content = null, is = null) {
  const element = is ? document.createElement(tag, { is }) : document.createElement(tag);
  if (content instanceof HTMLElement) {
    element.appendChild(content);
  } else {
    element.innerHTML = content;
  }
  for (const [key, value] of Object.entries(attributes)) {
    element.setAttribute(key, value);
  }
  return element;
}
function printMeasure(measure) {
  return `startTime:${measure.startTime.toFixed(2)}|duration:${measure.duration.toFixed(2)}`;
}
function isMobileOrTablet() {
  return window.matchMedia("(max-width: 1024px)").matches;
}
function getService2() {
  return document.getElementsByTagName(MAS_COMMERCE_SERVICE2)?.[0];
}
function getOuterHeight(element) {
  const style = window.getComputedStyle(element);
  return element.offsetHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
}

// src/wcs.js
var NAMESPACE2 = "wcs";
function Wcs({ settings }) {
  const log2 = Log.module(NAMESPACE2);
  const { env, wcsApiKey: apiKey } = settings;
  const cache2 = /* @__PURE__ */ new Map();
  const queue = /* @__PURE__ */ new Map();
  let timer;
  let staleCache = /* @__PURE__ */ new Map();
  async function resolveWcsOffers(options, promises, reject = true) {
    const service = getService();
    let message = ERROR_MESSAGE_OFFER_NOT_FOUND;
    log2.debug("Fetching:", options);
    let url = "";
    let response;
    if (options.offerSelectorIds.length > 1)
      throw new Error("Multiple OSIs are not supported anymore");
    const unresolvedPromises = new Map(promises);
    const [osi] = options.offerSelectorIds;
    const uniqueId = Date.now() + Math.random().toString(36).substring(2, 7);
    const startMark = `${NAMESPACE2}:${osi}:${uniqueId}${MARK_START_SUFFIX}`;
    const measureName = `${NAMESPACE2}:${osi}:${uniqueId}${MARK_DURATION_SUFFIX}`;
    let measure;
    try {
      performance.mark(startMark);
      url = new URL(settings.wcsURL);
      url.searchParams.set("offer_selector_ids", osi);
      url.searchParams.set("country", options.country);
      url.searchParams.set("locale", options.locale);
      url.searchParams.set(
        "landscape",
        env === Env.STAGE ? "ALL" : settings.landscape
      );
      url.searchParams.set("api_key", apiKey);
      if (options.language) {
        url.searchParams.set("language", options.language);
      }
      if (options.promotionCode) {
        url.searchParams.set("promotion_code", options.promotionCode);
      }
      if (options.currency) {
        url.searchParams.set("currency", options.currency);
      }
      response = await masFetch(url.toString(), {
        credentials: "omit"
      });
      if (response.ok) {
        let offers = [];
        try {
          const data = await response.json();
          log2.debug("Fetched:", options, data);
          offers = data.resolvedOffers ?? [];
        } catch (e4) {
          log2.error(`Error parsing JSON: ${e4.message}`, {
            ...e4.context,
            ...service?.duration
          });
        }
        offers = offers.map(applyPlanType);
        promises.forEach(({ resolve }, offerSelectorId) => {
          const resolved = offers.filter(
            ({ offerSelectorIds }) => offerSelectorIds.includes(offerSelectorId)
          ).flat();
          if (resolved.length) {
            unresolvedPromises.delete(offerSelectorId);
            promises.delete(offerSelectorId);
            resolve(resolved);
          }
        });
      } else {
        message = ERROR_MESSAGE_BAD_REQUEST;
      }
    } catch (e4) {
      message = `Network error: ${e4.message}`;
    } finally {
      measure = performance.measure(measureName, startMark);
      performance.clearMarks(startMark);
      performance.clearMeasures(measureName);
    }
    if (reject && promises.size) {
      log2.debug("Missing:", { offerSelectorIds: [...promises.keys()] });
      const headers = getLogHeaders(response);
      promises.forEach((promise) => {
        promise.reject(
          new MasError(message, {
            ...options,
            ...headers,
            response,
            measure: printMeasure(measure),
            ...service?.duration
          })
        );
      });
    }
  }
  function flushQueue() {
    clearTimeout(timer);
    const pending = [...queue.values()];
    queue.clear();
    pending.forEach(
      ({ options, promises }) => resolveWcsOffers(options, promises)
    );
  }
  function prefillWcsCache(preloadedCache) {
    if (!preloadedCache || typeof preloadedCache !== "object") {
      throw new TypeError("Cache must be a Map or similar object");
    }
    const envKey = env === Env.STAGE ? "stage" : "prod";
    const envCache = preloadedCache[envKey];
    if (!envCache || typeof envCache !== "object") {
      log2.warn(`No cache found for environment: ${env}`);
      return;
    }
    for (const [key, value] of Object.entries(envCache)) {
      cache2.set(key, Promise.resolve(value.map(applyPlanType)));
    }
    log2.debug(`Prefilled WCS cache with ${envCache.size} entries`);
  }
  function flushWcsCacheInternal() {
    const size = cache2.size;
    staleCache = new Map(cache2);
    cache2.clear();
    log2.debug(`Moved ${size} cache entries to stale cache`);
  }
  function validateLanguageAndLocale(country, language, perpetual) {
    const validLanguage = SUPPORTED_LANGUAGES.includes(language) ? language : Defaults.language;
    const validCountry = SUPPORTED_COUNTRIES.includes(country) ? country : Defaults.country;
    return {
      validCountry,
      validLanguage: country !== "GB" && !perpetual ? "MULT" : validLanguage,
      locale: SUPPORTED_LANGUAGE_COUNTRY.includes(
        `${validLanguage}_${validCountry}`
      ) ? `${validLanguage}_${validCountry}` : `${Defaults.language}_${Defaults.country}`
    };
  }
  function resolveOfferSelectors({
    country,
    language,
    perpetual = false,
    promotionCode = "",
    wcsOsi = []
  }) {
    const { validCountry, validLanguage, locale } = validateLanguageAndLocale(country, language, perpetual);
    const groupKey = [validCountry, validLanguage, promotionCode].filter((val) => val).join("-").toLowerCase();
    return wcsOsi.map((osi) => {
      const cacheKey = `${osi}-${groupKey}`;
      if (cache2.has(cacheKey)) {
        return cache2.get(cacheKey);
      }
      const promiseWithFallback = new Promise((resolve, reject) => {
        let group = queue.get(groupKey);
        if (!group) {
          const options = {
            country: validCountry,
            locale,
            ...perpetual ? {} : { language: validLanguage },
            offerSelectorIds: []
          };
          const promises = /* @__PURE__ */ new Map();
          group = { options, promises };
          queue.set(groupKey, group);
        }
        if (promotionCode) {
          group.options.promotionCode = promotionCode;
        }
        group.options.offerSelectorIds.push(osi);
        group.promises.set(osi, {
          resolve,
          reject
        });
        flushQueue();
      }).catch((error) => {
        if (staleCache.has(cacheKey)) {
          return staleCache.get(cacheKey);
        }
        throw error;
      });
      cache2.set(cacheKey, promiseWithFallback);
      return promiseWithFallback;
    });
  }
  return {
    Commitment,
    PlanType,
    Term,
    applyPlanType,
    resolveOfferSelectors,
    flushWcsCacheInternal,
    prefillWcsCache,
    validateLanguageAndLocale
  };
}

// src/mas-commerce-service.js
var TAG_NAME_SERVICE2 = "mas-commerce-service";
var MARK_START = "mas-commerce-service:start";
var MEASURE_READY = "mas-commerce-service:ready";
var _measure, _featureFlags, _MasCommerceService_instances, config_get, getFeatureFlag_fn;
var MasCommerceService = class extends HTMLElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _MasCommerceService_instances);
    __privateAdd(this, _measure);
    __privateAdd(this, _featureFlags);
    __publicField(this, "lastLoggingTime", 0);
  }
  async registerCheckoutAction(action) {
    if (typeof action != "function") return;
    this.buildCheckoutAction = async (offers, options, el) => {
      const checkoutAction = await action?.(
        offers,
        options,
        this.imsSignedInPromise,
        el
      );
      if (checkoutAction) {
        return checkoutAction;
      }
      return null;
    };
  }
  get featureFlags() {
    if (!__privateGet(this, _featureFlags)) {
      __privateSet(this, _featureFlags, {
        [FF_DEFAULTS]: __privateMethod(this, _MasCommerceService_instances, getFeatureFlag_fn).call(this, FF_DEFAULTS)
      });
    }
    return __privateGet(this, _featureFlags);
  }
  activate() {
    const config2 = __privateGet(this, _MasCommerceService_instances, config_get);
    const settings = getSettings(config2, this);
    updateConfig(config2.lana);
    const log2 = Log.init(config2.hostEnv).module("service");
    log2.debug("Activating:", config2);
    const price2 = getPriceLiterals(settings);
    const literals = { price: price2 };
    const providers = {
      checkout: /* @__PURE__ */ new Set(),
      price: /* @__PURE__ */ new Set()
    };
    const startup = { literals, providers, settings };
    Object.defineProperties(
      this,
      Object.getOwnPropertyDescriptors({
        // Activate modules and expose their API as combined flat object
        ...Checkout(startup),
        ...Ims(startup),
        ...Price(startup),
        ...Wcs(startup),
        ...constants_exports,
        // Defined serviceweb  component API
        Log,
        get defaults() {
          return Defaults;
        },
        get log() {
          return Log;
        },
        /* c8 ignore next 11 */
        get providers() {
          return {
            checkout(provider) {
              providers.checkout.add(provider);
              return () => providers.checkout.delete(provider);
            },
            price(provider) {
              providers.price.add(provider);
              return () => providers.price.delete(provider);
            },
            has: (providerFunction) => providers.price.has(providerFunction) || providers.checkout.has(providerFunction)
          };
        },
        get settings() {
          return settings;
        }
      })
    );
    log2.debug("Activated:", { literals, settings });
    const event = new CustomEvent(EVENT_TYPE_READY, {
      bubbles: true,
      cancelable: false,
      detail: this
    });
    performance.mark(MEASURE_READY);
    __privateSet(this, _measure, performance.measure(MEASURE_READY, MARK_START));
    this.dispatchEvent(event);
    setTimeout(() => {
      this.logFailedRequests();
    }, 1e4);
  }
  connectedCallback() {
    performance.mark(MARK_START);
    this.activate();
  }
  flushWcsCache() {
    this.flushWcsCacheInternal();
    this.log.debug("Flushed WCS cache");
  }
  refreshOffers() {
    this.flushWcsCacheInternal();
    document.querySelectorAll(SELECTOR_MAS_ELEMENT).forEach((el) => el.requestUpdate(true));
    this.log.debug("Refreshed WCS offers");
    this.logFailedRequests();
  }
  refreshFragments() {
    this.flushWcsCacheInternal();
    customElements.get("aem-fragment")?.cache.clear();
    document.querySelectorAll("aem-fragment").forEach((el) => el.refresh(false));
    this.log.debug("Refreshed AEM fragments");
    this.logFailedRequests();
  }
  get duration() {
    return {
      "mas-commerce-service:measure": printMeasure(__privateGet(this, _measure))
    };
  }
  /**
   * Logs failed network requests related to AEM fragments and WCS commerce artifacts.
   * Identifies failed resources by checking for zero transfer size, zero duration,
   * response status less than 200, or response status greater than or equal to 400.
   * Only logs errors if any of the failed resources are fragment or commerce artifact requests.
   */
  /* c8 ignore next 21 */
  logFailedRequests() {
    const failedResources = [...performance.getEntriesByType("resource")].filter(({ startTime }) => startTime > this.lastLoggingTime).filter(
      ({ transferSize, duration, responseStatus }) => transferSize === 0 && duration === 0 && responseStatus < 200 || responseStatus >= 400
    );
    const uniqueFailedResources = Array.from(
      new Map(
        failedResources.map((resource) => [resource.name, resource])
      ).values()
    );
    if (uniqueFailedResources.some(
      ({ name }) => /(\/fragment\?|web_commerce_artifact)/.test(name)
    )) {
      const failedUrls = uniqueFailedResources.map(({ name }) => name);
      this.log.error("Failed requests:", {
        failedUrls,
        ...this.duration
      });
    }
    this.lastLoggingTime = performance.now().toFixed(3);
  }
};
_measure = new WeakMap();
_featureFlags = new WeakMap();
_MasCommerceService_instances = new WeakSet();
config_get = function() {
  const env = this.getAttribute("env") ?? "prod";
  const config2 = {
    commerce: { env },
    hostEnv: { name: env },
    lana: {
      tags: this.getAttribute("lana-tags"),
      sampleRate: parseInt(
        this.getAttribute("lana-sample-rate") ?? 1,
        10
      ),
      isProdDomain: env === "prod"
    },
    masIOUrl: this.getAttribute("mas-io-url")
  };
  ["locale", "country", "language", "preview"].forEach((attribute) => {
    const value = this.getAttribute(attribute);
    if (value) {
      config2[attribute] = value;
    }
  });
  [
    "checkout-workflow-step",
    "force-tax-exclusive",
    "checkout-client-id",
    "allow-override",
    "wcs-api-key"
  ].forEach((attribute) => {
    const value = this.getAttribute(attribute);
    if (value != null) {
      const camelCaseAttribute = attribute.replace(
        /-([a-z])/g,
        (g2) => g2[1].toUpperCase()
      );
      config2.commerce[camelCaseAttribute] = value;
    }
  });
  return config2;
};
getFeatureFlag_fn = function(ff) {
  return ["on", "true", true].includes(
    this.getAttribute(`data-${ff}`) || getParameter(ff)
  );
};
if (!window.customElements.get(TAG_NAME_SERVICE2)) {
  window.customElements.define(TAG_NAME_SERVICE2, MasCommerceService);
}

// src/checkout-button.js
var _CheckoutButton = class _CheckoutButton extends CheckoutMixin(HTMLButtonElement) {
  static createCheckoutButton(options = {}, innerHTML = "") {
    return createCheckoutElement(_CheckoutButton, options, innerHTML);
  }
  setCheckoutUrl(value) {
    this.setAttribute("data-href", value);
  }
  get href() {
    return this.getAttribute("data-href");
  }
  get isCheckoutButton() {
    return true;
  }
  clickHandler(e4) {
    if (this.checkoutActionHandler) {
      this.checkoutActionHandler?.(e4);
      return;
    }
    if (this.href) {
      window.location.href = this.href;
    }
  }
};
__publicField(_CheckoutButton, "is", "checkout-button");
__publicField(_CheckoutButton, "tag", "button");
var CheckoutButton = _CheckoutButton;
if (!window.customElements.get(CheckoutButton.is)) {
  window.customElements.define(CheckoutButton.is, CheckoutButton, {
    extends: CheckoutButton.tag
  });
}

// src/upt-link.js
function getPromoTermsUrl(env) {
  const host = env === "PRODUCTION" ? "www.adobe.com" : "www.stage.adobe.com";
  return `https://${host}/offers/promo-terms.html`;
}
var _service2;
var _UptLink = class _UptLink extends HTMLAnchorElement {
  constructor() {
    super();
    __publicField(this, "masElement", new MasElement(this));
    __privateAdd(this, _service2);
    this.setAttribute("is", _UptLink.is);
  }
  get isUptLink() {
    return true;
  }
  /**
   * @param {string} osi
   * @param {string} promotionCode
   */
  initializeWcsData(osi, promotionCode) {
    this.setAttribute("data-wcs-osi", osi);
    if (promotionCode)
      this.setAttribute("data-promotion-code", promotionCode);
  }
  attributeChangedCallback(name, oldValue, value) {
    this.masElement.attributeChangedCallback(name, oldValue, value);
  }
  connectedCallback() {
    this.masElement.connectedCallback();
    __privateSet(this, _service2, getService2());
    if (__privateGet(this, _service2)) {
      this.log = __privateGet(this, _service2).log.module("upt-link");
    }
  }
  disconnectedCallback() {
    this.masElement.disconnectedCallback();
    __privateSet(this, _service2, void 0);
  }
  requestUpdate(force = false) {
    this.masElement.requestUpdate(force);
  }
  onceSettled() {
    return this.masElement.onceSettled();
  }
  async render() {
    const service = getService2();
    if (!service) return false;
    if (!this.dataset.imsCountry) {
      service.imsCountryPromise.then((countryCode) => {
        if (countryCode) this.dataset.imsCountry = countryCode;
      });
    }
    const options = service.collectCheckoutOptions({}, this);
    if (!options.wcsOsi) {
      this.log.error(`Missing 'data-wcs-osi' attribute on upt-link.`);
      return false;
    }
    const version = this.masElement.togglePending(options);
    const promises = service.resolveOfferSelectors(options);
    try {
      const [[offer]] = await Promise.all(promises);
      const { country, language, env } = options;
      let params = `locale=${language}_${country}&country=${country}&offer_id=${offer.offerId}`;
      const promotionCode = this.getAttribute("data-promotion-code");
      if (promotionCode)
        params += `&promotion_code=${encodeURIComponent(promotionCode)}`;
      this.href = `${getPromoTermsUrl(env)}?${params}`;
      this.masElement.toggleResolved(version, offer, options);
    } catch (error) {
      const masError = new Error(
        `Could not resolve offer selectors for id: ${options.wcsOsi}.`,
        error.message
      );
      this.masElement.toggleFailed(version, masError, options);
      return false;
    }
  }
  /**
   * @param {HTMLElement} element
   */
  static createFrom(element) {
    const uptLink = new _UptLink();
    for (const attribute of element.attributes) {
      if (attribute.name === "is") continue;
      if (attribute.name === "class" && attribute.value.includes("upt-link"))
        uptLink.setAttribute(
          "class",
          attribute.value.replace("upt-link", "").trim()
        );
      else uptLink.setAttribute(attribute.name, attribute.value);
    }
    uptLink.innerHTML = element.innerHTML;
    uptLink.setAttribute("tabindex", 0);
    return uptLink;
  }
};
_service2 = new WeakMap();
__publicField(_UptLink, "is", "upt-link");
__publicField(_UptLink, "tag", "a");
__publicField(_UptLink, "observedAttributes", [
  "data-wcs-osi",
  "data-promotion-code",
  "data-ims-country"
]);
var UptLink = _UptLink;
if (!window.customElements.get(UptLink.is)) {
  window.customElements.define(UptLink.is, UptLink, {
    extends: UptLink.tag
  });
}

// src/merch-card.js
init_lit();

// src/merch-card.css.js
init_lit();

// src/media.js
var MOBILE_LANDSCAPE = "(max-width: 767px)";
var TABLET_DOWN = "(max-width: 1199px)";
var TABLET_UP = "(min-width: 768px)";
var DESKTOP_UP = "(min-width: 1200px)";
var LARGE_DESKTOP = "(min-width: 1600px)";
function matchMobile() {
  return window.matchMedia(MOBILE_LANDSCAPE);
}
function matchDesktop() {
  return window.matchMedia(DESKTOP_UP);
}
function isMobile() {
  return matchMobile().matches;
}
function isDesktop() {
  return matchDesktop().matches;
}

// src/merch-card.css.js
var styles = i`
    :host {
        --consonant-merch-card-background-color: #fff;
        --consonant-merch-card-border: 1px solid
            var(--consonant-merch-card-border-color);
        -webkit-font-smoothing: antialiased;
        background-color: var(--consonant-merch-card-background-color);
        border-radius: var(--consonant-merch-spacing-xs);
        border: var(--consonant-merch-card-border);
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        font-family: var(--merch-body-font-family, 'Adobe Clean');
        grid-template-columns: repeat(auto-fit, minmax(300px, max-content));
        position: relative;
        text-align: start;
    }

    :host(.placeholder) {
        visibility: hidden;
    }

    :host([aria-selected]) {
        outline: none;
        box-shadow: inset 0 0 0 2px var(--color-accent);
    }

    .invisible {
        visibility: hidden;
    }

    :host(:hover) .invisible,
    :host(:active) .invisible,
    :host(:focus) .invisible {
        visibility: visible;
        background-image: var(--ellipsis-icon);
        cursor: pointer;
    }

    .action-menu.always-visible {
        visibility: visible;
        background-image: var(--ellipsis-icon);
        cursor: pointer;
    }

    .top-section {
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        gap: 16px;
    }

    .top-section.badge {
        min-height: 32px;
    }

    .body {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        height: 100%;
        gap: var(--consonant-merch-spacing-xxs);
        padding: var(--consonant-merch-spacing-xs);
    }

    footer {
        display: flex;
        justify-content: flex-end;
        box-sizing: border-box;
        align-items: flex-end;
        width: 100%;
        flex-flow: wrap;
        gap: var(--consonant-merch-spacing-xs);

        padding: var(--consonant-merch-spacing-xs);
    }

    footer.wide-footer {
        align-items: center;
    }

    footer.wide-footer .secure-transaction-label {
        flex: 0 1 auto;
    }

    footer.footer-column {
        flex-direction: column;
    }

    footer.footer-column .secure-transaction-label {
        align-self: flex-start;
    }

    hr {
        background-color: var(--merch-color-grey-200);
        border: none;
        height: 1px;
        width: auto;
        margin-top: 0;
        margin-bottom: 0;
        margin-left: var(--consonant-merch-spacing-xs);
        margin-right: var(--consonant-merch-spacing-xs);
    }

    div[class$='-badge'] {
        position: absolute;
        top: 16px;
        right: 0;
        font-size: var(--type-heading-xxs-size);
        font-weight: 500;
        max-width: 180px;
        line-height: 16px;
        text-align: center;
        padding: 8px 11px;
        border-radius: 5px 0 0 5px;
    }

    div[class$='-badge']:dir(rtl) {
        left: 0;
        right: initial;
        padding: 8px 11px;
        border-radius: 0 5px 5px 0;
    }

    .detail-bg-container {
        right: 0;
        padding: var(--consonant-merch-spacing-xs);
        border-radius: 5px;
        font-size: var(--consonant-merch-card-body-font-size);
        margin: var(--consonant-merch-spacing-xs);
    }

    .action-menu {
        display: flex;
        width: 32px;
        height: 32px;
        position: absolute;
        top: 16px;
        right: 16px;
        background-color: #f6f6f6;
        background-repeat: no-repeat;
        background-position: center;
        background-size: 16px 16px;
        font-size: 0;
    }
    .hidden {
        visibility: hidden;
    }

    #stock-checkbox,
    .secure-transaction-label {
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        line-height: 1.3;
        color: var(--merch-color-grey-600);
    }

    #stock-checkbox {
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        gap: 10px; /*same as spectrum */
    }

    #stock-checkbox > input {
        display: none;
    }

    #stock-checkbox > span {
        display: inline-block;
        box-sizing: border-box;
        border: 2px solid rgb(117, 117, 117);
        border-radius: 2px;
        width: 14px;
        height: 14px;
    }

    #stock-checkbox > input:checked + span {
        background: var(--checkmark-icon) no-repeat var(--color-accent);
        border-color: var(--color-accent);
    }

    .secure-transaction-label {
        white-space: nowrap;
        display: inline-flex;
        gap: var(--consonant-merch-spacing-xxs);
        align-items: center;
        flex: 1;
        line-height: normal;
        align-self: center;
    }

    .secure-transaction-label::before {
        display: inline-block;
        content: '';
        width: 12px;
        height: 15px;
        background: var(--secure-icon) no-repeat;
        background-position: center;
        background-size: contain;
    }

    .checkbox-container {
        display: flex;
        align-items: center;
        gap: var(--consonant-merch-spacing-xxs);
    }

    .checkbox-container input[type='checkbox']:checked + .checkmark {
        background-color: var(--color-accent);
        background-image: var(--checkmark-icon);
        border-color: var(--color-accent);
    }

    .checkbox-container input[type='checkbox'] {
        display: none;
    }

    .checkbox-container .checkmark {
        position: relative;
        display: inline-block;
        width: 12px;
        height: 12px;
        border: 2px solid #757575;
        background: #fff;
        border-radius: 2px;
        cursor: pointer;
        margin-top: 2px;
    }

    slot[name='icons'] {
        display: flex;
        gap: 8px;
    }

    ::slotted([slot='price']) {
        color: var(--consonant-merch-card-price-color);
    }
`;
var sizeStyles = () => {
  const styles5 = [
    i`
            /* Tablet */
            @media screen and ${r(TABLET_UP)} {
                :host([size='wide']),
                :host([size='super-wide']) {
                    width: 100%;
                    grid-column: 1 / -1;
                }
            }

            /* Laptop */
            @media screen and ${r(DESKTOP_UP)} {
                :host([size='wide']) {
                    grid-column: span 2;
                }
            }
        `
  ];
  return styles5;
};

// src/merch-icon.js
init_lit();
function hasSpectrumTooltip2() {
  return customElements.get("sp-tooltip") !== void 0 || document.querySelector("sp-theme") !== null;
}
var MerchIcon = class extends s4 {
  constructor() {
    super();
    this.size = "m";
    this.alt = "";
    this.loading = "lazy";
  }
  connectedCallback() {
    super.connectedCallback();
    setTimeout(() => this.handleTooltips(), 0);
  }
  handleTooltips() {
    if (hasSpectrumTooltip2()) return;
    const tooltipElements = this.querySelectorAll(
      "sp-tooltip, overlay-trigger"
    );
    tooltipElements.forEach((element) => {
      let content = "";
      let placement = "top";
      if (element.tagName === "SP-TOOLTIP") {
        content = element.textContent;
        placement = element.getAttribute("placement") || "top";
      } else if (element.tagName === "OVERLAY-TRIGGER") {
        const tooltip = element.querySelector("sp-tooltip");
        if (tooltip) {
          content = tooltip.textContent;
          placement = tooltip.getAttribute("placement") || element.getAttribute("placement") || "top";
        }
      }
      if (content) {
        const masMnemonic = document.createElement("mas-mnemonic");
        masMnemonic.setAttribute("content", content);
        masMnemonic.setAttribute("placement", placement);
        const img = this.querySelector("img");
        const link = this.querySelector("a");
        if (link && link.contains(img)) {
          masMnemonic.appendChild(link);
        } else if (img) {
          masMnemonic.appendChild(img);
        }
        this.innerHTML = "";
        this.appendChild(masMnemonic);
        Promise.resolve().then(() => init_mas_mnemonic());
      }
      element.remove();
    });
  }
  render() {
    const { href } = this;
    return href ? x`<a href="${href}">
                  <img
                      src="${this.src}"
                      alt="${this.alt}"
                      loading="${this.loading}"
                  />
              </a>` : x` <img
                  src="${this.src}"
                  alt="${this.alt}"
                  loading="${this.loading}"
              />`;
  }
};
__publicField(MerchIcon, "properties", {
  size: { type: String, attribute: true },
  src: { type: String, attribute: true },
  alt: { type: String, attribute: true },
  href: { type: String, attribute: true },
  loading: { type: String, attribute: true }
});
__publicField(MerchIcon, "styles", i`
        :host {
            --img-width: 32px;
            --img-height: 32px;
            display: block;
            width: var(--mod-img-width, var(--img-width));
            height: var(--mod-img-height, var(--img-height));
        }

        :host([size='xxs']) {
            --img-width: 13px;
            --img-height: 13px;
        }

        :host([size='xs']) {
            --img-width: 20px;
            --img-height: 20px;
        }

        :host([size='s']) {
            --img-width: 24px;
            --img-height: 24px;
        }

        :host([size='m']) {
            --img-width: 30px;
            --img-height: 30px;
        }

        :host([size='l']) {
            --img-width: 40px;
            --img-height: 40px;
        }

        img {
            width: var(--mod-img-width, var(--img-width));
            height: var(--mod-img-height, var(--img-height));
        }
    `);
customElements.define("merch-icon", MerchIcon);

// src/merch-gradient.js
var _angle, _borderRadius, _colors, _positions, _updateParentBackground;
var MerchGradient = class extends HTMLElement {
  constructor() {
    super();
    __privateAdd(this, _angle, "");
    __privateAdd(this, _borderRadius);
    __privateAdd(this, _colors, []);
    __privateAdd(this, _positions, []);
    __privateAdd(this, _updateParentBackground);
    __privateSet(this, _updateParentBackground, debounce(() => {
      if (!this.isConnected) return;
      this.parentElement.style.background = this.value;
      if (__privateGet(this, _borderRadius)) {
        this.parentElement.style.borderRadius = __privateGet(this, _borderRadius);
      } else if (__privateGet(this, _borderRadius) === "") {
        this.parentElement.style.borderRadius = "";
      }
    }, 1));
  }
  static get observedAttributes() {
    return ["colors", "positions", "angle", "border-radius"];
  }
  get value() {
    const stops = __privateGet(this, _colors).map((color, index) => {
      const position = __privateGet(this, _positions)[index] || "";
      return `${color} ${position}`;
    }).join(", ");
    return `linear-gradient(${__privateGet(this, _angle)}, ${stops})`;
  }
  connectedCallback() {
    __privateGet(this, _updateParentBackground).call(this);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "border-radius") {
      __privateSet(this, _borderRadius, newValue?.trim());
    }
    if (name === "colors" && newValue) {
      __privateSet(this, _colors, newValue?.split(",").map((color) => color.trim()) ?? []);
    } else if (name === "positions" && newValue) {
      __privateSet(this, _positions, newValue?.split(",").map((position) => position.trim()) ?? []);
    } else if (name === "angle") {
      __privateSet(this, _angle, newValue?.trim() ?? "");
    }
    __privateGet(this, _updateParentBackground).call(this);
  }
};
_angle = new WeakMap();
_borderRadius = new WeakMap();
_colors = new WeakMap();
_positions = new WeakMap();
_updateParentBackground = new WeakMap();
customElements.define("merch-gradient", MerchGradient);

// src/merch-addon.js
init_lit();
var MerchAddon = class extends s4 {
  constructor() {
    super();
    this.planType = void 0;
    this.checked = false;
    this.updatePlanType = this.updatePlanType.bind(this);
    this.handleChange = this.handleChange.bind(this);
    this.handleCustomClick = this.handleCustomClick.bind(this);
  }
  getOsi(planType, offerType) {
    const offerTypeOptions = {
      TRIAL: ["TRIAL"],
      BASE: ["BASE", "PROMOTION", "TRIAL"],
      PROMOTION: ["PROMOTION", "BASE", "TRIAL"]
    };
    const priorityList = offerTypeOptions[offerType] || [offerType];
    const selector = priorityList.map(
      (type) => `p[data-plan-type="${planType}"] ${SELECTOR_MAS_INLINE_PRICE}[data-offer-type="${type}"]`
    ).join(", ");
    const el = this.querySelector(selector);
    return el?.dataset?.wcsOsi;
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener(EVENT_TYPE_RESOLVED, this.updatePlanType);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener(EVENT_TYPE_RESOLVED, this.updatePlanType);
  }
  updatePlanType(e4) {
    if (e4.target.tagName !== "SPAN") return;
    const price2 = e4.target;
    const offer = price2?.value?.[0];
    if (!offer) return;
    price2.setAttribute("data-offer-type", offer.offerType);
    price2.closest("p").setAttribute("data-plan-type", offer.planType);
  }
  handleChange(e4) {
    this.checked = e4.target.checked;
    this.dispatchEvent(
      new CustomEvent("change", {
        detail: { checked: this.checked },
        bubbles: true,
        composed: true
      })
    );
  }
  handleCustomClick() {
    const addonCheckbox = this.shadowRoot.querySelector("input");
    addonCheckbox.click();
  }
  handleKeyDown(e4) {
    if (e4.key === " ") {
      e4.preventDefault();
      this.handleCustomClick();
    }
  }
  render() {
    return x` <input
                type="checkbox"
                id="addon-checkbox"
                .checked=${this.checked}
                @change=${this.handleChange}
            />
            <span
                role="checkbox"
                aria-checked=${this.checked}
                tabindex="0"
                aria-labelledby="custom-checkbox-label"
                id="custom-checkbox"
                @click=${this.handleCustomClick}
                @keydown=${this.handleKeyDown}
            >
            </span>
            <label id="custom-checkbox-label" for="addon-checkbox">
                <slot></slot>
            </label>`;
  }
};
__publicField(MerchAddon, "properties", {
  planType: { type: String, attribute: "plan-type", reflect: true },
  checked: { type: Boolean, reflect: true },
  customCheckbox: {
    type: Boolean,
    attribute: "custom-checkbox",
    reflect: true
  }
});
__publicField(MerchAddon, "styles", i`
        :host {
            --merch-addon-gap: 9px;
            --merch-addon-align: start;
            --merch-addon-checkbox-size: unset;
            --merch-addon-checkbox-border: unset;
            --merch-addon-checkbox-radius: unset;
            --merch-addon-checkbox-checked-bg: unset;
            --merch-addon-checkbox-checked-color: unset;
            --merch-addon-label-size: unset;
            --merch-addon-label-color: unset;
            --merch-addon-label-line-height: unset;
            display: flex;
            gap: var(--merch-addon-gap);
            align-items: var(--merch-addon-align);
            cursor: pointer;
        }

        :host([custom-checkbox]) #addon-checkbox {
            display: none;
        }

        :host([custom-checkbox]) #custom-checkbox {
            display: block;
        }

        :host #custom-checkbox {
            display: none;
            width: var(--merch-addon-checkbox-size);
            height: var(--merch-addon-checkbox-size);
            border: var(--merch-addon-checkbox-border);
            border-radius: var(--merch-addon-checkbox-radius);
            box-sizing: border-box;
        }

        :host #addon-checkbox:checked + #custom-checkbox {
            background: var(--merch-addon-checkbox-checked-bg) no-repeat
                var(--merch-addon-checkbox-checked-color);
            border-color: var(--merch-addon-checkbox-checked-color);
        }

        ::slotted(p:not([data-plan-type])) {
            color: var(--merch-addon-label-color);
            font-size: var(--merch-addon-label-size);
            line-height: var(--merch-addon-label-line-height);
            font-style: normal;
            font-weight: 400;
            cursor: pointer;
        }

        ::slotted(p[data-plan-type]) {
            display: none;
        }

        :host([plan-type='PUF']) ::slotted(p[data-plan-type='PUF']) {
            display: block;
        }

        :host([plan-type='ABM']) ::slotted(p[data-plan-type='ABM']) {
            display: block;
        }

        :host([plan-type='M2M']) ::slotted(p[data-plan-type='M2M']) {
            display: block;
        }
    `);
customElements.define("merch-addon", MerchAddon);

// src/variants/variant-layout.js
init_lit();
var _container;
var _VariantLayout = class _VariantLayout {
  constructor(card) {
    __publicField(this, "card");
    __privateAdd(this, _container);
    this.card = card;
    this.insertVariantStyle();
  }
  getContainer() {
    __privateSet(this, _container, __privateGet(this, _container) ?? this.card.closest('[class*="-merch-cards"]') ?? this.card.parentElement);
    return __privateGet(this, _container);
  }
  insertVariantStyle() {
    if (!_VariantLayout.styleMap[this.card.variant]) {
      _VariantLayout.styleMap[this.card.variant] = true;
      const styles5 = document.createElement("style");
      styles5.innerHTML = this.getGlobalCSS();
      document.head.appendChild(styles5);
    }
  }
  updateCardElementMinHeight(el, name) {
    if (!el) return;
    const elMinHeightPropertyName = `--consonant-merch-card-${this.card.variant}-${name}-height`;
    const height = Math.max(
      0,
      parseInt(window.getComputedStyle(el).height) || 0
    );
    const maxMinHeight = parseInt(
      this.getContainer().style.getPropertyValue(
        elMinHeightPropertyName
      )
    ) || 0;
    if (height > maxMinHeight) {
      this.getContainer().style.setProperty(
        elMinHeightPropertyName,
        `${height}px`
      );
    }
  }
  get badge() {
    let additionalStyles;
    if (!this.card.badgeBackgroundColor || !this.card.badgeColor || !this.card.badgeText) {
      return;
    }
    if (this.evergreen) {
      additionalStyles = `border: 1px solid ${this.card.badgeBackgroundColor}; border-right: none;`;
    }
    return x`
            <div
                id="badge"
                class="${this.card.variant}-badge"
                style="background-color: ${this.card.badgeBackgroundColor};
                color: ${this.card.badgeColor};
                ${additionalStyles}"
            >
                ${this.card.badgeText}
            </div>
        `;
  }
  get cardImage() {
    return x` <div class="image">
            <slot name="bg-image"></slot>
            ${this.badge}
        </div>`;
  }
  /* c8 ignore next 3 */
  getGlobalCSS() {
    return "";
  }
  /* c8 ignore next 3 */
  get theme() {
    return document.querySelector("sp-theme");
  }
  get evergreen() {
    return this.card.classList.contains("intro-pricing");
  }
  get promoBottom() {
    return this.card.classList.contains("promo-bottom");
  }
  get headingSelector() {
    return '[slot="heading-xs"]';
  }
  get secureLabel() {
    return this.card.secureLabel ? x`<span class="secure-transaction-label"
                  >${this.card.secureLabel}</span
              >` : A;
  }
  get secureLabelFooter() {
    return x`<footer>
            ${this.secureLabel}<slot name="footer"></slot>
        </footer>`;
  }
  async adjustTitleWidth() {
    const cardWidth = this.card.getBoundingClientRect().width;
    const badgeWidth = this.card.badgeElement?.getBoundingClientRect().width || 0;
    if (cardWidth === 0 || badgeWidth === 0) return;
    this.card.style.setProperty(
      "--consonant-merch-card-heading-xs-max-width",
      `${Math.round(cardWidth - badgeWidth - 16)}px`
      // consonant-merch-spacing-xs
    );
  }
  async postCardUpdateHook() {
  }
  connectedCallbackHook() {
  }
  disconnectedCallbackHook() {
  }
  /* c8 ignore next 3 */
  renderLayout() {
  }
  get aemFragmentMapping() {
    return getFragmentMapping(this.card.variant);
  }
};
_container = new WeakMap();
__publicField(_VariantLayout, "styleMap", {});
var VariantLayout = _VariantLayout;

// src/variants/catalog.js
init_lit();

// src/variants/catalog.css.js
var CSS = `
:root {
    --consonant-merch-card-catalog-width: 302px;
    --consonant-merch-card-catalog-icon-size: 40px;
}

.collection-container.catalog {
    --merch-card-collection-card-min-height: 330px;
    --merch-card-collection-card-width: var(--consonant-merch-card-catalog-width);
}

merch-sidenav.catalog {
    --merch-sidenav-title-font-size: 15px;
    --merch-sidenav-title-font-weight: 500;
    --merch-sidenav-title-line-height: 19px;
    --merch-sidenav-title-color: rgba(70, 70, 70, 0.87);
    --merch-sidenav-title-padding: 8px 15px 21px;
    --merch-sidenav-item-height: 40px;
    --merch-sidenav-item-inline-padding: 15px;
    --merch-sidenav-item-font-weight: 700;
    --merch-sidenav-item-font-size: 17px;
    --merch-sidenav-item-line-height: normal;
    --merch-sidenav-item-label-top-margin: 8px;
    --merch-sidenav-item-label-bottom-margin: 11px;
    --merch-sidenav-item-icon-top-margin: 11px;
    --merch-sidenav-item-icon-gap: 13px;
    --merch-sidenav-item-selected-background: var(--spectrum-gray-300, #D5D5D5);
    --merch-sidenav-list-item-gap: 5px;
    --merch-sidenav-checkbox-group-padding: 0 15px;
    --merch-sidenav-modal-border-radius: 0;
}

merch-sidenav.catalog merch-sidenav-checkbox-group {
    border: none;
}

merch-sidenav.catalog merch-sidenav-list:not(:first-of-type) {
    --merch-sidenav-list-gap: 32px;
}

.one-merch-card.catalog,
.two-merch-cards.catalog,
.three-merch-cards.catalog,
.four-merch-cards.catalog {
    --merch-card-collection-card-width: var(--consonant-merch-card-catalog-width);
}

.collection-container.catalog merch-sidenav {
    --merch-sidenav-gap: 10px;
}

merch-card-collection-header.catalog {
    --merch-card-collection-header-row-gap: var(--consonant-merch-spacing-xs);
    --merch-card-collection-header-search-max-width: 244px;
}

@media screen and ${MOBILE_LANDSCAPE} {
    merch-card-collection-header.catalog {
        --merch-card-collection-header-columns: min-content auto;
    }
}

@media screen and ${TABLET_UP} {
    merch-card-collection-header.catalog {
        --merch-card-collection-header-column-gap: 16px;
    }
}

@media screen and ${DESKTOP_UP} {
    :root {
        --consonant-merch-card-catalog-width: 276px;
    }

    merch-card-collection-header.catalog {
        --merch-card-collection-header-result-font-size: 17px;
    }
}

merch-card[variant="catalog"] [slot="action-menu-content"] {
  background-color: #000;
  color: var(--color-white, #fff);
  font-size: var(--consonant-merch-card-body-xs-font-size);
  width: fit-content;
  padding: var(--consonant-merch-spacing-xs);
  border-radius: var(--consonant-merch-spacing-xxxs);
  position: absolute;
  top: 55px;
  right: 15px;
  line-height: var(--consonant-merch-card-body-line-height);
}

merch-card[variant="catalog"] [slot="action-menu-content"] ul {
  padding-left: 0;
  padding-bottom: var(--consonant-merch-spacing-xss);
  margin-top: 0;
  margin-bottom: 0;
  list-style-position: inside;
  list-style-type: '\u2022 ';
}

merch-card[variant="catalog"] [slot="action-menu-content"] ul li {
  padding-left: 0;
  line-height: var(--consonant-merch-card-body-line-height);
}

merch-card[variant="catalog"] [slot="action-menu-content"] ::marker {
  margin-right: 0;
}

merch-card[variant="catalog"] [slot="action-menu-content"] p {
  color: var(--color-white, #fff);
}

merch-card[variant="catalog"] [slot="action-menu-content"] a {
  color: var(--consonant-merch-card-background-color);
  text-decoration: underline;
}

merch-card[variant="catalog"] .payment-details {
  font-size: var(--consonant-merch-card-body-font-size);
  font-style: italic;
  font-weight: 400;
  line-height: var(--consonant-merch-card-body-line-height);
}`;

// src/variants/catalog.js
var CATALOG_AEM_FRAGMENT_MAPPING = {
  badge: true,
  ctas: { slot: "footer", size: "m" },
  description: { tag: "div", slot: "body-xs" },
  mnemonics: { size: "l" },
  prices: { tag: "h3", slot: "heading-xs" },
  size: ["wide", "super-wide"],
  title: { tag: "h3", slot: "heading-xs" }
};
var Catalog = class extends VariantLayout {
  constructor(card) {
    super(card);
    __publicField(this, "dispatchActionMenuToggle", () => {
      this.card.dispatchEvent(
        new CustomEvent(EVENT_MERCH_CARD_ACTION_MENU_TOGGLE, {
          bubbles: true,
          composed: true,
          detail: {
            card: this.card.name,
            type: "action-menu"
          }
        })
      );
    });
    __publicField(this, "toggleActionMenu", (e4) => {
      if (!this.actionMenuContentSlot || !e4 || e4.type !== "click" && e4.code !== "Space" && e4.code !== "Enter")
        return;
      e4.preventDefault();
      this.actionMenuContentSlot.classList.toggle("hidden");
      const isHidden = this.actionMenuContentSlot.classList.contains("hidden");
      if (!isHidden) this.dispatchActionMenuToggle();
      this.setAriaExpanded(this.actionMenu, (!isHidden).toString());
    });
    __publicField(this, "toggleActionMenuFromCard", (e4) => {
      const retract = e4?.type === "mouseleave" ? true : void 0;
      this.card.blur();
      this.actionMenu?.classList.remove("always-visible");
      if (!this.actionMenuContentSlot) return;
      if (!retract) this.dispatchActionMenuToggle();
      this.actionMenuContentSlot.classList.toggle("hidden", retract);
      this.setAriaExpanded(this.actionMenu, "false");
    });
    __publicField(this, "hideActionMenu", (e4) => {
      this.actionMenuContentSlot?.classList.add("hidden");
      this.setAriaExpanded(this.actionMenu, "false");
    });
  }
  get actionMenu() {
    return this.card.shadowRoot.querySelector(".action-menu");
  }
  get actionMenuContentSlot() {
    return this.card.shadowRoot.querySelector(
      'slot[name="action-menu-content"]'
    );
  }
  renderLayout() {
    return x` <div class="body">
                <div class="top-section">
                    <slot name="icons"></slot> ${this.badge}
                    <div
                        class="action-menu
                ${isMobileOrTablet() && this.card.actionMenu ? "always-visible" : ""}
                ${!this.card.actionMenu ? "hidden" : "invisible"}"
                        @click="${this.toggleActionMenu}"
                        @keypress="${this.toggleActionMenu}"
                        tabindex="0"
                        aria-expanded="false"
                        role="button"
                    >
                        ${this.card.actionMenuLabel} - ${this.card.title}
                    </div>
                </div>
                <slot
                    name="action-menu-content"
                    class="action-menu-content
            ${!this.card.actionMenuContent ? "hidden" : ""}"
                    @focusout="${this.hideActionMenu}"
                    >${this.card.actionMenuContent}
                </slot>
                <slot name="heading-xs"></slot>
                <slot name="heading-m"></slot>
                <slot name="body-xxs"></slot>
                ${!this.promoBottom ? x`<slot name="promo-text"></slot
                          ><slot name="callout-content"></slot>` : ""}
                <slot name="body-xs"></slot>
                ${this.promoBottom ? x`<slot name="promo-text"></slot
                          ><slot name="callout-content"></slot>` : ""}
            </div>
            ${this.secureLabelFooter}
            <slot></slot>`;
  }
  getGlobalCSS() {
    return CSS;
  }
  setAriaExpanded(element, value) {
    element.setAttribute("aria-expanded", value);
  }
  connectedCallbackHook() {
    this.card.addEventListener("mouseleave", this.toggleActionMenuFromCard);
  }
  disconnectedCallbackHook() {
    this.card.removeEventListener(
      "mouseleave",
      this.toggleActionMenuFromCard
    );
  }
};
__publicField(Catalog, "variantStyle", i`
        :host([variant='catalog']) {
            min-height: 330px;
            width: var(--consonant-merch-card-catalog-width);
        }

        .body .catalog-badge {
            display: flex;
            height: fit-content;
            flex-direction: column;
            width: fit-content;
            max-width: 140px;
            border-radius: 5px;
            position: relative;
            top: 0;
            margin-left: var(--consonant-merch-spacing-xxs);
            box-sizing: border-box;
        }
    `);

// src/variants/image.js
init_lit();

// src/variants/image.css.js
var CSS2 = `
:root {
  --consonant-merch-card-image-width: 300px;
}

.one-merch-card.image,
.two-merch-cards.image,
.three-merch-cards.image,
.four-merch-cards.image {
  grid-template-columns: var(--consonant-merch-card-image-width);
}

@media screen and ${TABLET_UP} {
  .two-merch-cards.image,
  .three-merch-cards.image,
  .four-merch-cards.image {
      grid-template-columns: repeat(2, var(--consonant-merch-card-image-width));
  }
}

@media screen and ${DESKTOP_UP} {
  :root {
    --consonant-merch-card-image-width: 378px;
    --consonant-merch-card-image-width-4clm: 276px;
  }
    
  .three-merch-cards.image {
      grid-template-columns: repeat(3, var(--consonant-merch-card-image-width));
  }

  .four-merch-cards.image {
      grid-template-columns: repeat(4, var(--consonant-merch-card-image-width-4clm));
  }
}
`;

// src/variants/image.js
var Image2 = class extends VariantLayout {
  constructor(card) {
    super(card);
  }
  getGlobalCSS() {
    return CSS2;
  }
  renderLayout() {
    return x`${this.cardImage}
            <div class="body">
                <slot name="icons"></slot>
                <slot name="heading-xs"></slot>
                <slot name="body-xxs"></slot>
                ${this.promoBottom ? x`<slot name="body-xs"></slot
                          ><slot name="promo-text"></slot>` : x`<slot name="promo-text"></slot
                          ><slot name="body-xs"></slot>`}
            </div>
            ${this.evergreen ? x`
                      <div
                          class="detail-bg-container"
                          style="background: ${this.card["detailBg"]}"
                      >
                          <slot name="detail-bg"></slot>
                      </div>
                  ` : x`
                      <hr />
                      ${this.secureLabelFooter}
                  `}`;
  }
};

// src/variants/inline-heading.js
init_lit();

// src/variants/inline-heading.css.js
var CSS3 = `
:root {
  --consonant-merch-card-inline-heading-width: 300px;
}

.one-merch-card.inline-heading,
.two-merch-cards.inline-heading,
.three-merch-cards.inline-heading,
.four-merch-cards.inline-heading {
    grid-template-columns: var(--consonant-merch-card-inline-heading-width);
}

@media screen and ${TABLET_UP} {
  .two-merch-cards.inline-heading,
  .three-merch-cards.inline-heading,
  .four-merch-cards.inline-heading {
      grid-template-columns: repeat(2, var(--consonant-merch-card-inline-heading-width));
  }
}

@media screen and ${DESKTOP_UP} {
  :root {
    --consonant-merch-card-inline-heading-width: 378px;
  }

  .three-merch-cards.inline-heading,
  .four-merch-cards.inline-heading {
      grid-template-columns: repeat(3, var(--consonant-merch-card-inline-heading-width));
  }
}

@media screen and ${LARGE_DESKTOP} {
  .four-merch-cards.inline-heading {
      grid-template-columns: repeat(4, var(--consonant-merch-card-inline-heading-width));
  }
}
`;

// src/variants/inline-heading.js
var InlineHeading = class extends VariantLayout {
  constructor(card) {
    super(card);
  }
  getGlobalCSS() {
    return CSS3;
  }
  renderLayout() {
    return x` ${this.badge}
            <div class="body">
                <div class="top-section">
                    <slot name="icons"></slot>
                    <slot name="heading-xs"></slot>
                </div>
                <slot name="body-xs"></slot>
            </div>
            ${!this.card.customHr ? x`<hr />` : ""} ${this.secureLabelFooter}`;
  }
};

// src/variants/mini-compare-chart.js
init_lit();

// src/variants/mini-compare-chart.css.js
var CSS4 = `
  :root {
    --consonant-merch-card-mini-compare-chart-icon-size: 32px;
    --consonant-merch-card-mini-compare-border-color: #E9E9E9;
    --consonant-merch-card-mini-compare-mobile-cta-font-size: 16px;
    --consonant-merch-card-mini-compare-mobile-cta-width: 75px;
    --consonant-merch-card-mini-compare-badge-mobile-max-width: 50px;
    --consonant-merch-card-mini-compare-mobile-price-font-size: 32px;
    --consonant-merch-card-card-mini-compare-mobile-background-color: #F8F8F8;
    --consonant-merch-card-card-mini-compare-mobile-spacing-xs: 12px;
  }
  
  merch-card[variant="mini-compare-chart"] [slot="heading-m"] {
    padding: 0 var(--consonant-merch-spacing-s) 0;
  }

  merch-card[variant="mini-compare-chart"] merch-addon {
    box-sizing: border-box;
  }

  merch-card[variant="mini-compare-chart"] merch-addon {
    padding-left: 4px;
    padding-top: 8px;
    padding-bottom: 8px;
    padding-right: 8px;
    border-radius: .5rem;
    font-family: var(--merch-body-font-family, 'Adobe Clean');
    margin: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-s) .5rem;
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="mini-compare-chart"] merch-addon [is="inline-price"] {
    min-height: unset;
    font-weight: bold;
    pointer-events: none;
  }

  merch-card[variant="mini-compare-chart"] merch-addon::part(checkbox) {
      height: 18px;
      width: 18px;
      margin: 14px 12px 0 8px;
  }

  merch-card[variant="mini-compare-chart"] merch-addon::part(label) {
    display: flex;
    flex-direction: column;
    padding: 8px 4px 8px 0;
    width: 100%;
  }

  merch-card[variant="mini-compare-chart"] [is="inline-price"] {
    display: inline-block;
    min-height: 30px;
    min-width: 1px;
  }

  merch-card[variant="mini-compare-chart"] [slot="callout-content"] {
    padding: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-s) 0px;
  }

  merch-card[variant="mini-compare-chart"] [slot="body-m"] {
    padding: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-s);
  }

  merch-card[variant="mini-compare-chart"] [slot="callout-content"] [is="inline-price"] {
    min-height: unset;
  }

  merch-card[variant="mini-compare-chart"] [slot="price-commitment"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    padding: 0 var(--consonant-merch-spacing-s);
    font-style: italic;
  }

  merch-card[variant="mini-compare-chart"] [slot="price-commitment"] a {
    display: inline-block;
    height: 27px;
  }

  merch-card[variant="mini-compare-chart"] [slot="offers"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
  }

  merch-card[variant="mini-compare-chart"] [slot="body-xxs"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    padding: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-s) 0;    
  }

  merch-card[variant="mini-compare-chart"] [slot="promo-text"] {
    font-size: var(--consonant-merch-card-body-m-font-size);
    padding: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-s) 0;
  }

  merch-card[variant="mini-compare-chart"] [slot="promo-text"] a {
    text-decoration: underline;
  }

  merch-card[variant="mini-compare-chart"] .action-area {
    display: flex;
    justify-content: flex-end;
    align-items: flex-end;
    flex-wrap: wrap;
    width: 100%;
    gap: var(--consonant-merch-spacing-xxs);
  }

  merch-card[variant="mini-compare-chart"] [slot="footer-rows"] ul {
    margin-block-start: 0px;
    margin-block-end: 0px;
    padding-inline-start: 0px;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-icon {
    display: flex;
    place-items: center;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-icon img {
    max-width: initial;
    width: var(--consonant-merch-card-mini-compare-chart-icon-size);
    height: var(--consonant-merch-card-mini-compare-chart-icon-size);
  }

  merch-card[variant="mini-compare-chart"] .footer-rows-title {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-color: var(--merch-color-grey-60);
    font-weight: 700;
    line-height: var(--consonant-merch-card-body-xs-line-height);
    font-size: var(--consonant-merch-card-body-s-font-size);
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell {
    border-top: 1px solid var(--consonant-merch-card-border-color);
    display: flex;
    gap: var(--consonant-merch-spacing-xs);
    justify-content: start;
    place-items: center;
    padding: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-s);
    margin-block: 0px;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-icon-checkmark img {
    max-width: initial;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-icon-checkmark {
    display: flex;
    align-items: center;
    height: 20px;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell-checkmark {
    display: flex;
    gap: var(--consonant-merch-spacing-xs);
    justify-content: start;
    align-items: flex-start;
    margin-block: var(--consonant-merch-spacing-xxxs);
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell-description-checkmark {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    font-weight: 400;
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell-description {
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
    font-weight: 400;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell-description p {
    color: var(--merch-color-grey-80);
    vertical-align: bottom;
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell-description a {
    color: var(--color-accent);
  }

  merch-card[variant="mini-compare-chart"] .toggle-icon {
    display: flex;
    background-color: transparent;
    border: none;
    padding: 0;
    margin: 0;
    text-align: inherit;
    font: inherit;
    border-radius: 0;
  }

  merch-card[variant="mini-compare-chart"] .checkmark-copy-container {
    display: none;
  }

  merch-card[variant="mini-compare-chart"] .checkmark-copy-container.open {
    display: block;
    padding-block-start: var(--consonant-merch-card-card-mini-compare-mobile-spacing-xs);
    padding-block-end: 4px;
  }
  
.one-merch-card.mini-compare-chart {
  grid-template-columns: var(--consonant-merch-card-mini-compare-chart-wide-width);
  gap: var(--consonant-merch-spacing-xs);
}

.two-merch-cards.mini-compare-chart,
.three-merch-cards.mini-compare-chart,
.four-merch-cards.mini-compare-chart {
  grid-template-columns: repeat(2, var(--consonant-merch-card-mini-compare-chart-width));
  gap: var(--consonant-merch-spacing-xs);
}

/* bullet list */
merch-card[variant="mini-compare-chart"].bullet-list {
  border-radius: var(--consonant-merch-spacing-xxs);
}

merch-card[variant="mini-compare-chart"].bullet-list:not(.badge-card):not(.mini-compare-chart-badge) {
  border-color: var(--consonant-merch-card-mini-compare-border-color);
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m"] {
  padding: var(--consonant-merch-spacing-xxs) var(--consonant-merch-spacing-xs);
  font-size: var(--consonant-merch-card-heading-xxs-font-size);
  line-height: var(--consonant-merch-card-heading-xxs-line-height);
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"],
merch-card[variant="mini-compare-chart"].bullet-list [slot="price-commitment"] {
  padding: 0 var(--consonant-merch-spacing-xs);
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"] .starting-at {
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
  font-weight: 400;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"] .price {
  font-size: var(--consonant-merch-card-heading-l-font-size);
  line-height: 35px;
  font-weight: 800;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"] .price-alternative:has(+ .price-annual-prefix) {
  margin-bottom: 4px;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"] [data-template="strikethrough"] {
  min-height: 24px;
  margin-bottom: 2px;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"] [data-template="strikethrough"],
merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"] .price-strikethrough {
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
  font-weight: 700;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="heading-m-price"].annual-price-new-line > span[is="inline-price"] > .price-annual, .price-annual-prefix::after, .price-annual-suffix {
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
  font-weight: 400;
  font-style: italic;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="body-xxs"] {
  padding: var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xs) 0;
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
  font-weight: 400;
  letter-spacing: normal;
  font-style: italic;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="promo-text"] {
  padding: var(--consonant-merch-card-card-mini-compare-mobile-spacing-xs) var(--consonant-merch-spacing-xs) 0;
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
  font-weight: 700;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="promo-text"] a {
  font-weight: 400;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="body-m"] {
  padding: var(--consonant-merch-card-card-mini-compare-mobile-spacing-xs) var(--consonant-merch-spacing-xs) 0;
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
  font-weight: 400;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="body-m"] p:has(+ p) {
  margin-bottom: 8px;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="callout-content"] {
  padding: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-xs) 0px;
  margin: 0;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="callout-content"] > div > div {
  background-color: #D9D9D9;
}

merch-card[variant="mini-compare-chart"].bullet-list merch-addon {
  margin: var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-xs) var(--consonant-merch-spacing-xxs);
}

merch-card[variant="mini-compare-chart"].bullet-list merch-addon [is="inline-price"] {
  font-weight: 400;
}

merch-card[variant="mini-compare-chart"].bullet-list footer {
  gap: var(--consonant-merch-spacing-xxs);
}

merch-card[variant="mini-compare-chart"].bullet-list .action-area {
  justify-content: flex-start;
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="footer-rows"] {
  background-color: var(--consonant-merch-card-card-mini-compare-mobile-background-color);
  border-radius: 0 0 var(--consonant-merch-spacing-xxs) var(--consonant-merch-spacing-xxs);
}

merch-card[variant="mini-compare-chart"].bullet-list [slot="price-commitment"] {
  padding: var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xs) 0 var(--consonant-merch-spacing-xs);
  font-size: var(--consonant-merch-card-body-s-font-size);
  line-height: var(--consonant-merch-card-body-s-line-height);
}

/* mini compare mobile */ 
@media screen and ${MOBILE_LANDSCAPE} {
  :root {
    --consonant-merch-card-mini-compare-chart-width: 302px;
    --consonant-merch-card-mini-compare-chart-wide-width: 302px;
  }

  .two-merch-cards.mini-compare-chart,
  .three-merch-cards.mini-compare-chart,
  .four-merch-cards.mini-compare-chart {
    grid-template-columns: var(--consonant-merch-card-mini-compare-chart-width);
    gap: var(--consonant-merch-spacing-xs);
  }

  merch-card[variant="mini-compare-chart"] [slot="heading-m"] {
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
  }

  merch-card[variant="mini-compare-chart"] [slot="heading-m-price"] {
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
  }

  merch-card[variant="mini-compare-chart"] [slot="body-m"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }
  
  merch-card[variant="mini-compare-chart"] [slot="promo-text"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="mini-compare-chart"] .footer-row-cell-description {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="mini-compare-chart"] merch-addon {
    box-sizing: border-box;
  }
}

@media screen and ${TABLET_DOWN} {
  merch-card[variant="mini-compare-chart"] [slot="heading-m"] {
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
  }

  merch-card[variant="mini-compare-chart"] [slot="heading-m-price"] {
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
  }

  merch-card[variant="mini-compare-chart"] [slot="body-m"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="mini-compare-chart"] [slot="promo-text"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }
  
  merch-card[variant="mini-compare-chart"] .footer-row-cell-description {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="mini-compare-chart"].bullet-list .footer-row-cell-description {
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
  }
}
@media screen and ${TABLET_UP} {
  :root {
    --consonant-merch-card-mini-compare-chart-width: 302px;
    --consonant-merch-card-mini-compare-chart-wide-width: 302px;
  }

  .two-merch-cards.mini-compare-chart {
    grid-template-columns: repeat(2, minmax(var(--consonant-merch-card-mini-compare-chart-width), var(--consonant-merch-card-mini-compare-chart-wide-width)));
    gap: var(--consonant-merch-spacing-m);
  }

  .three-merch-cards.mini-compare-chart,
  .four-merch-cards.mini-compare-chart {
      grid-template-columns: repeat(2, minmax(var(--consonant-merch-card-mini-compare-chart-width), var(--consonant-merch-card-mini-compare-chart-wide-width)));
  }

   merch-card[variant="mini-compare-chart"].bullet-list [slot="price-commitment"] {
    padding: var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xs) 0 var(--consonant-merch-spacing-xs);
    font-size: var(--consonant-merch-card-body-s-font-size);
    line-height: var(--consonant-merch-card-body-s-line-height);
    font-weight: 400;
  }

  merch-card[variant="mini-compare-chart"].bullet-list [slot="footer-rows"] {
    padding: var(--consonant-merch-spacing-xs);
  }

  merch-card[variant="mini-compare-chart"].bullet-list .footer-rows-title {
    line-height: var(--consonant-merch-card-body-s-line-height);
  }

  merch-card[variant="mini-compare-chart"].bullet-list .checkmark-copy-container.open {
    padding-block-start: var(--consonant-merch-spacing-xs);
    padding-block-end: 0;
  }

  merch-card[variant="mini-compare-chart"].bullet-list .footer-row-cell-checkmark {
    gap: var(--consonant-merch-spacing-xxs);
  }
}

/* desktop */
@media screen and ${DESKTOP_UP} {
  :root {
    --consonant-merch-card-mini-compare-chart-width: 378px;
    --consonant-merch-card-mini-compare-chart-wide-width: 484px;  
  }
  .one-merch-card.mini-compare-chart {
    grid-template-columns: var(--consonant-merch-card-mini-compare-chart-wide-width);
  }

  .two-merch-cards.mini-compare-chart {
    grid-template-columns: repeat(2, var(--consonant-merch-card-mini-compare-chart-wide-width));
    gap: var(--consonant-merch-spacing-m);
  }

  .three-merch-cards.mini-compare-chart,
  .four-merch-cards.mini-compare-chart {
    grid-template-columns: repeat(3, var(--consonant-merch-card-mini-compare-chart-width));
    gap: var(--consonant-merch-spacing-m);
  }
}

@media screen and ${LARGE_DESKTOP} {
  .four-merch-cards.mini-compare-chart {
      grid-template-columns: repeat(4, var(--consonant-merch-card-mini-compare-chart-width));
  }
}

merch-card[variant="mini-compare-chart"].bullet-list div[slot="footer-rows"]  {
  height: 100%;
}

merch-card .footer-row-cell:nth-child(1) {
  min-height: var(--consonant-merch-card-footer-row-1-min-height);
}

merch-card .footer-row-cell:nth-child(2) {
  min-height: var(--consonant-merch-card-footer-row-2-min-height);
}

merch-card .footer-row-cell:nth-child(3) {
  min-height: var(--consonant-merch-card-footer-row-3-min-height);
}

merch-card .footer-row-cell:nth-child(4) {
  min-height: var(--consonant-merch-card-footer-row-4-min-height);
}

merch-card .footer-row-cell:nth-child(5) {
  min-height: var(--consonant-merch-card-footer-row-5-min-height);
}

merch-card .footer-row-cell:nth-child(6) {
  min-height: var(--consonant-merch-card-footer-row-6-min-height);
}

merch-card .footer-row-cell:nth-child(7) {
  min-height: var(--consonant-merch-card-footer-row-7-min-height);
}

merch-card .footer-row-cell:nth-child(8) {
  min-height: var(--consonant-merch-card-footer-row-8-min-height);
}
`;

// src/variants/mini-compare-chart.js
var FOOTER_ROW_MIN_HEIGHT = 32;
var MiniCompareChart = class extends VariantLayout {
  constructor(card) {
    super(card);
    __publicField(this, "getRowMinHeightPropertyName", (index) => `--consonant-merch-card-footer-row-${index}-min-height`);
    __publicField(this, "getMiniCompareFooter", () => {
      const secureLabel = this.card.secureLabel ? x`<slot name="secure-transaction-label">
                  <span class="secure-transaction-label"
                      >${this.card.secureLabel}</span
                  ></slot
              >` : x`<slot name="secure-transaction-label"></slot>`;
      return x`<footer>${secureLabel}<slot name="footer"></slot></footer>`;
    });
  }
  getGlobalCSS() {
    return CSS4;
  }
  adjustMiniCompareBodySlots() {
    if (this.card.getBoundingClientRect().width <= 2) return;
    this.updateCardElementMinHeight(
      this.card.shadowRoot.querySelector(".top-section"),
      "top-section"
    );
    let slots = [
      "heading-m",
      "body-m",
      "heading-m-price",
      "body-xxs",
      "price-commitment",
      "offers",
      "promo-text",
      "callout-content"
    ];
    if (this.card.classList.contains("bullet-list")) {
      slots.push("footer-rows");
    }
    slots.forEach(
      (slot) => this.updateCardElementMinHeight(
        this.card.shadowRoot.querySelector(`slot[name="${slot}"]`),
        slot
      )
    );
    this.updateCardElementMinHeight(
      this.card.shadowRoot.querySelector("footer"),
      "footer"
    );
    const badge = this.card.shadowRoot.querySelector(
      ".mini-compare-chart-badge"
    );
    if (badge?.textContent !== "") {
      this.getContainer().style.setProperty(
        "--consonant-merch-card-mini-compare-chart-top-section-mobile-height",
        "32px"
      );
    }
  }
  adjustMiniCompareFooterRows() {
    if (this.card.getBoundingClientRect().width === 0) return;
    const footerRows = this.card.querySelector('[slot="footer-rows"] ul');
    if (!footerRows || !footerRows.children) return;
    [...footerRows.children].forEach((el, index) => {
      const height = Math.max(
        FOOTER_ROW_MIN_HEIGHT,
        parseFloat(window.getComputedStyle(el).height) || 0
      );
      const maxMinHeight = parseFloat(
        this.getContainer().style.getPropertyValue(
          this.getRowMinHeightPropertyName(index + 1)
        )
      ) || 0;
      if (height > maxMinHeight) {
        this.getContainer().style.setProperty(
          this.getRowMinHeightPropertyName(index + 1),
          `${height}px`
        );
      }
    });
  }
  removeEmptyRows() {
    const footerRows = this.card.querySelectorAll(".footer-row-cell");
    footerRows.forEach((row) => {
      const rowDescription = row.querySelector(
        ".footer-row-cell-description"
      );
      if (rowDescription) {
        const isEmpty = !rowDescription.textContent.trim();
        if (isEmpty) {
          row.remove();
        }
      }
    });
  }
  get mainPrice() {
    const price2 = this.card.querySelector(
      `[slot="heading-m-price"] ${SELECTOR_MAS_INLINE_PRICE}[data-template="price"]`
    );
    return price2;
  }
  get headingMPriceSlot() {
    return this.card.shadowRoot.querySelector('slot[name="heading-m-price"]')?.assignedElements()[0];
  }
  toggleAddon(merchAddon) {
    const mainPrice = this.mainPrice;
    const headingMPriceSlot = this.headingMPriceSlot;
    if (!mainPrice && headingMPriceSlot) {
      const planType = merchAddon?.getAttribute("plan-type");
      let visibleSpan = null;
      if (merchAddon && planType) {
        const matchingP = merchAddon.querySelector(
          `p[data-plan-type="${planType}"]`
        );
        visibleSpan = matchingP?.querySelector(
          'span[is="inline-price"]'
        );
      }
      this.card.querySelectorAll('p[slot="heading-m-price"]').forEach((p2) => p2.remove());
      if (merchAddon.checked) {
        if (visibleSpan) {
          const replacementP = createTag(
            "p",
            {
              class: "addon-heading-m-price-addon",
              slot: "heading-m-price"
            },
            visibleSpan.innerHTML
          );
          this.card.appendChild(replacementP);
        }
      } else {
        const freeP = createTag(
          "p",
          {
            class: "card-heading",
            id: "free",
            slot: "heading-m-price"
          },
          "Free"
        );
        this.card.appendChild(freeP);
      }
    }
  }
  async adjustAddon() {
    await this.card.updateComplete;
    const addon = this.card.addon;
    if (!addon) return;
    const price2 = this.mainPrice;
    let planType = this.card.planType;
    if (price2) {
      await price2.onceSettled();
      planType = price2.value?.[0]?.planType;
    }
    if (!planType) return;
    addon.planType = planType;
    const addonWithPlanType = this.card.querySelector(
      "merch-addon[plan-type]"
    );
    addonWithPlanType?.updateComplete.then(() => {
      this.updateCardElementMinHeight(
        this.card.shadowRoot.querySelector(`slot[name="addon"]`),
        "addon"
      );
    });
  }
  renderLayout() {
    return x` <div class="top-section${this.badge ? " badge" : ""}">
                <slot name="icons"></slot> ${this.badge}
            </div>
            <slot name="heading-m"></slot>
            ${this.card.classList.contains("bullet-list") ? x`<slot name="heading-m-price"></slot>
                      <slot name="price-commitment"></slot>
                      <slot name="body-xxs"></slot>
                      <slot name="promo-text"></slot>
                      <slot name="body-m"></slot>
                      <slot name="offers"></slot>` : x`<slot name="body-m"></slot>
                      <slot name="heading-m-price"></slot>
                      <slot name="body-xxs"></slot>
                      <slot name="price-commitment"></slot>
                      <slot name="offers"></slot>
                      <slot name="promo-text"></slot> `}
            <slot name="callout-content"></slot>
            <slot name="addon"></slot>
            ${this.getMiniCompareFooter()}
            <slot name="footer-rows"><slot name="body-s"></slot></slot>`;
  }
  async postCardUpdateHook() {
    await Promise.all(this.card.prices.map((price2) => price2.onceSettled()));
    await this.adjustAddon();
    if (isMobile()) {
      this.removeEmptyRows();
    } else {
      this.adjustMiniCompareBodySlots();
      this.adjustMiniCompareFooterRows();
    }
  }
};
__publicField(MiniCompareChart, "variantStyle", i`
        :host([variant='mini-compare-chart']) > slot:not([name='icons']) {
            display: block;
        }

        :host([variant='mini-compare-chart'].bullet-list)
            > slot[name='heading-m-price'] {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        :host([variant='mini-compare-chart'].bullet-list)
            .mini-compare-chart-badge {
            padding: 2px 10px 3px 10px;
            font-size: var(--consonant-merch-card-body-xs-font-size);
            line-height: var(--consonant-merch-card-body-xs-line-height);
            border-radius: 7.11px 0 0 7.11px;
            font-weight: 700;
        }

        :host([variant='mini-compare-chart']) footer {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-footer-height
            );
            padding: var(--consonant-merch-spacing-s);
        }

        :host([variant='mini-compare-chart'].bullet-list) footer {
            flex-flow: column nowrap;
            min-height: var(
                --consonant-merch-card-mini-compare-chart-footer-height
            );
            padding: var(--consonant-merch-spacing-xs);
        }

        /* mini-compare card  */
        :host([variant='mini-compare-chart']) .top-section {
            padding-top: var(--consonant-merch-spacing-s);
            padding-inline-start: var(--consonant-merch-spacing-s);
            height: var(
                --consonant-merch-card-mini-compare-chart-top-section-height
            );
        }

        :host([variant='mini-compare-chart'].bullet-list) .top-section {
            padding-top: var(--consonant-merch-spacing-xs);
            padding-inline-start: var(--consonant-merch-spacing-xs);
        }

        :host([variant='mini-compare-chart'].bullet-list)
            .secure-transaction-label {
            align-self: flex-start;
            flex: none;
            font-size: var(--consonant-merch-card-body-xxs-font-size);
            font-weight: 400;
            color: #505050;
        }

        @media screen and ${r(TABLET_DOWN)} {
            [class*'-merch-cards']
                :host([variant='mini-compare-chart'])
                footer {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }
        }

        @media screen and ${r(DESKTOP_UP)} {
            :host([variant='mini-compare-chart']) footer {
                padding: var(--consonant-merch-spacing-xs)
                    var(--consonant-merch-spacing-s)
                    var(--consonant-merch-spacing-s)
                    var(--consonant-merch-spacing-s);
            }
        }

        :host([variant='mini-compare-chart']) slot[name='footer-rows'] {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: end;
        }
        /* mini-compare card heights for the slots: heading-m, body-m, heading-m-price, price-commitment, offers, promo-text, footer */
        :host([variant='mini-compare-chart']) slot[name='heading-m'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-heading-m-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='body-m'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-body-m-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='heading-m-price'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-heading-m-price-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='body-xxs'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-body-xxs-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='price-commitment'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-price-commitment-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='offers'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-offers-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='promo-text'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-promo-text-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='callout-content'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-callout-content-height
            );
        }
        :host([variant='mini-compare-chart']) slot[name='addon'] {
            min-height: var(
                --consonant-merch-card-mini-compare-chart-addon-height
            );
        }
        :host([variant='mini-compare-chart']:not(.bullet-list))
            slot[name='footer-rows'] {
            justify-content: flex-start;
        }
    `);

// src/variants/plans.js
init_lit();

// src/variants/plans.css.js
var CSS5 = `
:root {
    --consonant-merch-card-plans-width: 302px;
    --consonant-merch-card-plans-icon-size: 40px;
    --consonant-merch-card-plans-students-width: 568px;
}

merch-card[variant^="plans"] {
    --merch-card-plans-heading-xs-min-height: 23px;
    --consonant-merch-card-callout-icon-size: 18px;
    width: var(--consonant-merch-card-plans-width);
}

merch-card[variant^="plans"][size="wide"], merch-card[variant^="plans"][size="super-wide"] {
    width: auto;
}

merch-card[variant="plans-students"] {
    width: 100%;
}

merch-card[variant^="plans"] [slot="icons"] {
    --img-width: 41.5px;
}

merch-card[variant="plans-education"] [slot="body-xs"] span.price:not(.price-legal) {
    display: inline-block;
    font-size: var(--consonant-merch-card-heading-xs-font-size);
    font-weight: 700;
}

merch-card[variant="plans"] [slot="subtitle"] {
    font-size: 14px;
    font-weight: 700;
    line-height: 18px;
}

merch-card[variant^="plans"] span.price-unit-type {
    display: block;
}

merch-card[variant^="plans"] .price-unit-type:not(.disabled)::before {
    content: "";
}
merch-card[variant^="plans"] [slot="callout-content"] span.price-unit-type,
merch-card[variant^="plans"] [slot="addon"] span.price-unit-type,
merch-card[variant^="plans"] .price.price-strikethrough span.price-unit-type,
merch-card[variant^="plans"] span.price-unit-type.disabled {
  display: inline; 
}
  
merch-card[variant^="plans"] [slot="heading-xs"] span.price.price-strikethrough,
merch-card[variant^="plans"] [slot="heading-m"] span.price.price-strikethrough,
merch-card[variant="plans-education"] [slot="body-xs"] span.price.price-strikethrough {
    font-size: var(--consonant-merch-card-heading-xxxs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
    font-weight: 700;
}

merch-card[variant^="plans"] [slot='heading-xs'],
merch-card[variant="plans-education"] span.heading-xs,
merch-card[variant="plans-education"] [slot="body-xs"] span.price:not(.price-strikethrough) {
    min-height: var(--merch-card-plans-heading-xs-min-height);
}

merch-card[variant="plans-education"] [slot="body-xs"] p:has(.heading-xs) {
    margin-bottom: 16x;
}

merch-card[variant="plans-education"] [slot="body-xs"] p:has(span[is="inline-price"]) {
    margin-bottom: 16px;
}

merch-card[variant^="plans"] span.text-l {
    display: block;
    font-size: 18px;
    line-height: 23px;
}

merch-card[variant="plans-education"] span.promo-text {
    margin-bottom: 8px;
}

merch-card[variant="plans-education"] p:has(a[href^='tel:']):has(+ p, + div) {
    margin-bottom: 16px;
}

merch-card[variant^="plans"] [slot="promo-text"],
merch-card[variant="plans-education"] span.promo-text {
    line-height: var(--consonant-merch-card-body-xs-line-height);
}

merch-card[variant="plans-education"] [slot="body-xs"] {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
}

merch-card[variant="plans-education"] .spacer {
    height: calc(var(--merch-card-plans-edu-list-max-offset) - var(--merch-card-plans-edu-list-offset));
}

merch-card[variant="plans-education"] ul + p {
    margin-top: 16px;
}

merch-card-collection.plans merch-card {
    width: auto;
    height: 100%;
}

merch-card-collection.plans merch-card[variant="plans"] aem-fragment + [slot^="heading-"] {
    margin-top: calc(40px + var(--consonant-merch-spacing-xxs));
}

merch-card[variant^='plans'] span[data-template="legal"] {
    display: block;
    color: var(----merch-color-grey-80);
    font-size: 14px;
    font-style: italic;
    font-weight: 400;
    line-height: 21px;
}

merch-card[variant^='plans'] span.price-legal::first-letter {
    text-transform: uppercase;
}

merch-card[variant^='plans'] span.price-legal .price-tax-inclusivity::before {
  content: initial;
}

merch-card[variant^="plans"] [slot="description"] {
    min-height: 84px;
}

merch-card[variant^="plans"] [slot="body-xs"] a {
    color: var(--link-color);
}

merch-card[variant^="plans"] [slot="promo-text"] a {
    color: inherit;
}

merch-card[variant^="plans"] [slot="callout-content"] {
    margin: 8px 0 0;
}

merch-card[variant^="plans"][size="super-wide"] [slot="callout-content"] {
    margin: 0;
}

merch-card[variant^="plans"] [slot='callout-content'] > div > div,
merch-card[variant^="plans"] [slot="callout-content"] > p {
    position: relative;
    padding: 2px 10px 3px;
    background: #D9D9D9;
}

merch-card[variant^="plans"] [slot="callout-content"] > p:has(> .icon-button) {
    padding-right: 36px;
}

merch-card[variant^="plans"] [slot='callout-content'] > p,
merch-card[variant^="plans"] [slot='callout-content'] > div > div > div {
    color: #000;
}

merch-card[variant^="plans"] [slot="callout-content"] img,
merch-card[variant^="plans"] [slot="callout-content"] .icon-button {
    margin: 1.5px 0 1.5px 8px;
}

merch-card[variant^="plans"] [slot="whats-included"] [slot="description"] {
  min-height: auto;
}

merch-card[variant^="plans"] [slot="quantity-select"] {
    margin-top: auto;
    padding-top: 8px;
}

merch-card[variant^="plans"]:has([slot="quantity-select"]) merch-addon {
    margin: 0;
}

merch-card[variant^="plans"] merch-addon {
    --merch-addon-gap: 10px;
    --merch-addon-align: center;
    --merch-addon-checkbox-size: 12px;
    --merch-addon-checkbox-border: 2px solid rgb(109, 109, 109);
    --merch-addon-checkbox-radius: 2px;
    --merch-addon-checkbox-checked-bg: var(--checkmark-icon);
    --merch-addon-checkbox-checked-color: var(--color-accent);
    --merch-addon-label-size: 12px;
    --merch-addon-label-color: rgb(34, 34, 34);
    --merch-addon-label-line-height: normal;
}

merch-card[variant^="plans"] [slot="footer"] a {
    line-height: 19px;
    padding: 3px 16px 4px;
}

merch-card[variant^="plans"] [slot="footer"] .con-button > span {
    min-width: unset;
}

merch-card[variant^="plans"] merch-addon span[data-template="price"] {
    display: none;
}

/* Mobile */
@media screen and ${MOBILE_LANDSCAPE} {
    merch-whats-included merch-mnemonic-list,
    merch-whats-included [slot="heading"] {
        width: 100%;
    }
    merch-card[variant="plans-students"] {
        min-width: var(--consonant-merch-card-plans-width);
        max-width: var(--consonant-merch-card-plans-students-width);
        width: 100%;
    }
    merch-card[variant="plans-education"] .spacer {
        height: 0px;
    }
}

merch-card[variant^="plans"]:not([size]) {
    merch-whats-included merch-mnemonic-list,
    merch-whats-included [slot="heading"] {
        width: 100%;
    }
}

.collection-container.plans {
    --merch-card-collection-card-min-height: 273px;
    --merch-card-collection-card-width: var(--consonant-merch-card-plans-width);
}

merch-sidenav.plans {
    --merch-sidenav-padding: 16px 20px 16px 16px;
}

merch-card-collection-header.plans {
    --merch-card-collection-header-columns: 1fr fit-content(100%);
    --merch-card-collection-header-areas: "result filter";
}

.one-merch-card.plans,
.two-merch-cards.plans,
.three-merch-cards.plans,
.four-merch-cards.plans {
    --merch-card-collection-card-width: var(--consonant-merch-card-plans-width);
}

merch-card-collection:has([slot="subtitle"]) merch-card {
    --merch-card-plans-subtitle-display: block;
}

.columns .text .foreground {
    margin: 0;
}

.columns.merch-card > .row {
    grid-template-columns: repeat(auto-fit, var(--consonant-merch-card-plans-width));
    justify-content: center;
    align-items: center;
}

.columns.checkmark-list ul {
    padding-left: 20px;
    list-style-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3 18 18" height="18px"><path fill="currentcolor" d="M15.656,3.8625l-.7275-.5665a.5.5,0,0,0-.7.0875L7.411,12.1415,4.0875,8.8355a.5.5,0,0,0-.707,0L2.718,9.5a.5.5,0,0,0,0,.707l4.463,4.45a.5.5,0,0,0,.75-.0465L15.7435,4.564A.5.5,0,0,0,15.656,3.8625Z"></path></svg>');
}

.columns.checkmark-list ul li {
    padding-left: 8px;
}

/* Tabs containers */

#tabs-plan {
    --tabs-active-text-color: #131313;
    --tabs-border-color: #444444;
}
#tabs-plan .tab-list-container button[role="tab"][aria-selected="false"] {
    border-top-color: #EAEAEA;
    border-right-color: #EAEAEA;
}
#tabs-plan .tab-list-container button[role="tab"][aria-selected="false"]:first-of-type {
    border-left-color: #EAEAEA;
}

/* Tablet */
@media screen and ${TABLET_UP} {
    .four-merch-cards.plans .foreground {
        max-width: unset;
    }

    .columns.merch-card > .row {
        grid-template-columns: repeat(auto-fit, calc(var(--consonant-merch-card-plans-width) * 2 + var(--consonant-merch-spacing-m)));
    }
}

/* desktop */
@media screen and ${DESKTOP_UP} {
    :root {
        --consonant-merch-card-plans-width: 276px;
    }

    merch-sidenav.plans {
        --merch-sidenav-collection-gap: 30px;
    }

    .columns .four-merch-cards.plans {
        grid-template-columns: repeat(2, var(--consonant-merch-card-plans-width));
    }

    merch-card[variant="plans-students"] {
        width: var(--consonant-merch-card-plans-students-width);
    }

    merch-card-collection-header.plans {
        --merch-card-collection-header-columns: fit-content(100%);
        --merch-card-collection-header-areas: "custom";
    }

    .collection-container.plans:has(merch-sidenav) {
        width: fit-content;
        position: relative;
        left: 50%;
        transform: translateX(-50vw);
        justify-content: start;
        padding-inline: 30px;
        padding-top: 24px;
    }
}

/* Large desktop */
@media screen and ${LARGE_DESKTOP} {
    .columns .four-merch-cards.plans {
        grid-template-columns: repeat(2, var(--consonant-merch-card-plans-width));
    }

    merch-sidenav.plans {
        --merch-sidenav-collection-gap: 54px;
    }
}
`;

// src/variants/plans.js
var PLANS_AEM_FRAGMENT_MAPPING = {
  cardName: { attribute: "name" },
  title: { tag: "h3", slot: "heading-xs" },
  subtitle: { tag: "p", slot: "subtitle" },
  prices: { tag: "p", slot: "heading-m" },
  promoText: { tag: "p", slot: "promo-text" },
  description: { tag: "div", slot: "body-xs" },
  mnemonics: { size: "l" },
  callout: { tag: "div", slot: "callout-content" },
  quantitySelect: { tag: "div", slot: "quantity-select" },
  addon: true,
  secureLabel: true,
  planType: true,
  badge: { tag: "div", slot: "badge", default: "spectrum-yellow-300-plans" },
  allowedBadgeColors: [
    "spectrum-yellow-300-plans",
    "spectrum-gray-300-plans",
    "spectrum-gray-700-plans",
    "spectrum-green-900-plans"
  ],
  allowedBorderColors: [
    "spectrum-yellow-300-plans",
    "spectrum-gray-300-plans",
    "spectrum-green-900-plans"
  ],
  borderColor: { attribute: "border-color" },
  size: ["wide", "super-wide"],
  whatsIncluded: { tag: "div", slot: "whats-included" },
  ctas: { slot: "footer", size: "m" },
  style: "consonant",
  perUnitLabel: { tag: "span", slot: "per-unit-label" }
};
var PLANS_EDUCATION_AEM_FRAGMENT_MAPPING = {
  ...function() {
    const { whatsIncluded, size, ...rest } = PLANS_AEM_FRAGMENT_MAPPING;
    return rest;
  }(),
  title: { tag: "h3", slot: "heading-s" },
  secureLabel: false
};
var PLANS_STUDENTS_AEM_FRAGMENT_MAPPING = {
  ...function() {
    const { subtitle, whatsIncluded, size, quantitySelect, ...rest } = PLANS_AEM_FRAGMENT_MAPPING;
    return rest;
  }()
};
var Plans = class extends VariantLayout {
  constructor(card) {
    super(card);
    this.adaptForMedia = this.adaptForMedia.bind(this);
  }
  priceOptionsProvider(element, options) {
    if (element.dataset.template !== TEMPLATE_PRICE_LEGAL) return;
    options.displayPlanType = this.card?.settings?.displayPlanType ?? false;
  }
  getGlobalCSS() {
    return CSS5;
  }
  /**
   * Moves a slot to its proper place (body or footer) depending on card size and screen size
   * @param {string} name
   * @param {string[]} sizes
   * @param {boolean} shouldBeInFooter
   * @returns
   */
  adjustSlotPlacement(name, sizes, shouldBeInFooter) {
    const shadowRoot = this.card.shadowRoot;
    const footer = shadowRoot.querySelector("footer");
    const size = this.card.getAttribute("size");
    if (!size) return;
    const slotInFooter = shadowRoot.querySelector(
      `footer slot[name="${name}"]`
    );
    const slotInBody = shadowRoot.querySelector(
      `.body slot[name="${name}"]`
    );
    const body = shadowRoot.querySelector(".body");
    if (!size.includes("wide")) {
      footer?.classList.remove("wide-footer");
      if (slotInFooter) slotInFooter.remove();
    }
    if (!sizes.includes(size)) return;
    footer?.classList.toggle("wide-footer", isDesktop());
    if (!shouldBeInFooter && slotInFooter) {
      if (slotInBody) slotInFooter.remove();
      else {
        const bodyPlaceholder = body.querySelector(
          `[data-placeholder-for="${name}"]`
        );
        if (bodyPlaceholder) bodyPlaceholder.replaceWith(slotInFooter);
        else body.appendChild(slotInFooter);
      }
      return;
    }
    if (shouldBeInFooter && slotInBody) {
      const bodyPlaceholder = document.createElement("div");
      bodyPlaceholder.setAttribute("data-placeholder-for", name);
      bodyPlaceholder.classList.add("slot-placeholder");
      if (!slotInFooter) {
        const slotInBodyClone = slotInBody.cloneNode(true);
        footer.prepend(slotInBodyClone);
      }
      slotInBody.replaceWith(bodyPlaceholder);
    }
  }
  adaptForMedia() {
    if (!this.card.closest(
      "merch-card-collection,overlay-trigger,.two-merch-cards,.three-merch-cards,.four-merch-cards, .columns"
    )) {
      this.card.removeAttribute("size");
      return;
    }
    this.adjustSlotPlacement("addon", ["super-wide"], isDesktop());
    this.adjustSlotPlacement(
      "callout-content",
      ["super-wide"],
      isDesktop()
    );
  }
  adjustCallout() {
    const tooltipIcon = this.card.querySelector(
      '[slot="callout-content"] .icon-button'
    );
    if (tooltipIcon && tooltipIcon.title) {
      tooltipIcon.dataset.tooltip = tooltipIcon.title;
      tooltipIcon.removeAttribute("title");
      tooltipIcon.classList.add("hide-tooltip");
      document.addEventListener("touchstart", (event) => {
        event.preventDefault();
        if (event.target !== tooltipIcon) {
          tooltipIcon.classList.add("hide-tooltip");
        } else {
          event.target.classList.toggle("hide-tooltip");
        }
      });
      document.addEventListener("mouseover", (event) => {
        event.preventDefault();
        if (event.target !== tooltipIcon) {
          tooltipIcon.classList.add("hide-tooltip");
        } else {
          event.target.classList.remove("hide-tooltip");
        }
      });
    }
  }
  async adjustEduLists() {
    if (this.card.variant !== "plans-education") return;
    const existingSpacer = this.card.querySelector(".spacer");
    if (existingSpacer) return;
    const body = this.card.querySelector('[slot="body-xs"]');
    if (!body) return;
    const list = body.querySelector("ul");
    if (!list) return;
    const listHeader = list.previousElementSibling;
    const spacer = document.createElement("div");
    spacer.classList.add("spacer");
    body.insertBefore(spacer, listHeader);
    const intersectionObs = new IntersectionObserver(([entry]) => {
      if (entry.boundingClientRect.height === 0) return;
      let offset = 0;
      const heading = this.card.querySelector('[slot="heading-s"]');
      if (heading) offset += getOuterHeight(heading);
      const subtitle = this.card.querySelector('[slot="subtitle"]');
      if (subtitle) offset += getOuterHeight(subtitle);
      const price2 = this.card.querySelector('[slot="heading-m"]');
      if (price2) offset += 8 + getOuterHeight(price2);
      for (const child of body.childNodes) {
        if (child.classList.contains("spacer")) break;
        offset += getOuterHeight(child);
      }
      const maxOffset = this.card.parentElement.style.getPropertyValue(
        "--merch-card-plans-edu-list-max-offset"
      );
      if (offset > (parseFloat(maxOffset) || 0)) {
        this.card.parentElement.style.setProperty(
          "--merch-card-plans-edu-list-max-offset",
          `${offset}px`
        );
      }
      this.card.style.setProperty(
        "--merch-card-plans-edu-list-offset",
        `${offset}px`
      );
      intersectionObs.disconnect();
    });
    intersectionObs.observe(this.card);
  }
  async postCardUpdateHook() {
    this.adaptForMedia();
    this.adjustTitleWidth();
    this.adjustAddon();
    this.adjustCallout();
    if (!this.legalAdjusted) {
      await this.adjustLegal();
      await this.adjustEduLists();
    }
  }
  get headingM() {
    return this.card.querySelector('[slot="heading-m"]');
  }
  get mainPrice() {
    const price2 = this.headingM.querySelector(
      `${SELECTOR_MAS_INLINE_PRICE}[data-template="price"]`
    );
    return price2;
  }
  get divider() {
    return this.card.variant === "plans-education" ? x`<div class="divider"></div>` : A;
  }
  async adjustLegal() {
    if (this.legalAdjusted) return;
    try {
      this.legalAdjusted = true;
      await this.card.updateComplete;
      await customElements.whenDefined("inline-price");
      const prices = [];
      const headingPrice = this.card.querySelector(
        `[slot="heading-m"] ${SELECTOR_MAS_INLINE_PRICE}[data-template="price"]`
      );
      if (headingPrice) prices.push(headingPrice);
      const legalPromises = prices.map(async (price2) => {
        const legal2 = price2.cloneNode(true);
        await price2.onceSettled();
        if (!price2?.options) return;
        if (price2.options.displayPerUnit)
          price2.dataset.displayPerUnit = "false";
        if (price2.options.displayTax)
          price2.dataset.displayTax = "false";
        if (price2.options.displayPlanType)
          price2.dataset.displayPlanType = "false";
        legal2.setAttribute("data-template", "legal");
        price2.parentNode.insertBefore(legal2, price2.nextSibling);
        await legal2.onceSettled();
      });
      await Promise.all(legalPromises);
    } catch {
    }
  }
  async adjustAddon() {
    await this.card.updateComplete;
    const addon = this.card.addon;
    if (!addon) return;
    addon.setAttribute("custom-checkbox", "");
    const price2 = this.mainPrice;
    if (!price2) return;
    await price2.onceSettled();
    const planType = price2.value?.[0]?.planType;
    if (!planType) return;
    addon.planType = planType;
  }
  get stockCheckbox() {
    return this.card.checkboxLabel ? x`<label id="stock-checkbox">
                <input type="checkbox" @change=${this.card.toggleStockOffer}></input>
                <span></span>
                ${this.card.checkboxLabel}
            </label>` : A;
  }
  get icons() {
    if (!this.card.querySelector('[slot="icons"]') && !this.card.getAttribute("id"))
      return A;
    return x`<slot name="icons"></slot>`;
  }
  connectedCallbackHook() {
    const mobileWatcher = matchMobile();
    if (mobileWatcher?.addEventListener)
      mobileWatcher.addEventListener("change", this.adaptForMedia);
    const desktopWatcher = matchDesktop();
    if (desktopWatcher?.addEventListener)
      desktopWatcher.addEventListener("change", this.adaptForMedia);
  }
  disconnectedCallbackHook() {
    const mobileWatcher = matchMobile();
    if (mobileWatcher?.removeEventListener)
      mobileWatcher.removeEventListener("change", this.adaptForMedia);
    const desktopWatcher = matchDesktop();
    if (desktopWatcher?.removeEventListener)
      desktopWatcher.removeEventListener("change", this.adaptForMedia);
  }
  renderLayout() {
    return x` ${this.badge}
            <div class="body">
                ${this.icons}
                <slot name="heading-xs"></slot>
                <slot name="heading-s"></slot>
                <slot name="subtitle"></slot>
                ${this.divider}
                <slot name="heading-m"></slot>
                <slot name="annualPrice"></slot>
                <slot name="priceLabel"></slot>
                <slot name="body-xxs"></slot>
                <slot name="promo-text"></slot>
                <slot name="body-xs"></slot>
                <slot name="whats-included"></slot>
                <slot name="callout-content"></slot>
                <slot name="quantity-select"></slot>
                ${this.stockCheckbox}
                <slot name="addon"></slot>
                <slot name="badge"></slot>
            </div>
            ${this.secureLabelFooter}
            <slot></slot>`;
  }
};
__publicField(Plans, "variantStyle", i`
        :host([variant^='plans']) {
            min-height: 273px;
            border: 1px solid var(--consonant-merch-card-border-color, #dadada);
            --merch-card-plans-min-width: 244px;
            --merch-card-plans-padding: 15px;
            --merch-card-plans-subtitle-display: contents;
            --merch-card-plans-heading-min-height: 23px;
            --merch-color-green-promo: #05834e;
            --secure-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23505050' viewBox='0 0 12 15'%3E%3Cpath d='M11.5 6H11V5A5 5 0 1 0 1 5v1H.5a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5ZM3 5a3 3 0 1 1 6 0v1H3Zm4 6.111V12.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1.389a1.5 1.5 0 1 1 2 0Z'/%3E%3C/svg%3E");
            font-weight: 400;
        }

        :host([variant^='plans']) .slot-placeholder {
            display: none;
        }

        :host([variant='plans-education']) {
            min-height: unset;
        }

        :host([variant='plans-education']) ::slotted([slot='subtitle']) {
            font-size: var(--consonant-merch-card-heading-xxxs-font-size);
            line-height: var(--consonant-merch-card-heading-xxxs-line-height);
            font-style: italic;
            font-weight: 400;
        }

        :host([variant='plans-education']) .divider {
            border: 0;
            border-top: 1px solid #e8e8e8;
            margin-top: 8px;
            margin-bottom: 8px;
        }

        :host([variant='plans']) slot[name='subtitle'] {
            display: var(--merch-card-plans-subtitle-display);
            min-height: 18px;
            margin-top: 8px;
            margin-bottom: -8px;
        }

        :host([variant='plans']) ::slotted([slot='heading-xs']) {
            min-height: var(--merch-card-plans-heading-min-height);
        }

        :host([variant^='plans']) .body {
            min-width: var(--merch-card-plans-min-width);
            padding: var(--merch-card-plans-padding);
        }

        :host([variant='plans'][size]) .body {
            max-width: none;
        }

        :host([variant^='plans']) ::slotted([slot='addon']) {
            margin-top: auto;
            padding-top: 8px;
        }

        :host([variant^='plans']) footer ::slotted([slot='addon']) {
            margin: 0;
            padding: 0;
        }

        :host([variant='plans']) .wide-footer #stock-checkbox {
            margin-top: 0;
        }

        :host([variant='plans']) #stock-checkbox {
            margin-top: 8px;
            gap: 9px;
            color: rgb(34, 34, 34);
            line-height: var(--consonant-merch-card-detail-xs-line-height);
            padding-top: 4px;
            padding-bottom: 5px;
        }

        :host([variant='plans']) #stock-checkbox > span {
            border: 2px solid rgb(109, 109, 109);
            width: 12px;
            height: 12px;
        }

        :host([variant^='plans']) footer {
            padding: var(--merch-card-plans-padding);
            padding-top: 1px;
        }

        :host([variant='plans']) .secure-transaction-label {
            color: rgb(80, 80, 80);
            line-height: var(--consonant-merch-card-detail-xs-line-height);
        }

        :host([variant='plans']) ::slotted([slot='heading-xs']) {
            max-width: var(--consonant-merch-card-heading-xs-max-width, 100%);
        }

        :host([variant='plans']) #badge {
            border-radius: 4px 0 0 4px;
            font-weight: 400;
            line-height: 21px;
            padding: 2px 10px 3px;
        }
    `);
__publicField(Plans, "collectionOptions", {
  customHeaderArea: (collection) => {
    if (!collection.sidenav) return A;
    return x`<slot name="resultsText"></slot>`;
  },
  headerVisibility: {
    search: false,
    sort: false,
    result: ["mobile", "tablet"],
    custom: ["desktop"]
  }
});

// src/variants/product.js
init_lit();

// src/variants/product.css.js
var CSS6 = `
:root {
  --consonant-merch-card-product-width: 300px;
}

  merch-card[variant="product"] merch-addon {
    padding-left: 4px;
    padding-top: 8px;
    padding-bottom: 8px;
    padding-right: 8px;
    border-radius: .5rem;
    font-family: var(--merch-body-font-family, 'Adobe Clean');
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
  }

  merch-card[variant="product"] merch-addon [is="inline-price"] {
    font-weight: bold;
    pointer-events: none;
  }

  merch-card[variant="product"] merch-addon::part(checkbox) {
      height: 18px;
      width: 18px;
      margin: 14px 12px 0 8px;
  }

  merch-card[variant="product"] merch-addon::part(label) {
    display: flex;
    flex-direction: column;
    padding: 8px 4px 8px 0;
    width: 100%;
  }

/* grid style for product */
.one-merch-card.product,
.two-merch-cards.product,
.three-merch-cards.product,
.four-merch-cards.product {
    grid-template-columns: var(--consonant-merch-card-product-width);
}

/* Tablet */
@media screen and ${TABLET_UP} {
    .two-merch-cards.product,
    .three-merch-cards.product,
    .four-merch-cards.product {
        grid-template-columns: repeat(2, var(--consonant-merch-card-product-width));
    }
}

/* desktop */
@media screen and ${DESKTOP_UP} {
  :root {
    --consonant-merch-card-product-width: 378px;
    --consonant-merch-card-product-width-4clm: 276px;
  }
    
  .three-merch-cards.product {
      grid-template-columns: repeat(3, var(--consonant-merch-card-product-width));
  }

  .four-merch-cards.product {
      grid-template-columns: repeat(4, var(--consonant-merch-card-product-width-4clm));
  }
}
`;

// src/variants/product.js
var Product = class extends VariantLayout {
  constructor(card) {
    super(card);
    this.postCardUpdateHook = this.postCardUpdateHook.bind(this);
  }
  getGlobalCSS() {
    return CSS6;
  }
  adjustProductBodySlots() {
    if (this.card.getBoundingClientRect().width === 0) return;
    const slots = [
      "heading-xs",
      "body-xxs",
      "body-xs",
      "promo-text",
      "callout-content",
      "addon",
      "body-lower"
    ];
    slots.forEach(
      (slot) => this.updateCardElementMinHeight(
        this.card.shadowRoot.querySelector(`slot[name="${slot}"]`),
        slot
      )
    );
  }
  renderLayout() {
    return x` ${this.badge}
            <div class="body" aria-live="polite">
                <slot name="icons"></slot>
                <slot name="heading-xs"></slot>
                <slot name="body-xxs"></slot>
                ${!this.promoBottom ? x`<slot name="promo-text"></slot>` : ""}
                <slot name="body-xs"></slot>
                ${this.promoBottom ? x`<slot name="promo-text"></slot>` : ""}
                <slot name="callout-content"></slot>
                <slot name="addon"></slot>
                <slot name="body-lower"></slot>
            </div>
            ${this.secureLabelFooter}`;
  }
  connectedCallbackHook() {
    window.addEventListener("resize", this.postCardUpdateHook);
  }
  disconnectedCallbackHook() {
    window.removeEventListener("resize", this.postCardUpdateHook);
  }
  postCardUpdateHook() {
    if (!this.card.isConnected) return;
    this.adjustAddon();
    if (!isMobile()) {
      this.adjustProductBodySlots();
    }
    this.adjustTitleWidth();
  }
  get headingXSSlot() {
    return this.card.shadowRoot.querySelector('slot[name="heading-xs"]').assignedElements()[0];
  }
  get mainPrice() {
    const price2 = this.card.querySelector(
      `[slot="heading-xs"] ${SELECTOR_MAS_INLINE_PRICE}[data-template="price"]`
    );
    return price2;
  }
  toggleAddon(merchAddon) {
    const mainPrice = this.mainPrice;
    const headingXSSlot = this.headingXSSlot;
    if (!mainPrice && headingXSSlot) {
      const planType = merchAddon?.getAttribute("plan-type");
      let visibleSpan = null;
      if (merchAddon && planType) {
        const matchingP = merchAddon.querySelector(
          `p[data-plan-type="${planType}"]`
        );
        visibleSpan = matchingP?.querySelector(
          'span[is="inline-price"]'
        );
      }
      this.card.querySelectorAll('p[slot="heading-xs"]').forEach((p2) => p2.remove());
      if (merchAddon.checked) {
        if (visibleSpan) {
          const replacementP = createTag(
            "p",
            {
              class: "addon-heading-xs-price-addon",
              slot: "heading-xs"
            },
            visibleSpan.innerHTML
          );
          this.card.appendChild(replacementP);
        }
      } else {
        const freeP = createTag(
          "p",
          { class: "card-heading", id: "free", slot: "heading-xs" },
          "Free"
        );
        this.card.appendChild(freeP);
      }
    }
  }
  async adjustAddon() {
    await this.card.updateComplete;
    const addon = this.card.addon;
    if (!addon) return;
    const price2 = this.mainPrice;
    let planType = this.card.planType;
    if (price2) {
      await price2.onceSettled();
      planType = price2.value?.[0]?.planType;
    }
    if (!planType) return;
    addon.planType = planType;
  }
};
__publicField(Product, "variantStyle", i`
        :host([variant='product']) > slot:not([name='icons']) {
            display: block;
        }
        :host([variant='product']) slot[name='body-xs'] {
            min-height: var(--consonant-merch-card-product-body-xs-height);
            display: block;
        }
        :host([variant='product']) slot[name='heading-xs'] {
            min-height: var(--consonant-merch-card-product-heading-xs-height);
            display: block;
        }
        :host([variant='product']) slot[name='body-xxs'] {
            min-height: var(--consonant-merch-card-product-body-xxs-height);
            display: block;
        }
        :host([variant='product']) slot[name='promo-text'] {
            min-height: var(--consonant-merch-card-product-promo-text-height);
            display: block;
        }
        :host([variant='product']) slot[name='callout-content'] {
            min-height: var(
                --consonant-merch-card-product-callout-content-height
            );
            display: block;
        }
        :host([variant='product']) slot[name='addon'] {
            min-height: var(--consonant-merch-card-product-addon-height);
        }

        :host([variant='product']) ::slotted([slot='heading-xs']) {
            max-width: var(--consonant-merch-card-heading-xs-max-width, 100%);
        }
    `);

// src/variants/segment.js
init_lit();

// src/variants/segment.css.js
var CSS7 = `
:root {
  --consonant-merch-card-segment-width: 378px;
}

/* grid style for segment */
.one-merch-card.segment,
.two-merch-cards.segment,
.three-merch-cards.segment,
.four-merch-cards.segment {
  grid-template-columns: minmax(276px, var(--consonant-merch-card-segment-width));
}

/* Mobile */
@media screen and ${MOBILE_LANDSCAPE} {
  :root {
    --consonant-merch-card-segment-width: 276px;
  }
}

@media screen and ${TABLET_UP} {
  :root {
    --consonant-merch-card-segment-width: 276px;
  }
    
  .two-merch-cards.segment,
  .three-merch-cards.segment,
  .four-merch-cards.segment {
      grid-template-columns: repeat(2, minmax(276px, var(--consonant-merch-card-segment-width)));
  }
}

/* desktop */
@media screen and ${DESKTOP_UP} {
  :root {
    --consonant-merch-card-segment-width: 302px;
  }
    
  .three-merch-cards.segment {
      grid-template-columns: repeat(3, minmax(276px, var(--consonant-merch-card-segment-width)));
  }

  .four-merch-cards.segment {
      grid-template-columns: repeat(4, minmax(276px, var(--consonant-merch-card-segment-width)));
  }
}
`;

// src/variants/segment.js
var Segment = class extends VariantLayout {
  constructor(card) {
    super(card);
  }
  getGlobalCSS() {
    return CSS7;
  }
  postCardUpdateHook() {
    this.adjustTitleWidth();
  }
  renderLayout() {
    return x` ${this.badge}
            <div class="body">
                <slot name="heading-xs"></slot>
                <slot name="body-xxs"></slot>
                ${!this.promoBottom ? x`<slot name="promo-text"></slot
                          ><slot name="callout-content"></slot>` : ""}
                <slot name="body-xs"></slot>
                ${this.promoBottom ? x`<slot name="promo-text"></slot
                          ><slot name="callout-content"></slot>` : ""}
            </div>
            <hr />
            ${this.secureLabelFooter}`;
  }
};
__publicField(Segment, "variantStyle", i`
        :host([variant='segment']) {
            min-height: 214px;
        }
        :host([variant='segment']) ::slotted([slot='heading-xs']) {
            max-width: var(--consonant-merch-card-heading-xs-max-width, 100%);
        }
    `);

// src/variants/special-offer.js
init_lit();

// src/variants/special-offer.css.js
var CSS8 = `
:root {
  --consonant-merch-card-special-offers-width: 378px;
}

merch-card[variant="special-offers"] span[is="inline-price"][data-template="strikethrough"] {
  font-size: var(--consonant-merch-card-body-xs-font-size);
}

/* grid style for special-offers */
.one-merch-card.special-offers,
.two-merch-cards.special-offers,
.three-merch-cards.special-offers,
.four-merch-cards.special-offers {
  grid-template-columns: minmax(300px, var(--consonant-merch-card-special-offers-width));
}

@media screen and ${MOBILE_LANDSCAPE} {
  :root {
    --consonant-merch-card-special-offers-width: 302px;
  }
} 
  
@media screen and ${TABLET_UP} {
  :root {
    --consonant-merch-card-special-offers-width: 302px;
  }
    
  .two-merch-cards.special-offers,
  .three-merch-cards.special-offers,
  .four-merch-cards.special-offers {
      grid-template-columns: repeat(2, minmax(300px, var(--consonant-merch-card-special-offers-width)));
  }
}

/* desktop */
@media screen and ${DESKTOP_UP} {
  .three-merch-cards.special-offers,
  .four-merch-cards.special-offers {
    grid-template-columns: repeat(3, minmax(300px, var(--consonant-merch-card-special-offers-width)));
  }
}

@media screen and ${LARGE_DESKTOP} {
  .four-merch-cards.special-offers {
    grid-template-columns: repeat(4, minmax(300px, var(--consonant-merch-card-special-offers-width)));
  }
}
`;

// src/variants/special-offer.js
var SPECIAL_OFFERS_AEM_FRAGMENT_MAPPING = {
  name: { tag: "h4", slot: "detail-m" },
  title: { tag: "h4", slot: "detail-m" },
  backgroundImage: { tag: "div", slot: "bg-image" },
  prices: { tag: "h3", slot: "heading-xs" },
  description: { tag: "div", slot: "body-xs" },
  ctas: { slot: "footer", size: "l" }
};
var SpecialOffer = class extends VariantLayout {
  constructor(card) {
    super(card);
  }
  getGlobalCSS() {
    return CSS8;
  }
  get headingSelector() {
    return '[slot="detail-m"]';
  }
  renderLayout() {
    return x`${this.cardImage}
            <div class="body">
                <slot name="detail-m"></slot>
                <slot name="heading-xs"></slot>
                <slot name="body-xs"></slot>
            </div>
            ${this.evergreen ? x`
                      <div
                          class="detail-bg-container"
                          style="background: ${this.card["detailBg"]}"
                      >
                          <slot name="detail-bg"></slot>
                      </div>
                  ` : x`
                      <hr />
                      ${this.secureLabelFooter}
                  `}
            <slot></slot>`;
  }
};
__publicField(SpecialOffer, "variantStyle", i`
        :host([variant='special-offers']) {
            min-height: 439px;
        }

        :host([variant='special-offers']) {
            width: var(--consonant-merch-card-special-offers-width);
        }

        :host([variant='special-offers'].center) {
            text-align: center;
        }
    `);

// src/variants/simplified-pricing-express.js
init_lit();

// src/variants/simplified-pricing-express.css.js
var CSS9 = `
:root {
    --merch-card-simplified-pricing-express-width: 311px;
}

merch-card[variant="simplified-pricing-express"] merch-badge {
    white-space: nowrap;
    color: var(--spectrum-white);
    font-size: var(--consonant-merch-card-detail-m-font-size);
    line-height: var(--consonant-merch-card-detail-m-line-height);
}

/* Grid layout for simplified-pricing-express cards */
merch-card-collection.simplified-pricing-express {
    display: grid;
    justify-content: center;
    justify-items: center;
    align-items: stretch;
    gap: 16px;
    /* Default to 1 column on mobile */
    grid-template-columns: 1fr;
}

/* Also support direct merch-card children and wrapped in p tags */
merch-card-collection.simplified-pricing-express p {
    margin: 0;
    font-size: inherit;
}

/* Desktop - 3 columns */
@media screen and ${DESKTOP_UP} {
    merch-card-collection.simplified-pricing-express {
        grid-template-columns: repeat(3, 1fr);
        max-width: calc(3 * var(--merch-card-simplified-pricing-express-width) + 32px);
        margin: 0 auto;
    }
}

merch-card[variant="simplified-pricing-express"] p {
    margin: 0 !important; /* needed to override express-milo default margin to all <p> */
    font-size: inherit;
}

merch-card[variant="simplified-pricing-express"] [slot="heading-xs"] {
    font-size: 18px;
    font-weight: 700;
    line-height: 23.4px;
    color: var(--spectrum-gray-800);
}

merch-card[variant="simplified-pricing-express"] [slot="body-xs"] {
    font-size: var(--merch-card-simplified-pricing-express-body-xs-font-size, 14px);
    line-height: var(--merch-card-simplified-pricing-express-body-xs-line-height, 18.2px);
    color: var(--spectrum-gray-700);
    margin-bottom: 32px;
}

merch-card[variant="simplified-pricing-express"] [slot="cta"] {
    display: block;
    width: 100%;
}

merch-card[variant="simplified-pricing-express"] [slot="cta"] sp-button,
merch-card[variant="simplified-pricing-express"] [slot="cta"] button,
merch-card[variant="simplified-pricing-express"] [slot="cta"] a.button {
    display: block;
    width: 100%;
    box-sizing: border-box;
    font-weight: var(--merch-card-simplified-pricing-express-cta-font-weight);
    line-height: var(--merch-card-simplified-pricing-express-cta-line-height);
    font-size: var(--merch-card-simplified-pricing-express-cta-font-size);
    margin: 0;
    padding: 12px 24px 13px 24px;
    border-radius: 26px;
}

merch-card[variant="simplified-pricing-express"] [slot="price"] {
  display: flex;
  flex-direction: column;
  margin-bottom: var(--merch-card-simplified-pricing-express-padding);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"]:first-child {
  margin-inline-end: 8px;
}

merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child {
  display: flex;
  align-items: baseline;
  margin: 0;
}

merch-card[variant="simplified-pricing-express"] [slot="price"] span[is="inline-price"] {
  font-size: var(--merch-card-simplified-pricing-express-price-p-font-size);
  line-height: var(--merch-card-simplified-pricing-express-price-p-line-height);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"] {
  font-size: var(--merch-card-simplified-pricing-express-price-font-size);
  line-height: var(--merch-card-simplified-pricing-express-price-line-height);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] span[is="inline-price"][data-template="optical"] {
  font-size: var(--merch-card-simplified-pricing-express-price-font-size);
  color: var(--spectrum-gray-800);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] p {
  font-size: var(--merch-card-simplified-pricing-express-price-p-font-size);
  font-weight: var(--merch-card-simplified-pricing-express-price-p-font-weight);
  line-height: var(--merch-card-simplified-pricing-express-price-p-line-height);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] p:empty {
  min-height: var(--merch-card-simplified-pricing-express-price-p-line-height);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child .price-currency-symbol {
  font-size: var(--merch-card-simplified-pricing-express-price-font-size);
  font-weight: var(--merch-card-simplified-pricing-express-price-font-weight);
  line-height: var(--merch-card-simplified-pricing-express-price-line-height);
  width: 100%;
}

merch-card[variant="simplified-pricing-express"] [slot="price"] .price-currency-symbol {
  font-size: var(--merch-card-simplified-pricing-express-price-p-font-size);
  font-weight: var(--merch-card-simplified-pricing-express-price-p-font-weight);
  line-height: var(--merch-card-simplified-pricing-express-price-p-line-height);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] span[is="inline-price"] .price-recurrence {
  font-size: var(--merch-card-simplified-pricing-express-price-recurrence-font-size);
  font-weight: var(--merch-card-simplified-pricing-express-price-recurrence-font-weight);
  line-height: var(--merch-card-simplified-pricing-express-price-recurrence-line-height);
}

/* Strikethrough price styling */
merch-card[variant="simplified-pricing-express"] span[is="inline-price"][data-template='strikethrough'] .price,
merch-card[variant="simplified-pricing-express"] span[is="inline-price"][data-template='strikethrough'] .price-strikethrough,
merch-card[variant="simplified-pricing-express"] span.placeholder-resolved[data-template='strikethrough'] {
  text-decoration: none;
  font-size: var(--merch-card-simplified-pricing-express-price-p-font-size);
  line-height: var(--merch-card-simplified-pricing-express-price-p-line-height);
}

merch-card[variant="simplified-pricing-express"] span[is="inline-price"][data-template='strikethrough'] .price {
  color: var(--spectrum-gray-500);
}

merch-card[variant="simplified-pricing-express"] [slot="price"] p a {
  color: var(--spectrum-indigo-900);
  font-weight: 500;
  text-decoration: underline;
  white-space: nowrap;
}

merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"] .price-integer,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"] .price-decimals-delimiter,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"] .price-decimals {
  font-size: 28px;
  font-weight: 700;
  line-height: 36.4px;
  text-decoration-thickness: 2px;
}

merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"][data-template='strikethrough'] .price-integer,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"][data-template='strikethrough'] .price-decimals-delimiter,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:first-child span[is="inline-price"][data-template='strikethrough'] .price-decimals {
  text-decoration: line-through;
}

/* Apply indigo-800 color to optical price when preceded by strikethrough */
merch-card[variant="simplified-pricing-express"] span[is="inline-price"][data-template='strikethrough'] + span[is="inline-price"][data-template='optical'],
merch-card[variant="simplified-pricing-express"] span[is="inline-price"][data-template='strikethrough'] + span[is="inline-price"][data-template='optical'] .price-currency-symbol {
  color: var(--spectrum-indigo-900);
}

/* Ensure non-first paragraph prices have normal font weight */
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:not(:first-child) span[is="inline-price"] .price-integer,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:not(:first-child) span[is="inline-price"] .price-decimals-delimiter,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:not(:first-child) span[is="inline-price"] .price-decimals,
merch-card[variant="simplified-pricing-express"] [slot="price"] > p:not(:first-child) span[is="inline-price"] .price-recurrence {
  font-size: var(--merch-card-simplified-pricing-express-price-p-font-size);
  font-weight: var(--merch-card-simplified-pricing-express-price-p-font-weight);
  line-height: var(--merch-card-simplified-pricing-express-price-p-line-height);
}

/* Hide screen reader only text */
merch-card[variant="simplified-pricing-express"] sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* mas-mnemonic inline styles for simplified-pricing-express */
merch-card[variant="simplified-pricing-express"] mas-mnemonic {
    display: inline-block;
    align-items: center;
    vertical-align: baseline;
    margin-inline-end: 8px;
    overflow: visible;
    padding-top: 16px;
}

/* Tooltip containers - overflow handled by Shadow DOM */

/* Mobile styles */
@media screen and ${MOBILE_LANDSCAPE} {
  merch-card-collection.simplified-pricing-express {
    gap: 8px;
  }
  
  merch-card[variant="simplified-pricing-express"] {
    width: 311px;
    max-width: 311px;
  }

  /* Badge alignment on mobile */
  merch-card[variant="simplified-pricing-express"] [slot="badge"] {
    font-size: 16px;
    font-weight: 400;
  }

  /* Trial badge alignment on mobile */
  merch-card[variant="simplified-pricing-express"] [slot="trial-badge"] {
    margin-left: 0;
    align-self: flex-start;
  }
  
  merch-card[variant="simplified-pricing-express"] [slot="trial-badge"] merch-badge {
    font-size: 12px;
    line-height: 20.8px;
  }

  /* Fix spacing between cards on mobile */
  main merch-card-collection.simplified-pricing-express p:has(merch-card[variant="simplified-pricing-express"]),
  main .section p:has(merch-card[variant="simplified-pricing-express"]) {
    margin: 0;
  }
}

/* Collapse/expand styles for all tablet and mobile viewports */
@media screen and ${TABLET_DOWN} {
  /* Collapsed state - hide content sections */
  merch-card[variant="simplified-pricing-express"]:not([data-expanded="true"]) [slot="body-xs"],
  merch-card[variant="simplified-pricing-express"]:not([data-expanded="true"]) [slot="price"],
  merch-card[variant="simplified-pricing-express"]:not([data-expanded="true"]) [slot="cta"],
  merch-card[variant="simplified-pricing-express"][data-expanded="false"] [slot="body-xs"],
  merch-card[variant="simplified-pricing-express"][data-expanded="false"] [slot="price"],
  merch-card[variant="simplified-pricing-express"][data-expanded="false"] [slot="cta"] {
    display: none;
    visibility: hidden;
    height: 0;
    margin: 0;
    padding: 0;
  }

  /* Expanded state - explicitly show content */
  merch-card[variant="simplified-pricing-express"][data-expanded="true"] [slot="body-xs"],
  merch-card[variant="simplified-pricing-express"][data-expanded="true"] [slot="price"],
  merch-card[variant="simplified-pricing-express"][data-expanded="true"] [slot="cta"] {
    display: block;
    visibility: visible;
    height: auto;
  }

  /* Collapsed card should have fixed height and padding */
  merch-card[variant="simplified-pricing-express"][data-expanded="false"],
  merch-card[variant="simplified-pricing-express"]:not([data-expanded="true"]) {
    max-height: 57px;
    padding: 0;
    overflow: hidden;
    border-radius: 8px;
  }

  merch-card[variant="simplified-pricing-express"][gradient-border="true"][data-expanded="false"],
  merch-card[variant="simplified-pricing-express"][gradient-border="true"]:not([data-expanded="true"]) {
    max-height: 85px;
  }
}

/* Tablet styles - extending mobile styles with specific adjustments */
@media screen and ${TABLET_UP} and ${TABLET_DOWN} {
  merch-card-collection.simplified-pricing-express {
    padding: var(--spacing-m) 32px;
    grid-template-columns: 1fr;
    gap: 24px;
    width: var(--merch-card-simplified-pricing-express-tablet-width);
    margin: 0 auto;
  }
  
  merch-card[variant="simplified-pricing-express"] {
      min-width: var(--merch-card-simplified-pricing-express-tablet-width);
  }
}

merch-card[variant="simplified-pricing-express"] [slot="cta"] sp-button[variant="accent"],
merch-card[variant="simplified-pricing-express"] [slot="cta"] button.spectrum-Button--accent,
merch-card[variant="simplified-pricing-express"] [slot="cta"] a.spectrum-Button.spectrum-Button--accent {
    background-color: var(--spectrum-indigo-900);
    color: var(--spectrum-white, #ffffff);
    width: 100%;
}

/* Ensure text color is applied to the label span element for accessibility */
merch-card[variant="simplified-pricing-express"] [slot="cta"] sp-button[variant="accent"] .spectrum-Button-label,
merch-card[variant="simplified-pricing-express"] [slot="cta"] button.spectrum-Button--accent .spectrum-Button-label,
merch-card[variant="simplified-pricing-express"] [slot="cta"] a.spectrum-Button.spectrum-Button--accent .spectrum-Button-label {
    color: var(--spectrum-white, #ffffff);
}
`;

// src/variants/simplified-pricing-express.js
var isTabletOrBelow = () => window.matchMedia(TABLET_DOWN).matches;
var SIMPLIFIED_PRICING_EXPRESS_AEM_FRAGMENT_MAPPING = {
  title: {
    tag: "h3",
    slot: "heading-xs",
    maxCount: 250,
    withSuffix: true
  },
  badge: {
    tag: "div",
    slot: "badge",
    default: "spectrum-blue-400"
  },
  allowedBadgeColors: [
    "spectrum-blue-400",
    "spectrum-gray-300",
    "spectrum-yellow-300",
    "gradient-purple-blue",
    "gradient-firefly-spectrum"
  ],
  description: {
    tag: "div",
    slot: "body-xs",
    maxCount: 2e3,
    withSuffix: false
  },
  prices: {
    tag: "div",
    slot: "price"
  },
  ctas: {
    slot: "cta",
    size: "XL"
  },
  borderColor: {
    attribute: "border-color",
    specialValues: {
      gray: "var(--spectrum-gray-300)",
      blue: "var(--spectrum-blue-400)",
      "gradient-purple-blue": "linear-gradient(96deg, #B539C8 0%, #7155FA 66%, #3B63FB 100%)",
      "gradient-firefly-spectrum": "linear-gradient(96deg, #D73220 0%, #D92361 33%, #7155FA 100%)"
    }
  },
  disabledAttributes: [
    "badgeColor",
    "badgeBorderColor",
    "trialBadgeColor",
    "trialBadgeBorderColor"
  ],
  supportsDefaultChild: true
};
var SimplifiedPricingExpress = class extends VariantLayout {
  getGlobalCSS() {
    return CSS9;
  }
  get aemFragmentMapping() {
    return SIMPLIFIED_PRICING_EXPRESS_AEM_FRAGMENT_MAPPING;
  }
  get headingSelector() {
    return '[slot="heading-xs"]';
  }
  connectedCallbackHook() {
    if (!this.card || this.card.failed) {
      return;
    }
    this.setupAccordion();
    requestAnimationFrame(() => {
      if (this.card?.hasAttribute("data-default-card") && isTabletOrBelow()) {
        this.card.setAttribute("data-expanded", "true");
      }
    });
  }
  setupAccordion() {
    const merchCard = this.card;
    if (!merchCard) {
      return;
    }
    const updateExpandedState = () => {
      if (isTabletOrBelow()) {
        const isDefaultCard = merchCard.hasAttribute("data-default-card");
        merchCard.setAttribute(
          "data-expanded",
          isDefaultCard ? "true" : "false"
        );
      } else {
        merchCard.removeAttribute("data-expanded");
      }
    };
    updateExpandedState();
    const mediaQuery = window.matchMedia(TABLET_DOWN);
    this.mediaQueryListener = () => {
      updateExpandedState();
    };
    mediaQuery.addEventListener("change", this.mediaQueryListener);
    this.attributeObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && mutation.attributeName === "data-default-card" && this.card.hasAttribute("data-default-card") && isTabletOrBelow()) {
          this.card.setAttribute("data-expanded", "true");
        }
      });
    });
    this.attributeObserver.observe(this.card, {
      attributes: true,
      attributeOldValue: true
    });
  }
  disconnectedCallbackHook() {
    if (this.mediaQueryListener) {
      const mediaQuery = window.matchMedia(TABLET_DOWN);
      mediaQuery.removeEventListener("change", this.mediaQueryListener);
    }
    if (this.attributeObserver) {
      this.attributeObserver.disconnect();
    }
  }
  handleChevronClick(e4) {
    e4.preventDefault();
    e4.stopPropagation();
    const merchCard = this.card;
    if (!merchCard || !isTabletOrBelow()) {
      return;
    }
    const currentExpanded = merchCard.getAttribute("data-expanded");
    const isExpanded = currentExpanded === "true";
    const newExpanded = !isExpanded ? "true" : "false";
    merchCard.setAttribute("data-expanded", newExpanded);
  }
  renderLayout() {
    return x`
            <div class="badge-wrapper">
                <slot name="badge"></slot>
            </div>
            <div class="card-content">
                <div class="header">
                    <slot name="heading-xs"></slot>
                    <slot name="trial-badge"></slot>
                    <button
                        class="chevron-button"
                        @click=${(e4) => this.handleChevronClick(e4)}
                    >
                        <svg
                            class="chevron-icon"
                            width="24"
                            height="24"
                            viewBox="0 0 24 24"
                            fill="none"
                            xmlns="http://www.w3.org/2000/svg"
                        >
                            <path
                                d="M12 15.5L5 8.5L6.4 7.1L12 12.7L17.6 7.1L19 8.5L12 15.5Z"
                                fill="currentColor"
                            />
                        </svg>
                    </button>
                </div>
                <div class="description">
                    <slot name="body-xs"></slot>
                </div>
                <div class="price">
                    <slot name="price"></slot>
                </div>
                <div class="cta">
                    <slot name="cta"></slot>
                </div>
            </div>
            <slot></slot>
        `;
  }
};
__publicField(SimplifiedPricingExpress, "variantStyle", i`
        :host([variant='simplified-pricing-express']) {
            /* CSS Variables */
            --merch-card-simplified-pricing-express-width: 365px;
            --merch-card-simplified-pricing-express-tablet-width: 532px;
            --merch-card-simplified-pricing-express-padding: 24px;
            --merch-card-simplified-pricing-express-padding-mobile: 16px;
            --merch-card-simplified-pricing-express-min-height: 341px;
            --merch-card-simplified-pricing-express-price-font-size: 28px;
            --merch-card-simplified-pricing-express-price-p-font-size: 12px;
            --merch-card-simplified-pricing-express-price-p-line-height: 15.6px;
            --merch-card-simplified-pricing-express-price-font-weight: 700;
            --merch-card-simplified-pricing-express-price-line-height: 36.4px;
            --merch-card-simplified-pricing-express-price-currency-font-size: 22px;
            --merch-card-simplified-pricing-express-price-currency-font-weight: 700;
            --merch-card-simplified-pricing-express-price-currency-line-height: 28.6px;
            --merch-card-simplified-pricing-express-price-currency-symbol-font-size: 22px;
            --merch-card-simplified-pricing-express-price-currency-symbol-font-weight: 700;
            --merch-card-simplified-pricing-express-price-currency-symbol-line-height: 28.6px;
            --merch-card-simplified-pricing-express-price-recurrence-font-size: 12px;
            --merch-card-simplified-pricing-express-price-recurrence-font-weight: 700;
            --merch-card-simplified-pricing-express-price-recurrence-line-height: 15.6px;
            --merch-card-simplified-pricing-express-body-xs-font-size: 14px;
            --merch-card-simplified-pricing-express-body-xs-line-height: 18.2px;
            --merch-card-simplified-pricing-express-price-p-font-size: 12px;
            --merch-card-simplified-pricing-express-price-p-font-weight: 400;
            --merch-card-simplified-pricing-express-price-p-line-height: 15.6px;
            --merch-card-simplified-pricing-express-cta-font-size: 18px;
            --merch-card-simplified-pricing-express-cta-font-weight: 700;
            --merch-card-simplified-pricing-express-cta-line-height: 23.4px;

            /* Gradient definitions */
            --gradient-purple-blue: linear-gradient(
                96deg,
                #b539c8 0%,
                #7155fa 66%,
                #3b63fb 100%
            );
            --gradient-firefly-spectrum: linear-gradient(
                96deg,
                #d73220 0%,
                #d92361 33%,
                #7155fa 100%
            );
            width: var(--merch-card-simplified-pricing-express-width);
            max-width: var(--merch-card-simplified-pricing-express-width);
            background: transparent;
            border: none;
            display: flex;
            flex-direction: column;
            overflow: visible;
            box-sizing: border-box;
            position: relative;
        }

        /* Badge wrapper styling */
        :host([variant='simplified-pricing-express']) .badge-wrapper {
            padding: 4px 12px;
            border-radius: 8px 8px 0 0;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
            line-height: 15.6px;
            color: var(--spectrum-gray-800);
            position: relative;
            min-height: 23px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hide badge wrapper when empty */
        :host([variant='simplified-pricing-express']) .badge-wrapper:empty {
            display: none;
        }

        /* Also hide when badge slot is empty */
        :host(
                [variant='simplified-pricing-express']:not(
                        :has([slot='badge']:not(:empty))
                    )
            )
            .badge-wrapper {
            display: none;
        }

        /* Card content styling */
        :host([variant='simplified-pricing-express']) .card-content {
            border-radius: 8px;
            padding: var(--merch-card-simplified-pricing-express-padding);
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--consonant-merch-spacing-xxs);
            position: relative;
        }

        /* Ensure content appears above pseudo-element background */
        :host([variant='simplified-pricing-express']) .card-content > * {
            position: relative;
        }

        :host(
                [variant='simplified-pricing-express']:not(
                        [gradient-border='true']
                    )
            )
            .card-content {
            background: var(--spectrum-gray-50);
            border: 1px solid
                var(
                    --consonant-merch-card-border-color,
                    var(--spectrum-gray-100)
                );
        }

        /* Collapsed state for non-gradient cards */
        :host(
                [variant='simplified-pricing-express']:not(
                        [gradient-border='true']
                    )[data-expanded='false']
            )
            .card-content {
            overflow: hidden;
        }

        /* When badge exists, adjust card content border radius */
        :host(
                [variant='simplified-pricing-express']:has(
                        [slot='badge']:not(:empty)
                    )
            )
            .card-content {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        /* When badge exists with regular border, ensure top border */
        :host(
                [variant='simplified-pricing-express']:not(
                        [gradient-border='true']
                    ):has([slot='badge']:not(:empty))
            )
            .card-content {
            border-top: 1px solid
                var(
                    --consonant-merch-card-border-color,
                    var(--spectrum-gray-100)
                );
        }

        /* When badge has content, ensure seamless connection */
        :host(
                [variant='simplified-pricing-express']:has(
                        [slot='badge']:not(:empty)
                    )
            )
            .badge-wrapper {
            margin-bottom: -2px;
        }

        /* Common gradient border styles */
        :host([variant='simplified-pricing-express'][gradient-border='true'])
            .badge-wrapper {
            border: none;
            margin-bottom: -6px;
            padding-bottom: 6px;
        }

        :host([variant='simplified-pricing-express'][gradient-border='true'])
            .badge-wrapper
            ::slotted(*) {
            color: white !important;
        }

        :host([variant='simplified-pricing-express'][gradient-border='true'])
            .card-content {
            position: relative;
            border: none;
            padding: calc(
                var(--merch-card-simplified-pricing-express-padding) + 2px
            );
            border-radius: 8px;
        }

        :host([variant='simplified-pricing-express'][gradient-border='true'])
            .card-content::before {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            background: var(--spectrum-gray-50);
            border-radius: 7px;
            z-index: 0;
            pointer-events: none;
        }

        /* Gradient-specific backgrounds */
        :host(
                [variant='simplified-pricing-express'][border-color='gradient-purple-blue']
            )
            .badge-wrapper,
        :host(
                [variant='simplified-pricing-express'][border-color='gradient-purple-blue']
            )
            .card-content {
            background: var(--gradient-purple-blue);
        }

        :host(
                [variant='simplified-pricing-express'][border-color='gradient-firefly-spectrum']
            )
            .badge-wrapper,
        :host(
                [variant='simplified-pricing-express'][border-color='gradient-firefly-spectrum']
            )
            .card-content {
            background: var(--gradient-firefly-spectrum);
        }

        /* When gradient and badge exist, keep rounded corners for smooth transition */
        :host(
                [variant='simplified-pricing-express'][gradient-border='true']:has(
                        [slot='badge']:not(:empty)
                    )
            )
            .card-content {
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        :host(
                [variant='simplified-pricing-express'][gradient-border='true']:has(
                        [slot='badge']:not(:empty)
                    )
            )
            .card-content::before {
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
        }

        :host([variant='simplified-pricing-express']) .header {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: space-between;
            gap: 8px;
        }

        /* Font specifications for heading and body */
        :host([variant='simplified-pricing-express']) [slot='heading-xs'] {
            font-size: 18px;
            font-weight: 700;
            line-height: 23.4px;
            color: var(--spectrum-gray-800);
        }

        :host([variant='simplified-pricing-express']) .description {
            gap: 16px;
            display: flex;
            flex-direction: column;
        }

        :host([variant='simplified-pricing-express']) .price {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            margin-top: auto;
        }

        /* Desktop only - Fixed heights for alignment */
        @media (min-width: 1200px) {
            :host([variant='simplified-pricing-express']) {
                display: flex;
                flex-direction: column;
                height: auto;
            }

            :host([variant='simplified-pricing-express']) .cta {
                flex-shrink: 0;
            }
        }

        :host([variant='simplified-pricing-express']) .cta,
        :host([variant='simplified-pricing-express']) .cta ::slotted(*) {
            width: 100%;
            display: block;
        }

        /* Mobile accordion styles */
        :host([variant='simplified-pricing-express']) .chevron-button {
            display: none;
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        :host([variant='simplified-pricing-express']) .chevron-icon {
            width: 24px;
            height: 24px;
            color: var(--spectrum-gray-800);
            transition: transform 0.3s ease;
        }

        /* Chevron rotation based on parent card's data-expanded attribute */
        :host-context(merch-card[data-expanded='false']) .chevron-icon {
            transform: rotate(0deg);
        }
        :host-context(merch-card[data-expanded='true']) .chevron-icon {
            transform: rotate(180deg);
        }

        /* Mobile and Tablet styles */
        @media (max-width: 1199px) {
            :host([variant='simplified-pricing-express']) {
                width: 311px;
                max-width: 311px;
                min-height: auto;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            :host([variant='simplified-pricing-express']) .header {
                position: relative;
                justify-content: space-between;
                align-items: center;
                gap: 8px;
            }

            :host([variant='simplified-pricing-express']) .chevron-button {
                display: block;
                flex-shrink: 0;
                margin-left: auto;
            }

            :host(
                    [variant='simplified-pricing-express'][gradient-border='true']
                )
                .card-content,
            :host(
                    [variant='simplified-pricing-express']:not(
                            [gradient-border='true']
                        )
                )
                .card-content {
                padding: calc(
                    var(
                            --merch-card-simplified-pricing-express-padding-mobile
                        ) +
                        2px
                );
            }

            /* Hide badge-wrapper on mobile/tablet except for gradient borders */
            :host(
                    [variant='simplified-pricing-express']:not(
                            [gradient-border='true']
                        )
                )
                .badge-wrapper {
                display: none;
            }

            /* Gradient border collapsed state - limit badge-wrapper height */
            :host(
                    [variant='simplified-pricing-express'][gradient-border='true'][data-expanded='false']
                )
                .card-content {
                overflow: hidden;
                padding: 16px 16px 35px 16px;
            }
        }
    `);

// src/variants/mini.js
init_lit();

// src/variants/mini.css.js
var CSS10 = `
merch-card[variant="mini"] {
  color: var(--spectrum-body-color);
  width: 400px;
  height: 250px;
}

merch-card[variant="mini"] .price-tax-inclusivity::before {
  content: initial;
}

merch-card[variant="mini"] [slot="title"] {
    font-size: 16px;
    font-weight: 700;
    line-height: 24px;
}

merch-card[variant="mini"] [slot="legal"] {
    min-height: 17px;
}

merch-card[variant="mini"] [slot="ctas"] {
  display: flex;
  flex: 1;
  gap: 16px;
  align-items: end;
  justify-content: end;
}

merch-card[variant="mini"] span.promo-duration-text,
merch-card[variant="mini"] span.renewal-text {
    display: block;
}
`;

// src/variants/mini.js
var MINI_AEM_FRAGMENT_MAPPING = {
  title: { tag: "p", slot: "title" },
  prices: { tag: "p", slot: "prices" },
  description: {
    tag: "p",
    slot: "description"
  },
  planType: true,
  ctas: { slot: "ctas", size: "S" }
};
var Mini = class extends VariantLayout {
  constructor() {
    super(...arguments);
    __publicField(this, "legal");
  }
  async postCardUpdateHook() {
    await this.card.updateComplete;
    this.adjustLegal();
  }
  getGlobalCSS() {
    return CSS10;
  }
  get headingSelector() {
    return '[slot="title"]';
  }
  priceOptionsProvider(element, options) {
    options.literals = {
      ...options.literals,
      strikethroughAriaLabel: "",
      alternativePriceAriaLabel: ""
    };
    options.space = true;
    options.displayAnnual = this.card.settings?.displayAnnual ?? false;
  }
  adjustLegal() {
    if (this.legal !== void 0) return;
    const price2 = this.card.querySelector(
      `${SELECTOR_MAS_INLINE_PRICE}[data-template="price"]`
    );
    if (!price2) return;
    const legal2 = price2.cloneNode(true);
    this.legal = legal2;
    price2.dataset.displayTax = "false";
    legal2.dataset.template = "legal";
    legal2.dataset.displayPlanType = this.card?.settings?.displayPlanType ?? true;
    legal2.setAttribute("slot", "legal");
    this.card.appendChild(legal2);
  }
  renderLayout() {
    return x`
            ${this.badge}
            <div class="body">
                <slot name="title"></slot>
                <slot name="prices"></slot>
                <slot name="legal"></slot>
                <slot name="description"></slot>
                <slot name="ctas"></slot>
            </div>
        `;
  }
};
__publicField(Mini, "variantStyle", i`
        :host([variant='mini']) {
            min-width: 209px;
            min-height: 103px;
            background-color: var(--spectrum-background-base-color);
            border: 1px solid var(--consonant-merch-card-border-color, #dadada);
        }
    `);

// src/variants/variants.js
var variantRegistry = /* @__PURE__ */ new Map();
var registerVariant = (name, variantClass, fragmentMapping = null, style = null, collectionOptions) => {
  variantRegistry.set(name, {
    class: variantClass,
    fragmentMapping,
    style,
    collectionOptions
  });
};
registerVariant(
  "catalog",
  Catalog,
  CATALOG_AEM_FRAGMENT_MAPPING,
  Catalog.variantStyle
);
registerVariant("image", Image2);
registerVariant("inline-heading", InlineHeading);
registerVariant(
  "mini-compare-chart",
  MiniCompareChart,
  null,
  MiniCompareChart.variantStyle
);
registerVariant(
  "plans",
  Plans,
  PLANS_AEM_FRAGMENT_MAPPING,
  Plans.variantStyle,
  Plans.collectionOptions
);
registerVariant(
  "plans-students",
  Plans,
  PLANS_STUDENTS_AEM_FRAGMENT_MAPPING,
  Plans.variantStyle,
  Plans.collectionOptions
);
registerVariant(
  "plans-education",
  Plans,
  PLANS_EDUCATION_AEM_FRAGMENT_MAPPING,
  Plans.variantStyle,
  Plans.collectionOptions
);
registerVariant("product", Product, null, Product.variantStyle);
registerVariant("segment", Segment, null, Segment.variantStyle);
registerVariant(
  "special-offers",
  SpecialOffer,
  SPECIAL_OFFERS_AEM_FRAGMENT_MAPPING,
  SpecialOffer.variantStyle
);
registerVariant(
  "simplified-pricing-express",
  SimplifiedPricingExpress,
  SIMPLIFIED_PRICING_EXPRESS_AEM_FRAGMENT_MAPPING,
  SimplifiedPricingExpress.variantStyle
);
registerVariant("mini", Mini, MINI_AEM_FRAGMENT_MAPPING, Mini.variantStyle);
var getVariantLayout = (card) => {
  const variantInfo = variantRegistry.get(card.variant);
  if (!variantInfo) {
    return void 0;
  }
  const { class: VariantClass, style } = variantInfo;
  if (style) {
    try {
      const sheet = new CSSStyleSheet();
      sheet.replaceSync(style.cssText);
      card.shadowRoot.adoptedStyleSheets.push(sheet);
    } catch (e4) {
      const styleElement = document.createElement("style");
      styleElement.textContent = style.cssText;
      card.shadowRoot.appendChild(styleElement);
    }
  }
  return new VariantClass(card);
};
function getFragmentMapping(variant) {
  return variantRegistry.get(variant)?.fragmentMapping;
}
function getCollectionOptions(variant) {
  return variantRegistry.get(variant)?.collectionOptions;
}

// src/global.css.js
var styles2 = document.createElement("style");
styles2.innerHTML = `
:root {
    --consonant-merch-card-detail-font-size: 12px;
    --consonant-merch-card-detail-font-weight: 500;
    --consonant-merch-card-detail-letter-spacing: 0.8px;

    --consonant-merch-card-heading-font-size: 18px;
    --consonant-merch-card-heading-line-height: 22.5px;
    --consonant-merch-card-heading-secondary-font-size: 14px;
    --consonant-merch-card-body-font-size: 14px;
    --consonant-merch-card-body-line-height: 21px;
    --consonant-merch-card-promo-text-height: var(--consonant-merch-card-body-font-size);

    /* Fonts */
    --merch-body-font-family: 'Adobe Clean', adobe-clean, 'Trebuchet MS', sans-serif;

    /* spacing */
    --consonant-merch-spacing-xxxs: 4px;
    --consonant-merch-spacing-xxs: 8px;
    --consonant-merch-spacing-xs: 16px;
    --consonant-merch-spacing-s: 24px;
    --consonant-merch-spacing-m: 32px;

    /* cta */
    --consonant-merch-card-cta-font-size: 15px;

    /* headings */
    --consonant-merch-card-heading-xxxs-font-size: 14px;
    --consonant-merch-card-heading-xxxs-line-height: 18px;
    --consonant-merch-card-heading-xxs-font-size: 16px;
    --consonant-merch-card-heading-xxs-line-height: 20px;
    --consonant-merch-card-heading-xs-font-size: 18px;
    --consonant-merch-card-heading-xs-line-height: 22.5px;
    --consonant-merch-card-heading-s-font-size: 20px;
    --consonant-merch-card-heading-s-line-height: 25px;
    --consonant-merch-card-heading-m-font-size: 24px;
    --consonant-merch-card-heading-m-line-height: 30px;
    --consonant-merch-card-heading-l-font-size: 28px;
    --consonant-merch-card-heading-l-line-height: 36.4px;
    --consonant-merch-card-heading-xl-font-size: 32px;
    --consonant-merch-card-heading-xl-line-height: 40px;


    /* detail */
    --consonant-merch-card-detail-xs-line-height: 12px;
    --consonant-merch-card-detail-s-font-size: 11px;
    --consonant-merch-card-detail-s-line-height: 14px;
    --consonant-merch-card-detail-m-font-size: 12px;
    --consonant-merch-card-detail-m-line-height: 15px;
    --consonant-merch-card-detail-m-font-weight: 700;
    --consonant-merch-card-detail-m-letter-spacing: 1px;
    --consonant-merch-card-detail-l-line-height: 18px;
    --consonant-merch-card-detail-l-line-height: 23px;

    /* body */
    --consonant-merch-card-body-xxs-font-size: 12px;
    --consonant-merch-card-body-xxs-line-height: 18px;
    --consonant-merch-card-body-xxs-letter-spacing: 1px;
    --consonant-merch-card-body-xs-font-size: 14px;
    --consonant-merch-card-body-xs-line-height: 21px;
    --consonant-merch-card-body-s-font-size: 16px;
    --consonant-merch-card-body-s-line-height: 24px;
    --consonant-merch-card-body-m-font-size: 18px;
    --consonant-merch-card-body-m-line-height: 27px;
    --consonant-merch-card-body-l-font-size: 20px;
    --consonant-merch-card-body-l-line-height: 30px;
    --consonant-merch-card-body-xl-font-size: 22px;
    --consonant-merch-card-body-xxl-font-size: 24px;
    --consonant-merch-card-body-xl-line-height: 33px;


    --consonant-merch-card-heading-padding: 0;

    /* colors */
    --consonant-merch-card-background-color: inherit;
    --consonant-merch-card-border-color: #eaeaea;
    --color-accent: rgb(59, 99, 251);
    --merch-color-focus-ring: #1473E6;
    --merch-color-grey-10: #f6f6f6;
    --merch-color-grey-50: var(--spectrum-gray-50);
    --merch-color-grey-60: var(--spectrum-gray-600);
    --merch-color-grey-80: #2c2c2c;
    --merch-color-grey-200: #E8E8E8;
    --merch-color-grey-600: #686868;
    --merch-color-grey-700: #464646;
    --merch-color-grey-800: #222222;
    --merch-color-green-promo: #05834E;
    --merch-color-red-promo: #D31510;
    --merch-color-grey-80: #2c2c2c;
    --consonant-merch-card-body-xs-color: var(--spectrum-gray-800, var(--merch-color-grey-80));
    --merch-color-inline-price-strikethrough: initial;
    --consonant-merch-card-detail-s-color: var(--spectrum-gray-600, var(--merch-color-grey-600));
    --consonant-merch-card-heading-color: var(--spectrum-gray-800, var(--merch-color-grey-80));
    --consonant-merch-card-heading-xs-color: var(--consonant-merch-card-heading-color);
    --consonant-merch-card-price-color: #222222;
    --consonant-merch-card-heading-xxxs-color: #131313;
    --consonant-merch-card-body-xxs-color: #292929;

    /* ccd colors */
    --ccd-gray-200-light: #E6E6E6;
    --ccd-gray-800-dark: #222;
    --ccd-gray-700-dark: #464646;
    --ccd-gray-600-light: #6D6D6D;

    /* ah colors */
    --ah-gray-500: #717171;
    --fuchsia: #FDE9FF;

    /* plans colors */
    --spectrum-yellow-300-plans: #F5C700;
    --spectrum-green-900-plans: #05834E;
    --spectrum-gray-300-plans: #DADADA;
    --spectrum-gray-700-plans: #505050;

    /* simplified-pricing-express colors */
    --spectrum-gray-50: #FFFFFF;
    --spectrum-gray-100: #F8F8F8;
    --spectrum-gray-200: #E6E6E6;
    --spectrum-gray-300: #D5D5D5;
    --spectrum-gray-400: #B8B8B8;
    --spectrum-gray-500: #909090;
    --spectrum-gray-600: #6D6D6D;
    --spectrum-gray-700: #494949;
    --spectrum-gray-800: #2C2C2C;
    --spectrum-gray-900: #1C1C1C;
    --spectrum-indigo-900: #5258E4;
  
    /* merch card generic */
    --consonant-merch-card-max-width: 300px;
    --transition: cmax-height 0.3s linear, opacity 0.3s linear;

    /* background image */
    --consonant-merch-card-bg-img-height: 180px;

    /* inline SVGs */
    --checkmark-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 10 10'%3E%3Cpath fill='%23fff' d='M3.788 9A.999.999 0 0 1 3 8.615l-2.288-3a1 1 0 1 1 1.576-1.23l1.5 1.991 3.924-4.991a1 1 0 1 1 1.576 1.23l-4.712 6A.999.999 0 0 1 3.788 9z' class='spectrum-UIIcon--medium'/%3E%3C/svg%3E%0A");

    --secure-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23757575' viewBox='0 0 12 15'%3E%3Cpath d='M11.5 6H11V5A5 5 0 1 0 1 5v1H.5a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h11a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5ZM3 5a3 3 0 1 1 6 0v1H3Zm4 6.111V12.5a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1.389a1.5 1.5 0 1 1 2 0Z'/%3E%3C/svg%3E");

    --info-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 36 36'><circle cx='18' cy='12' r='2.15'%3E%3C/circle%3E%3Cpath d='M20.333 24H20v-7.6a.4.4 0 0 0-.4-.4h-3.933s-1.167.032-1.167 1 1.167 1 1.167 1H16v6h-.333s-1.167.032-1.167 1 1.167 1 1.167 1h4.667s1.167-.033 1.167-1-1.168-1-1.168-1z'%3E%3C/path%3E%3Cpath d='M18 2.1A15.9 15.9 0 1 0 33.9 18 15.9 15.9 0 0 0 18 2.1zm0 29.812A13.912 13.912 0 1 1 31.913 18 13.912 13.912 0 0 1 18 31.913z'%3E%3C/path%3E%3C/svg%3E");

    --ellipsis-icon: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="2" cy="2" r="2" fill="%232c2c2c" transform="translate(6 6)"/><circle cx="2" cy="2" r="2" fill="%232c2c2c" data-name="Ellipse 71" transform="translate(12 6)"/><circle cx="2" cy="2" r="2" fill="%232c2c2c" transform="translate(0 6)"/></svg>');

    /* callout */
    --consonant-merch-card-callout-line-height: 21px;
    --consonant-merch-card-callout-font-size: 14px;
    --consonant-merch-card-callout-font-color: #2C2C2C;
    --consonant-merch-card-callout-icon-size: 16px;
    --consonant-merch-card-callout-icon-top: 6px;
    --consonant-merch-card-callout-icon-right: 8px;
    --consonant-merch-card-callout-letter-spacing: 0px;
    --consonant-merch-card-callout-icon-padding: 34px;
    --consonant-merch-card-callout-spacing-xxs: 8px;

    --merch-card-ul-padding: 8px;
}

.collection-container {
    display: grid;
    justify-content: center;
    grid-template-columns: min-content min-content;
    grid-template-rows: min-content 1fr;
    align-items: start;
    grid-template-areas: "sidenav header" "sidenav content";
    --merch-card-collection-card-min-height: auto;
    --merch-sidenav-collection-gap: 0;
    --merch-card-collection-card-width: unset;
}

.collection-container merch-sidenav {
    grid-area: sidenav;
}

.collection-container merch-card-collection-header {
    --merch-card-collection-header-margin-bottom: var(--spacing-m);
    grid-area: header;
}

.collection-container merch-card-collection {
    grid-area: content;
}

.collection-container merch-card {
    min-height: var(--merch-card-collection-card-min-height);
}

.collection-container .one-merch-card,
.collection-container .two-merch-cards,
.collection-container .three-merch-cards,
.collection-container .four-merch-cards {
    padding: 0;
}

merch-card-collection {
    display: contents;
}

merch-card-collection > p[slot],
merch-card-collection > div[slot] p,
merch-card-collection-header > p[slot],
merch-card-collection-header > div[slot] p {
    margin: 0;
}

.one-merch-card,
.two-merch-cards,
.three-merch-cards,
.four-merch-cards {
    --merch-card-collection-card-width: unset;
    display: grid;
    justify-content: center;
    justify-items: stretch;
    align-items: normal;
    gap: var(--consonant-merch-spacing-m);
    padding: var(--spacing-m);
    grid-template-columns: var(--merch-card-collection-card-width);
}

.tabpanel > .four-merch-cards {
    z-index: 3;
}

merch-card[variant="ccd-suggested"] *,
merch-card[variant="ccd-slice"] * {
  box-sizing: border-box;
}

merch-card * {
  padding: revert-layer;
}

merch-card.background-opacity-70 {
    background-color: rgba(255 255 255 / 70%);
}

merch-card.has-divider hr {
    margin: var(--consonant-merch-spacing-xs) 0;
    height: 1px;
    border: none;
}

merch-card.has-divider div[slot='body-lower'] hr {
    margin: 0;
}

merch-card p, merch-card h3, merch-card h4 {
    margin: 0;
}

merch-card span[is='inline-price'] {
    display: inline-block;
}

.annual-price-new-line > span[is="inline-price"] {
  line-height: var(--consonant-merch-card-body-m-line-height);
}

.annual-price-new-line > span[is="inline-price"] > .price-annual-prefix {
  font-size: 0;
  line-height: 0;
}

.annual-price-new-line > span[is="inline-price"] .price-alternative {
  display: block;
}

.annual-price-new-line > span[is="inline-price"] > .price-annual::before {
  content: '(';
}

merch-card [slot^='heading-'],
merch-card span[class^='heading-'] {
    color: var(--consonant-merch-card-heading-color);
    font-weight: 700;
}

merch-card span[class^='heading-'],
merch-card span.promo-text {
    display: block;
}

merch-card [slot='heading-xxxs'],
merch-card span.heading-xxxs {
    font-size: var(--consonant-merch-card-heading-xxxs-font-size);
    line-height: var(--consonant-merch-card-heading-xxxs-line-height);
    color: var(--consonant-merch-card-heading-xxxs-color);
    letter-spacing: normal;
}

merch-card [slot='heading-xxs'],
merch-card span.heading-xxs {
    font-size: var(--consonant-merch-card-heading-xxs-font-size);
    line-height: var(--consonant-merch-card-heading-xxs-line-height);
    letter-spacing: normal;
}

merch-card [slot='heading-xs'],
merch-card span.heading-xs {
    font-size: var(--consonant-merch-card-heading-xs-font-size);
    line-height: var(--consonant-merch-card-heading-xs-line-height);
    color: var(--consonant-merch-card-heading-xs-color);
    margin: 0;
}

merch-card.dc-pricing [slot='heading-xs'] {
    margin-bottom: var(--consonant-merch-spacing-xxs);
}

merch-card:not([variant='inline-heading']) [slot='heading-xs'] a {
    color: var(--merch-color-grey-80);
}

merch-card div.starting-at {
  font-size: var(--consonant-merch-card-body-xs-font-size);
  line-height: var(--consonant-merch-card-body-xs-line-height);
  font-weight: 500;
}

merch-card [slot='heading-xs'] a:not(:hover) {
    text-decoration: inherit;
}

merch-card [slot='heading-s'],
merch-card span.heading-s {
    font-size: var(--consonant-merch-card-heading-s-font-size);
    line-height: var(--consonant-merch-card-heading-s-line-height);
    margin: 0;
}

merch-card [slot='heading-m'],
merch-card span.heading-m {
    font-size: var(--consonant-merch-card-heading-m-font-size);
    line-height: var(--consonant-merch-card-heading-m-line-height);
    margin: 0;
}

merch-card [slot='heading-m-price'] {
    font-size: var(--consonant-merch-card-heading-m-font-size);
    line-height: var(--consonant-merch-card-heading-m-line-height);
    padding: 0 var(--consonant-merch-spacing-s);
    margin: 0;
    color: var(--spectrum-gray-800, #2c2c2c);
}

merch-card [slot='heading-l'],
merch-card span.heading-l {
    font-size: var(--consonant-merch-card-heading-l-font-size);
    line-height: var(--consonant-merch-card-heading-l-line-height);
    font-weight: 900;
    margin: 0;
}

merch-card [slot='offers'] {
    padding: var(--consonant-merch-spacing-xxs) var(--consonant-merch-spacing-s);
}

merch-card [slot='whats-included'] {
    margin: var(--consonant-merch-spacing-xxxs) 0px;
}

merch-card [slot='callout-content'] {
    display: flex;
    flex-direction: column;
    margin: var(--consonant-merch-spacing-xxxs) 0px;
    gap: var(--consonant-merch-card-callout-spacing-xxs);
}

merch-card[variant^='plans'] [slot='badge'] {
    position: absolute;
    top: 16px;
    right: 0;
    line-height: 16px;
}

merch-card [slot='callout-content'] > p {
    background: rgba(203 203 203 / 50%);
    border-radius: var(--consonant-merch-spacing-xxxs);
    padding: var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xxs);
    width: fit-content;
    font-size: var(--consonant-merch-card-callout-font-size);
    line-height: var(--consonant-merch-card-callout-line-height);
}

merch-card [slot='callout-content'] > div {
    display: flex;
    flex-direction: column;
    margin: var(--consonant-merch-spacing-xxxs) 0px;
    gap: var(--consonant-merch-card-callout-spacing-xxs);
    align-items: flex-start;
}

merch-card [slot='callout-content'] > div > div {
    display: flex;
    background: rgba(203 203 203 / 50%);
    border-radius: var(--consonant-merch-spacing-xxxs);
    padding: var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xxxs) var(--consonant-merch-spacing-xxs);
}

merch-card [slot='callout-content'] > div > div > div {
    display: inline-block;
    text-align: start;
    font: normal normal normal var(--consonant-merch-card-callout-font-size)/var(--consonant-merch-card-callout-line-height) var(--body-font-family, 'Adobe Clean');
    letter-spacing: var(--consonant-merch-card-callout-letter-spacing);
    color: var(--consonant-merch-card-callout-font-color);
}

merch-card [slot='callout-content'] img {
    width: var(--consonant-merch-card-callout-icon-size);
    height: var(--consonant-merch-card-callout-icon-size);
    margin-inline-end: 2.5px;
    margin-inline-start: 9px;
    margin-block-start: 2.5px;
}

merch-card [slot='detail-s'] {
    font-size: var(--consonant-merch-card-detail-s-font-size);
    line-height: var(--consonant-merch-card-detail-s-line-height);
    letter-spacing: 0.66px;
    font-weight: 700;
    text-transform: uppercase;
    color: var(--consonant-merch-card-detail-s-color);
}

merch-card [slot='detail-m'] {
    font-size: var(--consonant-merch-card-detail-m-font-size);
    letter-spacing: var(--consonant-merch-card-detail-m-letter-spacing);
    font-weight: var(--consonant-merch-card-detail-m-font-weight);
    text-transform: uppercase;
    margin: 0;
    color: var(--merch-color-grey-80);
}

merch-card [slot="body-xxs"] {
    font-size: var(--consonant-merch-card-body-xxs-font-size);
    line-height: var(--consonant-merch-card-body-xxs-line-height);
    font-weight: normal;
    letter-spacing: var(--consonant-merch-card-body-xxs-letter-spacing);
    margin: 0;
    color: var(--merch-color-grey-80);
}

merch-card [slot="body-s"] {
    color: var(--consonant-merch-card-body-s-color);
}

merch-card button.spectrum-Button > a {
  color: inherit;
  text-decoration: none;
}

merch-card button.spectrum-Button > a:hover {
  color: inherit;
}

merch-card button.spectrum-Button > a:active {
  color: inherit;
}

merch-card button.spectrum-Button > a:focus {
  color: inherit;
}

merch-card [slot="body-xs"] {
    font-size: var(--consonant-merch-card-body-xs-font-size);
    line-height: var(--consonant-merch-card-body-xs-line-height);
    color: var(--consonant-merch-card-body-xs-color);
}

merch-card [slot="body-m"] {
    font-size: var(--consonant-merch-card-body-m-font-size);
    line-height: var(--consonant-merch-card-body-m-line-height);
    color: var(--merch-color-grey-80);
}

merch-card [slot="body-l"] {
    font-size: var(--consonant-merch-card-body-l-font-size);
    line-height: var(--consonant-merch-card-body-l-line-height);
    color: var(--merch-color-grey-80);
}

merch-card [slot="body-xl"] {
    font-size: var(--consonant-merch-card-body-xl-font-size);
    line-height: var(--consonant-merch-card-body-xl-line-height);
    color: var(--merch-color-grey-80);
}

merch-card [slot="cci-footer"] p,
merch-card [slot="cct-footer"] p,
merch-card [slot="cce-footer"] p {
    margin: 0;
}

merch-card [slot="promo-text"],
merch-card span.promo-text {
    color: var(--merch-color-green-promo);
    font-size: var(--consonant-merch-card-promo-text-height);
    font-weight: 700;
    line-height: var(--consonant-merch-card-heading-font-size);
    margin: 0;
    min-height: var(--consonant-merch-card-promo-text-height);
    padding: 0;
}

merch-card span[data-styling][class^='heading-'],
merch-card span[data-styling].promo-text {
    display: block;
}

merch-card [slot="footer-rows"] {
    min-height: var(--consonant-merch-card-footer-rows-height);
}

merch-card div[slot="footer"] {
    display: contents;
}

merch-card.product div[slot="footer"] {
    display: block;
}

merch-card.product div[slot="footer"] a + a {
    margin: 5px 0 0 5px;
}

merch-card [slot="footer"] a {
    word-wrap: break-word;
    text-align: center;
}

merch-card [slot="footer"] a:not([class]) {
    font-weight: 700;
    font-size: var(--consonant-merch-card-cta-font-size);
}

merch-card div[slot='bg-image'] img {
    position: relative;
    width: 100%;
    min-height: var(--consonant-merch-card-bg-img-height);
    max-height: var(--consonant-merch-card-bg-img-height);
    object-fit: cover;
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
}

.price-unit-type:not(.disabled)::before,
.price-tax-inclusivity:not(.disabled)::before {
  content: "\\00a0";
}

merch-card span.placeholder-resolved[data-template='priceStrikethrough'],
merch-card span.placeholder-resolved[data-template='strikethrough'],
merch-card span.price.price-strikethrough {
  font-size: var(--consonant-merch-card-body-xs-font-size);
  font-weight: normal;
  text-decoration: line-through;
  color: var(--merch-color-inline-price-strikethrough);
}

merch-card [slot^="body-"] ul {
    margin: 0;
    padding-inline-start: var(--merch-card-ul-padding);
    list-style-type: "\u2022";
}
    
merch-card [slot^="body-"] ul li {
    padding-inline-start: var(--merch-card-ul-padding);
}

/* merch-offer-select */
merch-offer-select[variant="subscription-options"] merch-offer span[is="inline-price"][data-display-tax='true'] .price-tax-inclusivity {
    font-size: 12px;
    font-style: italic;
    font-weight: normal;
    position: absolute;
    left: 0;
    top: 20px;
}

merch-addon span[data-wcs-osi][data-offer-type="TRIAL"] {
    display: none;
}

merch-gradient {
    display: none;
}

body.merch-modal {
    overflow: hidden;
    scrollbar-gutter: stable;
    height: 100vh;
}

merch-sidenav-list img[slot="icon"] {
    height: fit-content;
    pointer-events: none;
}

merch-sidenav-list sp-sidenav > sp-sidenav-item:last-of-type {
    --mod-sidenav-gap: 0;
    line-height: var(--mod-sidenav-top-level-line-height)
}

merch-sidenav-checkbox-group h3 {
    font-size: var(--merch-sidenav-checkbox-group-title-font-size);
    font-weight: var(--merch-sidenav-checkbox-group-title-font-weight);
    line-height: var(--merch-sidenav-checkbox-group-title-line-height);
    color: var(--merch-sidenav-checkbox-group-title-color);
    padding: var(--merch-sidenav-checkbox-group-title-padding);
    margin: 0;
}

sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

aem-fragment {
  display: contents;
}

merch-card [slot='callout-content'] .icon-button {
  position: absolute;
  top: 3px;
  text-decoration: none;
  border-bottom: none;
  min-width: 18px;
  display: inline-flex;
  min-height: 18px;
  align-items: center;
  justify-content: center;
  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" height="14" width="14"><path d="M7 .778A6.222 6.222 0 1 0 13.222 7 6.222 6.222 0 0 0 7 .778zM6.883 2.45a1.057 1.057 0 0 1 1.113.998q.003.05.001.1a1.036 1.036 0 0 1-1.114 1.114A1.052 1.052 0 0 1 5.77 3.547 1.057 1.057 0 0 1 6.784 2.45q.05-.002.1.001zm1.673 8.05a.389.389 0 0 1-.39.389H5.834a.389.389 0 0 1-.389-.389v-.778a.389.389 0 0 1 .39-.389h.388V7h-.389a.389.389 0 0 1-.389-.389v-.778a.389.389 0 0 1 .39-.389h1.555a.389.389 0 0 1 .389.39v3.5h.389a.389.389 0 0 1 .389.388z"/></svg>');
  background-size: 18px;
}

merch-card [slot='callout-content'] .icon-button::before {
  content: attr(data-tooltip);
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  left: 100%;
  margin-left: 8px;
  max-width: 140px;
  padding: 10px;
  border-radius: 5px;
  background: #0469E3;
  color: #fff;
  text-align: left;
  display: block;
  z-index: 10;
  font-size: 12px;
  font-style: normal;
  font-weight: 400;
  line-height: 16px;
  width: max-content;
}

merch-card [slot='callout-content'] .icon-button::after {
  content: "";
  position: absolute;
  left: 102%;
  margin-left: -8px;
  top: 50%;
  transform: translateY(-50%);
  border: 8px solid #0469E3;
  border-color: transparent #0469E3 transparent transparent;
  display: block;
  z-index: 10;
}

merch-card [slot='callout-content'] .icon-button.hide-tooltip::before,
merch-card [slot='callout-content'] .icon-button.hide-tooltip::after {
  display: none;
}

@media (max-width: 600px) {
merch-card [slot='callout-content'] .icon-button::before { 
    max-width: 180px;
  }
}

@media screen and ${TABLET_UP} {
    .two-merch-cards,
    .three-merch-cards,
    .four-merch-cards {
        grid-template-columns: repeat(2, var(--merch-card-collection-card-width));
    }
}

@media screen and ${DESKTOP_UP} {
    .four-merch-cards {
        grid-template-columns: repeat(4, var(--merch-card-collection-card-width));
    }

    .three-merch-cards,
    merch-sidenav ~ .four-merch-cards {
        grid-template-columns: repeat(3, var(--merch-card-collection-card-width));
    }
}

@media screen and ${LARGE_DESKTOP} {
    .four-merch-cards,
    merch-sidenav ~ .four-merch-cards {
        grid-template-columns: repeat(4, var(--merch-card-collection-card-width));
    }
}

`;
document.head.appendChild(styles2);

// src/aem-fragment.js
var ATTRIBUTE_FRAGMENT = "fragment";
var ATTRIBUTE_AUTHOR = "author";
var ATTRIBUTE_PREVIEW = "preview";
var ATTRIBUTE_LOADING = "loading";
var ATTRIBUTE_TIMEOUT = "timeout";
var AEM_FRAGMENT_TAG_NAME = "aem-fragment";
var LOADING_EAGER = "eager";
var LOADING_CACHE = "cache";
var LOADING_VALUES = [LOADING_EAGER, LOADING_CACHE];
var _fragmentCache, _fetchInfos, _promises;
var FragmentCache = class {
  constructor() {
    __privateAdd(this, _fragmentCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _fetchInfos, /* @__PURE__ */ new Map());
    __privateAdd(this, _promises, /* @__PURE__ */ new Map());
  }
  clear() {
    __privateGet(this, _fragmentCache).clear();
    __privateGet(this, _fetchInfos).clear();
    __privateGet(this, _promises).clear();
  }
  /**
   * Add fragment to cache
   * @param {Object} fragment fragment object.
   */
  add(fragment, references = true) {
    if (this.has(fragment.id)) return;
    if (this.has(fragment.fields?.originalId)) return;
    __privateGet(this, _fragmentCache).set(fragment.id, fragment);
    if (fragment.fields?.originalId) {
      __privateGet(this, _fragmentCache).set(fragment.fields.originalId, fragment);
    }
    if (__privateGet(this, _promises).has(fragment.id)) {
      const [, resolve] = __privateGet(this, _promises).get(fragment.id);
      resolve();
    }
    if (__privateGet(this, _promises).has(fragment.fields?.originalId)) {
      const [, resolve] = __privateGet(this, _promises).get(fragment.fields?.originalId);
      resolve();
    }
    if (!references || typeof fragment.references !== "object" || Array.isArray(fragment.references))
      return;
    for (const key in fragment.references) {
      const { type, value } = fragment.references[key];
      if (type === "content-fragment") {
        value.settings = {
          ...fragment?.settings,
          ...value.settings
        };
        value.placeholders = {
          ...fragment?.placeholders,
          ...value.placeholders
        };
        value.dictionary = {
          ...fragment?.dictionary,
          ...value.dictionary
        };
        value.priceLiterals = {
          ...fragment?.priceLiterals,
          ...value.priceLiterals
        };
        this.add(value, fragment);
      }
    }
  }
  has(fragmentId) {
    return __privateGet(this, _fragmentCache).has(fragmentId);
  }
  entries() {
    return __privateGet(this, _fragmentCache).entries();
  }
  get(key) {
    return __privateGet(this, _fragmentCache).get(key);
  }
  getAsPromise(key) {
    let [promise] = __privateGet(this, _promises).get(key) ?? [];
    if (promise) {
      return promise;
    }
    let resolveFn;
    promise = new Promise((resolve) => {
      resolveFn = resolve;
      if (this.has(key)) {
        resolve();
      }
    });
    __privateGet(this, _promises).set(key, [promise, resolveFn]);
    return promise;
  }
  getFetchInfo(fragmentId) {
    let fetchInfo = __privateGet(this, _fetchInfos).get(fragmentId);
    if (!fetchInfo) {
      fetchInfo = {
        url: null,
        retryCount: 0,
        stale: false,
        measure: null,
        status: null
      };
      __privateGet(this, _fetchInfos).set(fragmentId, fetchInfo);
    }
    return fetchInfo;
  }
  remove(fragmentId) {
    __privateGet(this, _fragmentCache).delete(fragmentId);
    __privateGet(this, _fetchInfos).delete(fragmentId);
    __privateGet(this, _promises).delete(fragmentId);
  }
};
_fragmentCache = new WeakMap();
_fetchInfos = new WeakMap();
_promises = new WeakMap();
var cache = new FragmentCache();
var _log, _rawData, _data, _service3, _fragmentId, _fetchInfo, _loading, _timeout, _fetchPromise, _author, _fetchCount, _preview, _AemFragment_instances, getFragmentById_fn, applyHeaders_fn, fail_fn, fetchData_fn;
var AemFragment = class extends HTMLElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _AemFragment_instances);
    __publicField(this, "cache", cache);
    __privateAdd(this, _log);
    __privateAdd(this, _rawData, null);
    __privateAdd(this, _data, null);
    __privateAdd(this, _service3, null);
    /**
     * @type {string} fragment id
     */
    __privateAdd(this, _fragmentId);
    __privateAdd(this, _fetchInfo);
    __privateAdd(this, _loading, LOADING_EAGER);
    __privateAdd(this, _timeout, 5e3);
    /**
     * Internal promise to track if fetching is in progress.
     */
    __privateAdd(this, _fetchPromise);
    __privateAdd(this, _author, false);
    __privateAdd(this, _fetchCount, 0);
    __privateAdd(this, _preview);
  }
  static get observedAttributes() {
    return [
      ATTRIBUTE_FRAGMENT,
      ATTRIBUTE_LOADING,
      ATTRIBUTE_TIMEOUT,
      ATTRIBUTE_AUTHOR,
      ATTRIBUTE_PREVIEW
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === ATTRIBUTE_FRAGMENT) {
      __privateSet(this, _fragmentId, newValue);
      __privateSet(this, _fetchInfo, cache.getFetchInfo(newValue));
    }
    if (name === ATTRIBUTE_LOADING && LOADING_VALUES.includes(newValue)) {
      __privateSet(this, _loading, newValue);
    }
    if (name === ATTRIBUTE_TIMEOUT) {
      __privateSet(this, _timeout, parseInt(newValue, 10));
    }
    if (name === ATTRIBUTE_AUTHOR) {
      __privateSet(this, _author, ["", "true"].includes(newValue));
    }
    if (name === ATTRIBUTE_PREVIEW) {
      __privateSet(this, _preview, newValue);
    }
  }
  connectedCallback() {
    if (__privateGet(this, _fetchPromise)) return;
    __privateGet(this, _service3) ?? __privateSet(this, _service3, getService2(this));
    __privateSet(this, _preview, __privateGet(this, _service3).settings?.preview);
    __privateGet(this, _log) ?? __privateSet(this, _log, __privateGet(this, _service3).log.module(
      `${AEM_FRAGMENT_TAG_NAME}[${__privateGet(this, _fragmentId)}]`
    ));
    if (!__privateGet(this, _fragmentId) || __privateGet(this, _fragmentId) === "#") {
      __privateGet(this, _fetchInfo) ?? __privateSet(this, _fetchInfo, cache.getFetchInfo("missing-fragment-id"));
      __privateMethod(this, _AemFragment_instances, fail_fn).call(this, "Missing fragment id");
      return;
    }
    this.refresh(false);
  }
  get fetchInfo() {
    return Object.fromEntries(
      Object.entries(__privateGet(this, _fetchInfo)).filter(([key, value]) => value != void 0).map(([key, value]) => [`aem-fragment:${key}`, value])
    );
  }
  async refresh(flushCache = true) {
    if (__privateGet(this, _fetchPromise)) {
      const ready = await Promise.race([
        __privateGet(this, _fetchPromise),
        Promise.resolve(false)
      ]);
      if (!ready) return;
    }
    if (flushCache) {
      cache.remove(__privateGet(this, _fragmentId));
    }
    if (__privateGet(this, _loading) === LOADING_CACHE) {
      await Promise.race([
        cache.getAsPromise(__privateGet(this, _fragmentId)),
        new Promise((resolve) => setTimeout(resolve, __privateGet(this, _timeout)))
      ]);
    }
    try {
      __privateSet(this, _fetchPromise, __privateMethod(this, _AemFragment_instances, fetchData_fn).call(this));
      await __privateGet(this, _fetchPromise);
    } catch (e4) {
      __privateMethod(this, _AemFragment_instances, fail_fn).call(this, e4.message);
      return false;
    }
    const { references, referencesTree, placeholders, wcs } = __privateGet(this, _rawData) || {};
    if (wcs && !getParameter("mas.disableWcsCache")) {
      __privateGet(this, _service3).prefillWcsCache(wcs);
    }
    this.dispatchEvent(
      new CustomEvent(EVENT_AEM_LOAD, {
        detail: {
          ...this.data,
          references,
          referencesTree,
          placeholders,
          ...__privateGet(this, _fetchInfo)
          // Spread all fetch info
        },
        bubbles: true,
        composed: true
      })
    );
    return __privateGet(this, _fetchPromise);
  }
  get updateComplete() {
    return __privateGet(this, _fetchPromise) ?? Promise.reject(new Error("AEM fragment cannot be loaded"));
  }
  get data() {
    if (__privateGet(this, _data)) return __privateGet(this, _data);
    if (__privateGet(this, _author)) {
      this.transformAuthorData();
    } else {
      this.transformPublishData();
    }
    return __privateGet(this, _data);
  }
  transformAuthorData() {
    const {
      fields,
      id,
      tags,
      settings = {},
      priceLiterals: priceLiterals2 = {},
      dictionary = {},
      placeholders = {}
    } = __privateGet(this, _rawData);
    __privateSet(this, _data, fields.reduce(
      (acc, { name, multiple, values }) => {
        acc.fields[name] = multiple ? values : values[0];
        return acc;
      },
      {
        fields: {},
        id,
        tags,
        settings,
        priceLiterals: priceLiterals2,
        dictionary,
        placeholders
      }
    ));
  }
  transformPublishData() {
    const {
      fields,
      id,
      tags,
      settings = {},
      priceLiterals: priceLiterals2 = {},
      dictionary = {},
      placeholders = {}
    } = __privateGet(this, _rawData);
    __privateSet(this, _data, Object.entries(fields).reduce(
      (acc, [key, value]) => {
        acc.fields[key] = value?.mimeType ? value.value : value ?? "";
        return acc;
      },
      {
        fields: {},
        id,
        tags,
        settings,
        priceLiterals: priceLiterals2,
        dictionary,
        placeholders
      }
    ));
  }
  /**
   * Gets the URL for loading fragment-client.js based on maslibs parameter
   * @returns {string} URL for fragment-client.js
   */
  getFragmentClientUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    const masLibs = urlParams.get("maslibs");
    if (!masLibs || masLibs.trim() === "") {
      return "https://mas.adobe.com/studio/libs/fragment-client.js";
    }
    const sanitizedMasLibs = masLibs.trim().toLowerCase();
    if (sanitizedMasLibs === "local") {
      return "http://localhost:3030/studio/libs/fragment-client.js";
    }
    const { hostname } = window.location;
    const extension = hostname.endsWith(".page") ? "page" : "live";
    if (sanitizedMasLibs.includes("--")) {
      return `https://${sanitizedMasLibs}.aem.${extension}/studio/libs/fragment-client.js`;
    }
    return `https://${sanitizedMasLibs}--mas--adobecom.aem.${extension}/studio/libs/fragment-client.js`;
  }
  async generatePreview() {
    const fragmentClientUrl = this.getFragmentClientUrl();
    const { previewFragment } = await import(fragmentClientUrl);
    const data = await previewFragment(__privateGet(this, _fragmentId), {
      locale: __privateGet(this, _service3).settings.locale,
      apiKey: __privateGet(this, _service3).settings.wcsApiKey
    });
    return data;
  }
};
_log = new WeakMap();
_rawData = new WeakMap();
_data = new WeakMap();
_service3 = new WeakMap();
_fragmentId = new WeakMap();
_fetchInfo = new WeakMap();
_loading = new WeakMap();
_timeout = new WeakMap();
_fetchPromise = new WeakMap();
_author = new WeakMap();
_fetchCount = new WeakMap();
_preview = new WeakMap();
_AemFragment_instances = new WeakSet();
getFragmentById_fn = async function(endpoint) {
  __privateWrapper(this, _fetchCount)._++;
  const markPrefix = `${AEM_FRAGMENT_TAG_NAME}:${__privateGet(this, _fragmentId)}:${__privateGet(this, _fetchCount)}`;
  const startMarkName = `${markPrefix}${MARK_START_SUFFIX}`;
  const measureName = `${markPrefix}${MARK_DURATION_SUFFIX}`;
  if (__privateGet(this, _preview)) {
    return await this.generatePreview();
  }
  performance.mark(startMarkName);
  let response;
  try {
    __privateGet(this, _fetchInfo).stale = false;
    __privateGet(this, _fetchInfo).url = endpoint;
    response = await masFetch(endpoint, {
      cache: "default",
      credentials: "omit"
    });
    __privateMethod(this, _AemFragment_instances, applyHeaders_fn).call(this, response);
    __privateGet(this, _fetchInfo).status = response?.status;
    __privateGet(this, _fetchInfo).measure = printMeasure(
      performance.measure(measureName, startMarkName)
    );
    __privateGet(this, _fetchInfo).retryCount = response.retryCount;
    if (!response?.ok) {
      throw new MasError("Unexpected fragment response", {
        response,
        ...__privateGet(this, _service3).duration
      });
    }
    return await response.json();
  } catch (e4) {
    __privateGet(this, _fetchInfo).measure = printMeasure(
      performance.measure(measureName, startMarkName)
    );
    __privateGet(this, _fetchInfo).retryCount = e4.retryCount;
    if (__privateGet(this, _rawData)) {
      __privateGet(this, _fetchInfo).stale = true;
      __privateGet(this, _log).error(`Serving stale data`, __privateGet(this, _fetchInfo));
      return __privateGet(this, _rawData);
    }
    const reason = e4.message ?? "unknown";
    throw new MasError(`Failed to fetch fragment: ${reason}`, {});
  }
};
applyHeaders_fn = function(response) {
  Object.assign(__privateGet(this, _fetchInfo), getLogHeaders(response));
};
fail_fn = function(message) {
  __privateSet(this, _fetchPromise, null);
  __privateGet(this, _fetchInfo).message = message;
  this.classList.add("error");
  const detail = {
    ...__privateGet(this, _fetchInfo),
    ...__privateGet(this, _service3).duration
  };
  __privateGet(this, _log).error(message, detail);
  this.dispatchEvent(
    new CustomEvent(EVENT_AEM_ERROR, {
      detail,
      bubbles: true,
      composed: true
    })
  );
};
fetchData_fn = async function() {
  var _a2;
  this.classList.remove("error");
  __privateSet(this, _data, null);
  let fragment = cache.get(__privateGet(this, _fragmentId));
  if (fragment) {
    __privateSet(this, _rawData, fragment);
    return true;
  }
  const { masIOUrl, wcsApiKey, country, locale } = __privateGet(this, _service3).settings;
  let endpoint = `${masIOUrl}/fragment?id=${__privateGet(this, _fragmentId)}&api_key=${wcsApiKey}&locale=${locale}`;
  if (country && !locale.endsWith(`_${country}`)) {
    endpoint += `&country=${country}`;
  }
  fragment = await __privateMethod(this, _AemFragment_instances, getFragmentById_fn).call(this, endpoint);
  (_a2 = fragment.fields).originalId ?? (_a2.originalId = __privateGet(this, _fragmentId));
  cache.add(fragment);
  __privateSet(this, _rawData, fragment);
  return true;
};
// TO be deprecated
__publicField(AemFragment, "cache", cache);
customElements.define(AEM_FRAGMENT_TAG_NAME, AemFragment);

// src/merch-badge.js
init_lit();
var MerchBadge = class extends s4 {
  constructor() {
    super();
    this.color = "";
    this.variant = "";
    this.backgroundColor = "";
    this.borderColor = "";
    this.text = this.textContent;
  }
  connectedCallback() {
    if (this.borderColor && this.borderColor !== "Transparent") {
      this.style.setProperty(
        "--merch-badge-border",
        `1px solid var(--${this.borderColor})`
      );
    } else {
      this.style.setProperty(
        "--merch-badge-border",
        `1px solid var(--${this.backgroundColor})`
      );
    }
    this.style.setProperty(
      "--merch-badge-background-color",
      `var(--${this.backgroundColor})`
    );
    this.style.setProperty("--merch-badge-color", this.color);
    this.style.setProperty("--merch-badge-padding", "2px 10px 3px 10px");
    this.style.setProperty("--merch-badge-border-radius", "4px 0 0 4px");
    this.style.setProperty(
      "--merch-badge-font-size",
      "var(--consonant-merch-card-body-xs-font-size)"
    );
    this.textContent = "";
    super.connectedCallback();
  }
  render() {
    return x`<div class="badge">${this.text}</div>`;
  }
};
__publicField(MerchBadge, "properties", {
  color: { type: String },
  variant: { type: String },
  backgroundColor: { type: String, attribute: "background-color" },
  borderColor: { type: String, attribute: "border-color" }
});
__publicField(MerchBadge, "styles", i`
        :host {
            display: block;
            background-color: var(--merch-badge-background-color);
            color: var(--merch-badge-color, #000);
            padding: var(--merch-badge-padding);
            border-radius: var(--merch-badge-border-radius);
            font-size: var(--merch-badge-font-size);
            line-height: 21px;
            border: var(--merch-badge-border);
            position: relative;
            left: 1px;
        }
    `);
customElements.define("merch-badge", MerchBadge);

// src/merch-mnemonic-list.js
init_lit();
var MerchMnemonicList = class extends s4 {
  constructor() {
    super();
  }
  render() {
    return x`
            <slot name="icon"></slot>
            <slot name="description">${this.description}</slot>
        `;
  }
};
__publicField(MerchMnemonicList, "styles", i`
        :host {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            margin-right: 16px;
            align-items: center;
        }

        ::slotted([slot='icon']) {
            display: flex;
            justify-content: center;
            align-items: center;
            height: max-content;
        }

        ::slotted([slot='description']) {
            font-size: 14px;
            line-height: 21px;
            margin: 0;
        }

        :host .hidden {
            display: none;
        }
    `);
__publicField(MerchMnemonicList, "properties", {
  description: { type: String, attribute: true }
});
customElements.define("merch-mnemonic-list", MerchMnemonicList);

// src/merch-whats-included.js
init_lit();
var MerchWhatsIncluded = class extends s4 {
  updated() {
    this.hideSeeMoreEls();
  }
  hideSeeMoreEls() {
    if (this.isMobile) {
      this.rows.forEach((node, index) => {
        if (index >= 5) {
          node.style.display = this.showAll ? "flex" : "none";
        }
      });
    }
  }
  constructor() {
    super();
    this.showAll = false;
    this.mobileRows = this.mobileRows === void 0 ? 5 : this.mobileRows;
  }
  toggle() {
    this.showAll = !this.showAll;
    this.dispatchEvent(
      new CustomEvent("hide-see-more-elements", {
        bubbles: true,
        composed: true
      })
    );
    this.requestUpdate();
  }
  render() {
    return x`<slot name="heading"></slot>
            <slot name="content"></slot>
            ${this.isMobile && this.rows.length > this.mobileRows ? x`<div @click=${this.toggle} class="see-more">
                      ${this.showAll ? "- See less" : "+ See more"}
                  </div>` : x``}`;
  }
  get isMobile() {
    return window.matchMedia("(max-width: 767px)").matches;
  }
  get rows() {
    return this.querySelectorAll("merch-mnemonic-list");
  }
};
__publicField(MerchWhatsIncluded, "styles", i`
        :host {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            overflow: hidden;
            box-sizing: border-box;
            row-gap: 10px;
        }

        ::slotted([slot='heading']) {
            font-size: 14px;
            font-weight: 700;
            margin-right: 16px;
        }

        ::slotted([slot='content']) {
            display: contents;
        }

        .hidden {
            display: none;
        }

        .see-more {
            font-size: 14px;
            text-decoration: underline;
            color: var(--link-color-dark);
        }
    `);
__publicField(MerchWhatsIncluded, "properties", {
  heading: { type: String, attribute: true },
  mobileRows: { type: Number, attribute: true }
});
customElements.define("merch-whats-included", MerchWhatsIncluded);

// src/hydrate.js
var DEFAULT_BADGE_COLOR = "#000000";
var DEFAULT_BADGE_BACKGROUND_COLOR = "#F8D904";
var DEFAULT_BORDER_COLOR = "#EAEAEA";
var DEFAULT_TRIAL_BADGE_BORDER_COLOR = "#31A547";
var CHECKOUT_STYLE_PATTERN = /(accent|primary|secondary)(-(outline|link))?/;
var ANALYTICS_TAG = "mas:product_code/";
var ANALYTICS_LINK_ATTR = "daa-ll";
var ANALYTICS_SECTION_ATTR = "daa-lh";
var SPECTRUM_BUTTON_SIZES = ["XL", "L", "M", "S"];
var TEXT_TRUNCATE_SUFFIX = "...";
function appendSlot(fieldName, fields, el, mapping) {
  const config2 = mapping[fieldName];
  if (fields[fieldName] && config2) {
    const attributes = { slot: config2?.slot };
    let content = fields[fieldName];
    if (config2.maxCount && typeof content === "string") {
      const [truncatedContent, cleanContent] = getTruncatedTextData(
        content,
        config2.maxCount,
        config2.withSuffix
      );
      if (truncatedContent !== content) {
        attributes.title = cleanContent;
        content = truncatedContent;
      }
    }
    const tag = createTag(config2.tag, attributes, content);
    el.append(tag);
  }
}
function processMnemonics(fields, merchCard, mnemonicsConfig) {
  const mnemonics = fields.mnemonicIcon?.map((icon, index) => ({
    icon,
    alt: fields.mnemonicAlt[index] ?? "",
    link: fields.mnemonicLink[index] ?? ""
  }));
  mnemonics?.forEach(({ icon: src, alt, link: href }) => {
    if (href && !/^https?:/.test(href)) {
      try {
        href = new URL(`https://${href}`).href.toString();
      } catch (e4) {
        href = "#";
      }
    }
    const attrs = {
      slot: "icons",
      src,
      loading: merchCard.loading,
      size: mnemonicsConfig?.size ?? "l"
    };
    if (alt) attrs.alt = alt;
    if (href) attrs.href = href;
    const merchIcon = createTag("merch-icon", attrs);
    merchCard.append(merchIcon);
  });
  const slotIcons = merchCard.shadowRoot.querySelector('slot[name="icons"]');
  if (!mnemonics?.length && slotIcons) {
    slotIcons.remove();
  }
}
function processBadge(fields, merchCard, mapping) {
  if (mapping.badge?.slot) {
    if (fields.badge?.length && !fields.badge?.startsWith("<merch-badge")) {
      let badgeDefaultBgColor = DEFAULT_BADGE_BACKGROUND_COLOR;
      let setBorderColorForBadge = false;
      if (mapping.allowedBadgeColors?.includes(mapping.badge?.default)) {
        badgeDefaultBgColor = mapping.badge?.default;
        if (!fields.borderColor) {
          setBorderColorForBadge = true;
        }
      }
      const bgColorToUse = fields.badgeBackgroundColor || badgeDefaultBgColor;
      let borderColorToUse = fields.borderColor || "";
      if (setBorderColorForBadge) {
        borderColorToUse = mapping.badge?.default;
        fields.borderColor = mapping.badge?.default;
      }
      fields.badge = `<merch-badge variant="${fields.variant}" background-color="${bgColorToUse}" border-color="${borderColorToUse}">${fields.badge}</merch-badge>`;
    }
    appendSlot("badge", fields, merchCard, mapping);
  } else {
    if (fields.badge) {
      merchCard.setAttribute("badge-text", fields.badge);
      if (!mapping.disabledAttributes?.includes("badgeColor")) {
        merchCard.setAttribute(
          "badge-color",
          fields.badgeColor || DEFAULT_BADGE_COLOR
        );
      }
      if (!mapping.disabledAttributes?.includes("badgeBackgroundColor")) {
        merchCard.setAttribute(
          "badge-background-color",
          fields.badgeBackgroundColor || DEFAULT_BADGE_BACKGROUND_COLOR
        );
      }
      merchCard.setAttribute(
        "border-color",
        fields.badgeBackgroundColor || DEFAULT_BADGE_BACKGROUND_COLOR
      );
    } else {
      merchCard.setAttribute(
        "border-color",
        fields.borderColor || DEFAULT_BORDER_COLOR
      );
    }
  }
}
function processTrialBadge(fields, merchCard, mapping) {
  if (mapping.trialBadge && fields.trialBadge) {
    if (!fields.trialBadge.startsWith("<merch-badge")) {
      const borderColorToUse = !mapping.disabledAttributes?.includes(
        "trialBadgeBorderColor"
      ) && fields.trialBadgeBorderColor || DEFAULT_TRIAL_BADGE_BORDER_COLOR;
      fields.trialBadge = `<merch-badge variant="${fields.variant}" border-color="${borderColorToUse}">${fields.trialBadge}</merch-badge>`;
    }
    appendSlot("trialBadge", fields, merchCard, mapping);
  }
}
function processSize(fields, merchCard, sizeConfig) {
  if (sizeConfig?.includes(fields.size)) {
    merchCard.setAttribute("size", fields.size);
  }
}
function processCardName(fields, merchCard) {
  if (fields.cardName) {
    merchCard.setAttribute("name", fields.cardName);
  }
}
function processTitle(fields, merchCard, titleConfig) {
  appendSlot("cardTitle", fields, merchCard, { cardTitle: titleConfig });
}
function processSubtitle(fields, merchCard, mapping) {
  appendSlot("subtitle", fields, merchCard, mapping);
}
function processBackgroundColor(fields, merchCard, allowedColors, backgroundColorConfig) {
  if (!fields.backgroundColor || fields.backgroundColor.toLowerCase() === "default") {
    merchCard.style.removeProperty("--merch-card-custom-background-color");
    merchCard.removeAttribute("background-color");
    return;
  }
  if (allowedColors?.[fields.backgroundColor]) {
    merchCard.style.setProperty(
      "--merch-card-custom-background-color",
      `var(${allowedColors[fields.backgroundColor]})`
    );
    merchCard.setAttribute("background-color", fields.backgroundColor);
  } else if (backgroundColorConfig?.attribute && fields.backgroundColor) {
    merchCard.setAttribute(
      backgroundColorConfig.attribute,
      fields.backgroundColor
    );
    merchCard.style.removeProperty("--merch-card-custom-background-color");
  }
}
function processBorderColor(fields, merchCard, variantMapping) {
  const borderColorConfig = variantMapping?.borderColor;
  const customBorderColor = "--consonant-merch-card-border-color";
  if (fields.borderColor?.toLowerCase() === "transparent") {
    merchCard.style.setProperty(customBorderColor, "transparent");
  } else if (fields.borderColor && borderColorConfig) {
    const specialValue = borderColorConfig?.specialValues?.[fields.borderColor];
    const isGradient = specialValue?.includes("gradient") || /-gradient/.test(fields.borderColor);
    if (isGradient) {
      merchCard.setAttribute("gradient-border", "true");
      let borderColorKey = fields.borderColor;
      if (borderColorConfig?.specialValues) {
        for (const [key, value] of Object.entries(
          borderColorConfig.specialValues
        )) {
          if (value === fields.borderColor) {
            borderColorKey = key;
            break;
          }
        }
      }
      merchCard.setAttribute("border-color", borderColorKey);
      merchCard.style.removeProperty(customBorderColor);
    } else {
      merchCard.style.setProperty(
        customBorderColor,
        `var(--${fields.borderColor})`
      );
    }
  }
}
function processBackgroundImage(fields, merchCard, backgroundImageConfig) {
  if (fields.backgroundImage) {
    const imgAttributes = {
      loading: merchCard.loading ?? "lazy",
      src: fields.backgroundImage
    };
    if (fields.backgroundImageAltText) {
      imgAttributes.alt = fields.backgroundImageAltText;
    } else {
      imgAttributes.role = "none";
    }
    if (!backgroundImageConfig) return;
    if (backgroundImageConfig?.attribute) {
      merchCard.setAttribute(
        backgroundImageConfig.attribute,
        fields.backgroundImage
      );
      return;
    }
    merchCard.append(
      createTag(
        backgroundImageConfig.tag,
        { slot: backgroundImageConfig.slot },
        createTag("img", imgAttributes)
      )
    );
  }
}
function processMnemonicElements(htmlContent) {
  if (!htmlContent || typeof htmlContent !== "string") return htmlContent;
  if (htmlContent.includes("<mas-mnemonic")) {
    Promise.resolve().then(() => (init_mas_mnemonic(), mas_mnemonic_exports)).catch(console.error);
  }
  return htmlContent;
}
function processPrices(fields, merchCard, mapping) {
  if (fields.prices) {
    fields.prices = processMnemonicElements(fields.prices);
  }
  appendSlot("prices", fields, merchCard, mapping);
}
function transformLinkToButton(linkElement, merchCard, aemFragmentMapping) {
  const isCheckoutLink = linkElement.hasAttribute("data-wcs-osi") && Boolean(linkElement.getAttribute("data-wcs-osi"));
  const originalClassName = linkElement.className || "";
  const checkoutLinkStyle = CHECKOUT_STYLE_PATTERN.exec(originalClassName)?.[0] ?? "accent";
  const isAccent = checkoutLinkStyle.includes("accent");
  const isPrimary = checkoutLinkStyle.includes("primary");
  const isSecondary = checkoutLinkStyle.includes("secondary");
  const isOutline = checkoutLinkStyle.includes("-outline");
  const isLinkStyle = checkoutLinkStyle.includes("-link");
  linkElement.classList.remove("accent", "primary", "secondary");
  let newButtonElement;
  if (merchCard.consonant) {
    newButtonElement = createConsonantButton(
      linkElement,
      isAccent,
      isCheckoutLink,
      isLinkStyle,
      isPrimary
    );
  } else if (isLinkStyle) {
    newButtonElement = linkElement;
  } else {
    let variant;
    if (isAccent) {
      variant = "accent";
    } else if (isPrimary) {
      variant = "primary";
    } else if (isSecondary) {
      variant = "secondary";
    }
    newButtonElement = merchCard.spectrum === "swc" ? createSpectrumSwcButton(
      linkElement,
      aemFragmentMapping,
      isOutline,
      variant,
      isCheckoutLink
    ) : createSpectrumCssButton(
      linkElement,
      aemFragmentMapping,
      isOutline,
      variant,
      isCheckoutLink
    );
  }
  return newButtonElement;
}
function processDescriptionLinks(merchCard, aemFragmentMapping) {
  const { slot } = aemFragmentMapping?.description;
  const links = merchCard.querySelectorAll(
    `[slot="${slot}"] a[data-wcs-osi]`
  );
  if (!links.length) return;
  links.forEach((link) => {
    const checkoutLink = transformLinkToButton(
      link,
      merchCard,
      aemFragmentMapping
    );
    link.replaceWith(checkoutLink);
  });
}
function processDescription(fields, merchCard, mapping) {
  if (fields.description) {
    fields.description = processMnemonicElements(fields.description);
  }
  if (fields.promoText) {
    fields.promoText = processMnemonicElements(fields.promoText);
  }
  appendSlot("promoText", fields, merchCard, mapping);
  appendSlot("description", fields, merchCard, mapping);
  processDescriptionLinks(merchCard, mapping);
  appendSlot("callout", fields, merchCard, mapping);
  appendSlot("quantitySelect", fields, merchCard, mapping);
  appendSlot("whatsIncluded", fields, merchCard, mapping);
}
function processAddon(fields, merchCard, mapping) {
  if (!mapping.addon) return;
  let addonField = fields.addon?.replace(/[{}]/g, "");
  if (!addonField) return;
  if (/disabled/.test(addonField)) return;
  const addon = createTag("merch-addon", { slot: "addon" }, addonField);
  [...addon.querySelectorAll(SELECTOR_MAS_INLINE_PRICE)].forEach((span) => {
    const parent = span.parentElement;
    if (parent?.nodeName !== "P") return;
    parent.setAttribute("data-plan-type", "");
  });
  merchCard.append(addon);
}
function processAddonConfirmation(fields, merchCard, mapping) {
  if (fields.addonConfirmation) {
    appendSlot("addonConfirmation", fields, merchCard, mapping);
  }
}
function processStockOffersAndSecureLabel(fields, merchCard, aemFragmentMapping, settings) {
  if (settings?.secureLabel && aemFragmentMapping?.secureLabel) {
    merchCard.setAttribute("secure-label", settings.secureLabel);
  }
}
function getTruncatedTextData(text, limit, withSuffix = true) {
  try {
    const _text = typeof text !== "string" ? "" : text;
    const cleanText = clearTags(_text);
    if (cleanText.length <= limit) return [_text, cleanText];
    let index = 0;
    let inTag = false;
    let remaining = withSuffix ? limit - TEXT_TRUNCATE_SUFFIX.length < 1 ? 1 : limit - TEXT_TRUNCATE_SUFFIX.length : limit;
    let openTags = [];
    for (const char of _text) {
      index++;
      if (char === "<") {
        inTag = true;
        if (_text[index] === "/") {
          openTags.pop();
        } else {
          let tagName = "";
          for (const tagChar of _text.substring(index)) {
            if (tagChar === " " || tagChar === ">") break;
            tagName += tagChar;
          }
          openTags.push(tagName);
        }
      }
      if (char === "/") {
        if (_text[index] === ">") {
          openTags.pop();
        }
      }
      if (char === ">") {
        inTag = false;
        continue;
      }
      if (inTag) continue;
      remaining--;
      if (remaining === 0) break;
    }
    let trimmedText = _text.substring(0, index).trim();
    if (openTags.length > 0) {
      if (openTags[0] === "p") openTags.shift();
      for (const tag of openTags.reverse()) {
        trimmedText += `</${tag}>`;
      }
    }
    let truncatedText = `${trimmedText}${withSuffix ? TEXT_TRUNCATE_SUFFIX : ""}`;
    return [truncatedText, cleanText];
  } catch (error) {
    const fallbackText = typeof text === "string" ? text : "";
    const cleanFallback = clearTags(fallbackText);
    return [fallbackText, cleanFallback];
  }
}
function clearTags(text) {
  if (!text) return "";
  let result = "";
  let inTag = false;
  for (const char of text) {
    if (char === "<") inTag = true;
    if (char === ">") {
      inTag = false;
      continue;
    }
    if (inTag) continue;
    result += char;
  }
  return result;
}
function processUptLinks(fields, merchCard) {
  const placeholders = merchCard.querySelectorAll("a.upt-link");
  placeholders.forEach((placeholder) => {
    const uptLink = UptLink.createFrom(placeholder);
    placeholder.replaceWith(uptLink);
    uptLink.initializeWcsData(fields.osi, fields.promoCode);
  });
}
function createSpectrumCssButton(cta, aemFragmentMapping, isOutline, variant, isCheckout) {
  let button = cta;
  if (isCheckout) {
    const CheckoutButton2 = customElements.get("checkout-button");
    button = CheckoutButton2.createCheckoutButton({}, cta.innerHTML);
  } else {
    button.innerHTML = `<span>${button.textContent}</span>`;
  }
  button.setAttribute("tabindex", 0);
  for (const attr of cta.attributes) {
    if (["class", "is"].includes(attr.name)) continue;
    button.setAttribute(attr.name, attr.value);
  }
  button.firstElementChild?.classList.add("spectrum-Button-label");
  const size = aemFragmentMapping?.ctas?.size ?? "M";
  const variantClass = `spectrum-Button--${variant}`;
  const sizeClass = SPECTRUM_BUTTON_SIZES.includes(size) ? `spectrum-Button--size${size}` : "spectrum-Button--sizeM";
  const spectrumClass = ["spectrum-Button", variantClass, sizeClass];
  if (isOutline) {
    spectrumClass.push("spectrum-Button--outline");
  }
  button.classList.add(...spectrumClass);
  return button;
}
function createSpectrumSwcButton(cta, aemFragmentMapping, isOutline, variant, isCheckout) {
  let button = cta;
  if (isCheckout) {
    const CheckoutButton2 = customElements.get("checkout-button");
    button = CheckoutButton2.createCheckoutButton(cta.dataset);
    button.connectedCallback();
    button.render();
  }
  let treatment = "fill";
  if (isOutline) {
    treatment = "outline";
  }
  const spectrumCta = createTag(
    "sp-button",
    {
      treatment,
      variant,
      tabIndex: 0,
      size: aemFragmentMapping?.ctas?.size ?? "m",
      ...cta.dataset.analyticsId && {
        "data-analytics-id": cta.dataset.analyticsId
      }
    },
    cta.innerHTML
  );
  spectrumCta.source = button;
  (isCheckout ? button.onceSettled() : Promise.resolve(button)).then(
    (target) => {
      spectrumCta.setAttribute("data-navigation-url", target.href);
    }
  );
  spectrumCta.addEventListener("click", (e4) => {
    if (e4.defaultPrevented) return;
    button.click();
  });
  return spectrumCta;
}
function createConsonantButton(cta, isAccent, isCheckout, isLinkStyle, isPrimary) {
  let button = cta;
  if (isCheckout) {
    const CheckoutLink2 = customElements.get("checkout-link");
    button = CheckoutLink2.createCheckoutLink(cta.dataset, cta.innerHTML);
  }
  if (!isLinkStyle) {
    button.classList.add("button", "con-button");
    if (isAccent) {
      button.classList.add("blue");
    }
    if (isPrimary) {
      button.classList.add("primary");
    }
  }
  return button;
}
function processCTAs(fields, merchCard, aemFragmentMapping, variant) {
  if (fields.ctas) {
    fields.ctas = processMnemonicElements(fields.ctas);
    const { slot } = aemFragmentMapping.ctas;
    const footer = createTag("div", { slot }, fields.ctas);
    const ctas = [...footer.querySelectorAll("a")].map((cta) => {
      const checkoutButton = transformLinkToButton(
        cta,
        merchCard,
        aemFragmentMapping
      );
      return checkoutButton;
    });
    footer.innerHTML = "";
    footer.append(...ctas);
    merchCard.append(footer);
  }
}
function processAnalytics(fields, merchCard) {
  const { tags } = fields;
  const cardAnalyticsId = tags?.find((tag) => tag.startsWith(ANALYTICS_TAG))?.split("/").pop();
  if (!cardAnalyticsId) return;
  merchCard.setAttribute(ANALYTICS_SECTION_ATTR, cardAnalyticsId);
  const elements = [
    ...merchCard.shadowRoot.querySelectorAll(
      `a[data-analytics-id],button[data-analytics-id]`
    ),
    ...merchCard.querySelectorAll(
      `a[data-analytics-id],button[data-analytics-id]`
    )
  ];
  elements.forEach((el, index) => {
    el.setAttribute(
      ANALYTICS_LINK_ATTR,
      `${el.dataset.analyticsId}-${index + 1}`
    );
  });
}
function updateLinksCSS(merchCard) {
  if (merchCard.spectrum !== "css") return;
  [
    ["primary-link", "primary"],
    ["secondary-link", "secondary"]
  ].forEach(([className, variant]) => {
    merchCard.querySelectorAll(`a.${className}`).forEach((link) => {
      link.classList.remove(className);
      link.classList.add("spectrum-Link", `spectrum-Link--${variant}`);
    });
  });
}
function cleanup(merchCard) {
  merchCard.querySelectorAll("[slot]").forEach((el) => {
    el.remove();
  });
  merchCard.variant = void 0;
  const attributesToRemove = [
    "checkbox-label",
    "stock-offer-osis",
    "secure-label",
    "background-image",
    "background-color",
    "border-color",
    "badge-background-color",
    "badge-color",
    "badge-text",
    "gradient-border",
    "size",
    ANALYTICS_SECTION_ATTR
  ];
  attributesToRemove.forEach((attr) => merchCard.removeAttribute(attr));
  const classesToRemove = ["wide-strip", "thin-strip"];
  merchCard.classList.remove(...classesToRemove);
}
async function hydrate(fragment, merchCard) {
  if (!fragment) {
    const cardIdForError = merchCard?.id || "unknown";
    console.error(
      `hydrate: Fragment is undefined. Cannot hydrate card (merchCard id: ${cardIdForError}).`
    );
    throw new Error(
      `hydrate: Fragment is undefined for card (merchCard id: ${cardIdForError}).`
    );
  }
  if (!fragment.fields) {
    const problemId = fragment.id || "unknown";
    const cardIdForError = merchCard?.id || "unknown";
    console.error(
      `hydrate: Fragment for card ID '${problemId}' (merchCard id: ${cardIdForError}) is missing 'fields'. Cannot hydrate.`
    );
    throw new Error(
      `hydrate: Fragment for card ID '${problemId}' (merchCard id: ${cardIdForError}) is missing 'fields'.`
    );
  }
  const { id, fields, settings = {}, priceLiterals: priceLiterals2 } = fragment;
  const { variant } = fields;
  if (!variant) throw new Error(`hydrate: no variant found in payload ${id}`);
  cleanup(merchCard);
  merchCard.settings = settings;
  if (priceLiterals2) merchCard.priceLiterals = priceLiterals2;
  merchCard.id ?? (merchCard.id = fragment.id);
  merchCard.variant = variant;
  await merchCard.updateComplete;
  const { aemFragmentMapping: mapping } = merchCard.variantLayout;
  if (!mapping)
    throw new Error(`hydrate: variant mapping not found for ${id}`);
  if (mapping.style === "consonant") {
    merchCard.setAttribute("consonant", true);
  }
  processMnemonics(fields, merchCard, mapping.mnemonics);
  processBadge(fields, merchCard, mapping);
  processTrialBadge(fields, merchCard, mapping);
  processSize(fields, merchCard, mapping.size);
  processCardName(fields, merchCard);
  processTitle(fields, merchCard, mapping.title);
  processSubtitle(fields, merchCard, mapping);
  processPrices(fields, merchCard, mapping);
  processBackgroundImage(fields, merchCard, mapping.backgroundImage);
  processBackgroundColor(
    fields,
    merchCard,
    mapping.allowedColors,
    mapping.backgroundColor
  );
  processBorderColor(fields, merchCard, mapping);
  processDescription(fields, merchCard, mapping);
  processAddon(fields, merchCard, mapping);
  processAddonConfirmation(fields, merchCard, mapping);
  processStockOffersAndSecureLabel(fields, merchCard, mapping, settings);
  processUptLinks(fields, merchCard);
  processCTAs(fields, merchCard, mapping, variant);
  processAnalytics(fields, merchCard);
  updateLinksCSS(merchCard);
}

// src/merch-card.js
var MERCH_CARD = "merch-card";
var MERCH_CARD_LOAD_TIMEOUT = 2e4;
var MARK_MERCH_CARD_PREFIX = "merch-card:";
function priceOptionsProvider(element, options) {
  const card = element.closest(MERCH_CARD);
  if (!card) return options;
  if (card.priceLiterals) {
    options.literals ?? (options.literals = {});
    Object.assign(options.literals, card.priceLiterals);
  }
  card.variantLayout?.priceOptionsProvider?.(element, options);
}
function registerPriceOptionsProvider(masCommerceService) {
  if (masCommerceService.providers.has(priceOptionsProvider)) return;
  masCommerceService.providers.price(priceOptionsProvider);
}
var idCounter = 0;
var _durationMarkName, _internalId, _log2, _service4, _startMarkName, _resolveHydration, _hydrationPromise, _MerchCard_instances, fail_fn2, regularPrice_get, legal_get, getCta_fn;
var MerchCard = class extends s4 {
  constructor() {
    super();
    __privateAdd(this, _MerchCard_instances);
    __privateAdd(this, _durationMarkName);
    __privateAdd(this, _internalId);
    // internal unique card identifier
    __privateAdd(this, _log2);
    __privateAdd(this, _service4);
    __privateAdd(this, _startMarkName);
    __privateAdd(this, _resolveHydration);
    __privateAdd(this, _hydrationPromise, new Promise((resolve) => {
      __privateSet(this, _resolveHydration, resolve);
    }));
    __publicField(this, "customerSegment");
    __publicField(this, "marketSegment");
    /**
     * @type {VariantLayout}
     */
    __publicField(this, "variantLayout");
    this.id = null;
    this.failed = false;
    this.filters = {};
    this.types = "";
    this.selected = false;
    this.spectrum = "css";
    this.loading = "lazy";
    this.handleAemFragmentEvents = this.handleAemFragmentEvents.bind(this);
    this.handleMerchOfferSelectReady = this.handleMerchOfferSelectReady.bind(this);
  }
  firstUpdated() {
    this.variantLayout = getVariantLayout(this);
    this.variantLayout?.connectedCallbackHook();
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("variant") || !this.variantLayout) {
      this.variantLayout = getVariantLayout(this);
      this.variantLayout?.connectedCallbackHook();
    }
  }
  updated(changedProperties) {
    if (changedProperties.has("badgeBackgroundColor") || changedProperties.has("borderColor")) {
      this.style.setProperty(
        "--consonant-merch-card-border",
        this.computedBorderStyle
      );
    }
    if (changedProperties.has("backgroundColor")) {
      this.style.setProperty(
        "--merch-card-custom-background-color",
        this.backgroundColor ? `var(--${this.backgroundColor})` : ""
      );
    }
    try {
      this.variantLayoutPromise = this.variantLayout?.postCardUpdateHook(changedProperties);
    } catch (e4) {
      __privateMethod(this, _MerchCard_instances, fail_fn2).call(this, `Error in postCardUpdateHook: ${e4.message}`, {}, false);
    }
  }
  get theme() {
    return this.closest("sp-theme");
  }
  get dir() {
    return this.closest("[dir]")?.getAttribute("dir") ?? "ltr";
  }
  render() {
    if (!this.isConnected || !this.variantLayout || this.style.display === "none")
      return;
    return this.variantLayout.renderLayout();
  }
  get computedBorderStyle() {
    if (![
      "ccd-slice",
      "ccd-suggested",
      "ah-promoted-plans",
      "simplified-pricing-express"
    ].includes(this.variant)) {
      return `1px solid ${this.borderColor ? this.borderColor : this.badgeBackgroundColor}`;
    }
    return "";
  }
  get badgeElement() {
    return this.shadowRoot.getElementById("badge");
  }
  get headingmMSlot() {
    return this.shadowRoot.querySelector('slot[name="heading-m"]').assignedElements()[0];
  }
  get footerSlot() {
    return this.shadowRoot.querySelector('slot[name="footer"]')?.assignedElements()[0];
  }
  get descriptionSlot() {
    return this.shadowRoot.querySelector('slot[name="body-xs"')?.assignedElements()[0];
  }
  get descriptionSlotCompare() {
    return this.shadowRoot.querySelector('slot[name="body-m"')?.assignedElements()[0];
  }
  get price() {
    return this.headingmMSlot?.querySelector(SELECTOR_MAS_INLINE_PRICE);
  }
  get checkoutLinks() {
    return [
      ...this.footerSlot?.querySelectorAll(SELECTOR_MAS_CHECKOUT_LINK) ?? []
    ];
  }
  get checkoutLinksDescription() {
    return [
      ...this.descriptionSlot?.querySelectorAll(
        SELECTOR_MAS_CHECKOUT_LINK
      ) ?? []
    ];
  }
  get checkoutLinkDescriptionCompare() {
    return [
      ...this.descriptionSlotCompare?.querySelectorAll(
        SELECTOR_MAS_CHECKOUT_LINK
      ) ?? []
    ];
  }
  get activeDescriptionLinks() {
    if (this.variant === "mini-compare-chart") {
      return this.checkoutLinkDescriptionCompare;
    }
    return this.checkoutLinksDescription;
  }
  async toggleStockOffer({ target }) {
    if (!this.stockOfferOsis) return;
    const elements = this.checkoutLinks;
    if (elements.length === 0) return;
    for (const element of elements) {
      await element.onceSettled();
      const planType = element.value?.[0]?.planType;
      if (!planType) return;
      const stockOfferOsi = this.stockOfferOsis[planType];
      if (!stockOfferOsi) return;
      const osis = element.dataset.wcsOsi.split(",").filter((osi) => osi !== stockOfferOsi);
      if (target.checked) {
        osis.push(stockOfferOsi);
      }
      element.dataset.wcsOsi = osis.join(",");
    }
  }
  changeHandler(event) {
    if (event.target.tagName === "MERCH-ADDON") {
      this.toggleAddon(event.target);
    }
  }
  toggleAddon(merchAddon) {
    this.variantLayout?.toggleAddon?.(merchAddon);
    const allLinks = [
      ...this.checkoutLinks,
      ...this.activeDescriptionLinks ?? []
    ];
    if (allLinks.length === 0) return;
    const updateOsi = (link) => {
      const { offerType, planType } = link.value?.[0] ?? {};
      if (!offerType || !planType) return;
      const addonOsi = merchAddon.getOsi(planType, offerType);
      const osis = (link.dataset.wcsOsi || "").split(",").filter((osi) => osi && osi !== addonOsi);
      if (merchAddon.checked) {
        osis.push(addonOsi);
      }
      link.dataset.wcsOsi = osis.join(",");
    };
    allLinks.forEach(updateOsi);
  }
  handleQuantitySelection(event) {
    const allLinks = [
      ...this.checkoutLinks,
      ...this.activeDescriptionLinks ?? []
    ];
    if (allLinks.length === 0) return;
    for (const link of allLinks) {
      link.dataset.quantity = event.detail.option;
    }
  }
  get titleElement() {
    return this.querySelector(
      this.variantLayout?.headingSelector || ".card-heading"
    );
  }
  get title() {
    return this.titleElement?.textContent?.trim();
  }
  /* c8 ignore next 3 */
  get description() {
    return this.querySelector('[slot="body-xs"]')?.textContent?.trim();
  }
  /**
   * If the card is the single app, set the order for all filters to 2.
   * If not, increment the order for all filters after the second card by 1.
   * @param {*} singleApp
   */
  updateFilters(singleApp) {
    const newFilters = { ...this.filters };
    Object.keys(newFilters).forEach((key) => {
      if (singleApp) {
        newFilters[key].order = Math.min(newFilters[key].order || 2, 2);
        return;
      }
      const value = newFilters[key].order;
      if (value === 1 || isNaN(value)) return;
      newFilters[key].order = Number(value) + 1;
    });
    this.filters = newFilters;
  }
  /* c8 ignore next 3 */
  includes(text) {
    return this.textContent.match(new RegExp(text, "i")) !== null;
  }
  connectedCallback() {
    var _a2;
    super.connectedCallback();
    if (!__privateGet(this, _internalId)) {
      __privateSet(this, _internalId, idCounter++);
    }
    if (!this.aemFragment) {
      (_a2 = __privateGet(this, _resolveHydration)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _resolveHydration, void 0);
    }
    this.id ?? (this.id = this.getAttribute("id") ?? this.aemFragment?.getAttribute("fragment"));
    const logId = this.id ?? __privateGet(this, _internalId);
    __privateSet(this, _startMarkName, `${MARK_MERCH_CARD_PREFIX}${logId}${MARK_START_SUFFIX}`);
    __privateSet(this, _durationMarkName, `${MARK_MERCH_CARD_PREFIX}${logId}${MARK_DURATION_SUFFIX}`);
    performance.mark(__privateGet(this, _startMarkName));
    __privateSet(this, _service4, getService2());
    registerPriceOptionsProvider(__privateGet(this, _service4));
    __privateSet(this, _log2, __privateGet(this, _service4).Log.module(MERCH_CARD));
    this.addEventListener(
      EVENT_MERCH_QUANTITY_SELECTOR_CHANGE,
      this.handleQuantitySelection
    );
    this.addEventListener(
      EVENT_MERCH_ADDON_AND_QUANTITY_UPDATE,
      this.handleAddonAndQuantityUpdate
    );
    this.addEventListener(
      EVENT_MERCH_OFFER_SELECT_READY,
      this.handleMerchOfferSelectReady
    );
    this.addEventListener(EVENT_AEM_ERROR, this.handleAemFragmentEvents);
    this.addEventListener(EVENT_AEM_LOAD, this.handleAemFragmentEvents);
    this.addEventListener("change", this.changeHandler);
    if (!this.aemFragment) {
      setTimeout(() => this.checkReady(), 0);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.variantLayout?.disconnectedCallbackHook();
    this.removeEventListener(
      EVENT_MERCH_QUANTITY_SELECTOR_CHANGE,
      this.handleQuantitySelection
    );
    this.removeEventListener(EVENT_AEM_ERROR, this.handleAemFragmentEvents);
    this.removeEventListener(EVENT_AEM_LOAD, this.handleAemFragmentEvents);
    this.removeEventListener("change", this.changeHandler);
    this.removeEventListener(
      EVENT_MERCH_ADDON_AND_QUANTITY_UPDATE,
      this.handleAddonAndQuantityUpdate
    );
  }
  // custom methods
  async handleAemFragmentEvents(e4) {
    var _a2;
    if (!this.isConnected) return;
    if (e4.type === EVENT_AEM_ERROR) {
      __privateMethod(this, _MerchCard_instances, fail_fn2).call(this, `AEM fragment cannot be loaded`);
    }
    if (e4.type === EVENT_AEM_LOAD) {
      this.failed = false;
      if (e4.target.nodeName === "AEM-FRAGMENT") {
        const fragment = e4.detail;
        try {
          if (!__privateGet(this, _resolveHydration)) {
            __privateSet(this, _hydrationPromise, new Promise((resolve) => {
              __privateSet(this, _resolveHydration, resolve);
            }));
          }
          hydrate(fragment, this);
        } catch (e5) {
          __privateMethod(this, _MerchCard_instances, fail_fn2).call(this, `hydration has failed: ${e5.message}`);
        } finally {
          (_a2 = __privateGet(this, _resolveHydration)) == null ? void 0 : _a2.call(this);
          __privateSet(this, _resolveHydration, void 0);
        }
        this.checkReady();
      }
    }
  }
  async checkReady() {
    if (!this.isConnected) return;
    if (__privateGet(this, _hydrationPromise)) {
      await __privateGet(this, _hydrationPromise);
      __privateSet(this, _hydrationPromise, void 0);
    }
    if (this.variantLayoutPromise) {
      await this.variantLayoutPromise;
      this.variantLayoutPromise = void 0;
    }
    const timeoutPromise = new Promise(
      (resolve) => setTimeout(() => resolve("timeout"), MERCH_CARD_LOAD_TIMEOUT)
    );
    if (this.aemFragment) {
      const result2 = await Promise.race([
        this.aemFragment.updateComplete,
        timeoutPromise
      ]);
      if (result2 === false || result2 === "timeout") {
        const errorMessage = result2 === "timeout" ? `AEM fragment was not resolved within ${MERCH_CARD_LOAD_TIMEOUT} timeout` : "AEM fragment cannot be loaded";
        __privateMethod(this, _MerchCard_instances, fail_fn2).call(this, errorMessage, {}, false);
        return;
      }
    }
    const masElements = [...this.querySelectorAll(SELECTOR_MAS_ELEMENT)];
    const successPromise = Promise.all(
      masElements.map(
        (element) => element.onceSettled().catch(() => element)
      )
    ).then(
      (elements) => elements.every(
        (el) => el.classList.contains("placeholder-resolved")
      )
    );
    const result = await Promise.race([successPromise, timeoutPromise]);
    if (result === true) {
      this.measure = performance.measure(
        __privateGet(this, _durationMarkName),
        __privateGet(this, _startMarkName)
      );
      const detail = {
        ...this.aemFragment?.fetchInfo,
        ...__privateGet(this, _service4).duration,
        measure: printMeasure(this.measure)
      };
      this.dispatchEvent(
        new CustomEvent(EVENT_MAS_READY, {
          bubbles: true,
          composed: true,
          detail
        })
      );
      return this;
    } else {
      this.measure = performance.measure(
        __privateGet(this, _durationMarkName),
        __privateGet(this, _startMarkName)
      );
      const details = {
        measure: printMeasure(this.measure),
        ...__privateGet(this, _service4).duration
      };
      if (result === "timeout") {
        __privateMethod(this, _MerchCard_instances, fail_fn2).call(this, `Contains offers that were not resolved within ${MERCH_CARD_LOAD_TIMEOUT} timeout`, details);
      } else {
        __privateMethod(this, _MerchCard_instances, fail_fn2).call(this, `Contains unresolved offers`, details);
      }
    }
  }
  get aemFragment() {
    return this.querySelector("aem-fragment");
  }
  get addon() {
    return this.querySelector("merch-addon");
  }
  /* c8 ignore next 3 */
  get quantitySelect() {
    return this.querySelector("merch-quantity-select");
  }
  get addonCheckbox() {
    return this.querySelector("merch-addon");
  }
  displayFooterElementsInColumn() {
    if (!this.classList.contains("product")) return;
    const secureTransactionLabel = this.shadowRoot.querySelector(
      ".secure-transaction-label"
    );
    const checkoutLinkCtas = this.footerSlot?.querySelectorAll(
      SELECTOR_MAS_CHECKOUT_LINK
    );
    if (checkoutLinkCtas.length === 2 && secureTransactionLabel) {
      secureTransactionLabel.parentElement.classList.add("footer-column");
    }
  }
  handleMerchOfferSelectReady() {
    if (this.offerSelect && !this.offerSelect.planType) return;
    this.displayFooterElementsInColumn();
  }
  /* c8 ignore next 3 */
  get dynamicPrice() {
    return this.querySelector('[slot="price"]');
  }
  handleAddonAndQuantityUpdate({ detail: { id, items } }) {
    if (!id || !items?.length) return;
    const parentTab = this.closest('[role="tabpanel"][hidden="true"]');
    if (parentTab) return;
    const cta = this.checkoutLinks.find(
      (link) => link.getAttribute("data-modal-id") === id
    );
    if (!cta) return;
    const url = new URL(cta.getAttribute("href"));
    const pa = url.searchParams.get("pa");
    const mainProductQuantity = items.find(
      (item) => item.productArrangementCode === pa
    )?.quantity;
    const isAddonIncluded = !!items.find(
      (item) => item.productArrangementCode !== pa
    );
    if (mainProductQuantity) {
      this.quantitySelect?.dispatchEvent(
        new CustomEvent(EVENT_MERCH_CARD_QUANTITY_CHANGE, {
          detail: { quantity: mainProductQuantity },
          bubbles: true,
          composed: true
        })
      );
    }
    if (this.addonCheckbox && this.addonCheckbox.checked !== isAddonIncluded) {
      this.toggleStockOffer({ target: this.addonCheckbox });
      const checkboxEvent = new Event("change", {
        bubbles: true,
        cancelable: true
      });
      Object.defineProperty(checkboxEvent, "target", {
        writable: false,
        value: { checked: isAddonIncluded }
      });
      this.addonCheckbox.handleChange(checkboxEvent);
    }
  }
  get prices() {
    return Array.from(this.querySelectorAll(SELECTOR_MAS_INLINE_PRICE));
  }
  get promoPrice() {
    if (!this.querySelector(`span.price-strikethrough`)) return;
    let price2 = this.querySelector(`.price.price-alternative`);
    if (!price2) {
      price2 = this.querySelector(
        `${SELECTOR_MAS_INLINE_PRICE}[data-template="price"] > span`
      );
    }
    if (!price2) return;
    price2 = price2.innerText;
    return price2;
  }
  get regularPrice() {
    return __privateGet(this, _MerchCard_instances, regularPrice_get)?.innerText;
  }
  get promotionCode() {
    const promotionCodes = [
      ...this.querySelectorAll(
        `${SELECTOR_MAS_INLINE_PRICE}[data-promotion-code],${SELECTOR_MAS_CHECKOUT_LINK}[data-promotion-code]`
      )
    ].map((el) => el.dataset.promotionCode);
    const uniqueCodes = [...new Set(promotionCodes)];
    if (uniqueCodes.length > 1) {
      __privateGet(this, _log2)?.warn(
        `Multiple different promotion codes found: ${uniqueCodes.join(", ")}`
      );
    }
    return promotionCodes[0];
  }
  get annualPrice() {
    const price2 = this.querySelector(
      `${SELECTOR_MAS_INLINE_PRICE}[data-template="price"] > .price.price-annual`
    );
    return price2?.innerText;
  }
  get promoText() {
    return void 0;
  }
  get taxText() {
    return (__privateGet(this, _MerchCard_instances, legal_get) ?? __privateGet(this, _MerchCard_instances, regularPrice_get))?.querySelector("span.price-tax-inclusivity")?.textContent?.trim() || void 0;
  }
  get recurrenceText() {
    return __privateGet(this, _MerchCard_instances, regularPrice_get)?.querySelector("span.price-recurrence")?.textContent?.trim();
  }
  get planTypeText() {
    return this.querySelector(
      '[is="inline-price"][data-template="legal"] span.price-plan-type'
    )?.textContent?.trim();
  }
  get seeTermsInfo() {
    const seeTerms = this.querySelector('a[is="upt-link"]');
    if (!seeTerms) return void 0;
    return __privateMethod(this, _MerchCard_instances, getCta_fn).call(this, seeTerms);
  }
  get renewalText() {
    return this.querySelector("span.renewal-text")?.textContent?.trim();
  }
  get promoDurationText() {
    return this.querySelector(
      "span.promo-duration-text"
    )?.textContent?.trim();
  }
  get ctas() {
    const ctas = this.querySelector(
      '[slot="ctas"], [slot="footer"]'
    )?.querySelectorAll(`${SELECTOR_MAS_CHECKOUT_LINK}, a`);
    return Array.from(ctas ?? []);
  }
  get primaryCta() {
    return __privateMethod(this, _MerchCard_instances, getCta_fn).call(this, this.ctas.find(
      (cta) => cta.variant === "accent" || cta.matches(".spectrum-Button--accent,.con-button.blue")
    ));
  }
  get secondaryCta() {
    return __privateMethod(this, _MerchCard_instances, getCta_fn).call(this, this.ctas.find(
      (cta) => cta.variant !== "accent" && !cta.matches(".spectrum-Button--accent,.con-button.blue")
    ));
  }
};
_durationMarkName = new WeakMap();
_internalId = new WeakMap();
_log2 = new WeakMap();
_service4 = new WeakMap();
_startMarkName = new WeakMap();
_resolveHydration = new WeakMap();
_hydrationPromise = new WeakMap();
_MerchCard_instances = new WeakSet();
fail_fn2 = function(error, details = {}, dispatch = true) {
  if (!this.isConnected) return;
  const aemFragment = this.aemFragment;
  let fragmentId = aemFragment?.getAttribute("fragment");
  fragmentId = `[${fragmentId}]`;
  const detail = {
    ...this.aemFragment?.fetchInfo,
    ...__privateGet(this, _service4).duration,
    ...details,
    message: error
  };
  __privateGet(this, _log2).error(`merch-card${fragmentId}: ${error}`, detail);
  this.failed = true;
  if (!dispatch) return;
  this.dispatchEvent(
    new CustomEvent(EVENT_MAS_ERROR, {
      bubbles: true,
      composed: true,
      detail
    })
  );
};
regularPrice_get = function() {
  return this.querySelector(`span.price-strikethrough`) ?? this.querySelector(
    `${SELECTOR_MAS_INLINE_PRICE}[data-template="price"] > span`
  );
};
legal_get = function() {
  return this.querySelector(
    `${SELECTOR_MAS_INLINE_PRICE}[data-template="legal"]`
  );
};
getCta_fn = function(element) {
  if (!element) return void 0;
  return {
    text: element.innerText.trim(),
    analyticsId: element.dataset.analyticsId,
    href: element.getAttribute("href") ?? element.dataset.href
  };
};
__publicField(MerchCard, "properties", {
  id: { type: String, attribute: "id", reflect: true },
  name: { type: String, attribute: "name", reflect: true },
  variant: { type: String, reflect: true },
  size: { type: String, attribute: "size", reflect: true },
  badgeColor: { type: String, attribute: "badge-color", reflect: true },
  borderColor: { type: String, attribute: "border-color", reflect: true },
  backgroundColor: {
    type: String,
    attribute: "background-color",
    reflect: true
  },
  badgeBackgroundColor: {
    type: String,
    attribute: "badge-background-color",
    reflect: true
  },
  backgroundImage: {
    type: String,
    attribute: "background-image",
    reflect: true
  },
  badgeText: { type: String, attribute: "badge-text" },
  actionMenu: { type: Boolean, attribute: "action-menu" },
  actionMenuLabel: { type: String, attribute: "action-menu-label" },
  customHr: { type: Boolean, attribute: "custom-hr" },
  consonant: { type: Boolean, attribute: "consonant" },
  failed: { type: Boolean, attribute: "failed", reflect: true },
  spectrum: { type: String, attribute: "spectrum" },
  detailBg: { type: String, attribute: "detail-bg" },
  secureLabel: { type: String, attribute: "secure-label" },
  checkboxLabel: { type: String, attribute: "checkbox-label" },
  addonTitle: { type: String, attribute: "addon-title" },
  addonOffers: { type: Object, attribute: "addon-offers" },
  selected: { type: Boolean, attribute: "aria-selected", reflect: true },
  storageOption: { type: String, attribute: "storage", reflect: true },
  planType: { type: String, attribute: "plan-type", reflect: true },
  settings: {
    type: Object,
    attribute: false
  },
  stockOfferOsis: {
    type: Object,
    attribute: "stock-offer-osis",
    converter: {
      fromAttribute: (value) => {
        if (!value) return;
        const [PUF2, ABM2, M2M2] = value.split(",");
        return { PUF: PUF2, ABM: ABM2, M2M: M2M2 };
      }
    }
  },
  filters: {
    type: String,
    reflect: true,
    converter: {
      fromAttribute: (value) => {
        return Object.fromEntries(
          value.split(",").map((filter) => {
            const [key, order, size] = filter.split(":");
            const value2 = Number(order);
            return [
              key,
              {
                order: isNaN(value2) ? void 0 : value2,
                size
              }
            ];
          })
        );
      },
      toAttribute: (value) => {
        return Object.entries(value).map(
          ([key, { order, size }]) => [key, order, size].filter((v2) => v2 != void 0).join(":")
        ).join(",");
      }
    }
  },
  types: {
    type: String,
    attribute: "types",
    reflect: true
  },
  merchOffer: { type: Object },
  analyticsId: {
    type: String,
    attribute: ANALYTICS_SECTION_ATTR,
    reflect: true
  },
  loading: { type: String },
  priceLiterals: { type: Object }
});
__publicField(MerchCard, "styles", [styles, ...sizeStyles()]);
__publicField(MerchCard, "registerVariant", registerVariant);
__publicField(MerchCard, "getCollectionOptions", getCollectionOptions);
__publicField(MerchCard, "getFragmentMapping", getFragmentMapping);
customElements.define(MERCH_CARD, MerchCard);

// src/merch-offer-select.js
init_lit();
var _handleOfferSelectionByQuantityFn;
var MerchOfferSelect = class extends s4 {
  constructor() {
    super();
    __privateAdd(this, _handleOfferSelectionByQuantityFn);
    this.defaults = {};
    this.variant = "plans";
  }
  /** Returns the default values for the price, cta, and description slots.
   * These are the values coming from the container itself, not from the merch-offer elements.
   * E.g. initial merch-card description text. There is no default price or cta in the container.
   */
  saveContainerDefaultValues() {
    const container = this.closest(this.getAttribute("container"));
    const description = container?.querySelector('[slot="description"]:not(merch-offer > *)')?.cloneNode(true);
    const badgeText = container?.badgeText;
    return {
      description,
      badgeText
    };
  }
  getSlottedElement(slotName, container) {
    const containerEl = container || this.closest(this.getAttribute("container"));
    return containerEl.querySelector(
      `[slot="${slotName}"]:not(merch-offer > *)`
    );
  }
  updateSlot(slotName, container) {
    const slot = this.getSlottedElement(slotName, container);
    if (!slot) return;
    const node = this.selectedOffer.getOptionValue(slotName) ? this.selectedOffer.getOptionValue(slotName) : this.defaults[slotName];
    if (node) {
      slot.replaceWith(node.cloneNode(true));
    }
  }
  handleOfferSelection(e4) {
    const newOffer = e4.detail;
    this.selectOffer(newOffer);
  }
  handleOfferSelectionByQuantity(event) {
    const selected = event.detail.option;
    const selectedValue = Number.parseInt(selected);
    const newOffer = this.findAppropriateOffer(selectedValue);
    this.selectOffer(newOffer);
    const cta = this.getSlottedElement("cta");
    cta.setAttribute("data-quantity", selectedValue);
  }
  selectOffer(newOffer) {
    if (!newOffer) {
      return;
    }
    const previousOffer = this.selectedOffer;
    if (previousOffer) {
      previousOffer.selected = false;
    }
    newOffer.selected = true;
    this.selectedOffer = newOffer;
    this.planType = newOffer.planType;
    this.updateContainer();
    this.updateComplete.then(() => {
      this.dispatchEvent(
        new CustomEvent(EVENT_OFFER_SELECTED, {
          detail: this,
          bubbles: true
        })
      );
    });
  }
  findAppropriateOffer(selectedValue) {
    let previousOfferWithValue = null;
    const foundOffer = this.offers.find((offer) => {
      const offerAttribute = Number.parseInt(offer.getAttribute("value"));
      if (offerAttribute === selectedValue) {
        return true;
      } else if (offerAttribute > selectedValue) {
        return false;
      } else {
        previousOfferWithValue = offer;
      }
    });
    return foundOffer || previousOfferWithValue;
  }
  /**
   * If badge text is empty string - delete the badge.
   * If badge text is present - set the badge.
   * If badge text is null or undefined - set default badge. */
  updateBadgeText(container) {
    if (this.selectedOffer.badgeText === "") {
      container.badgeText = null;
    } else if (this.selectedOffer.badgeText) {
      container.badgeText = this.selectedOffer.badgeText;
    } else {
      container.badgeText = this.defaults.badgeText;
    }
  }
  /** Will update price, cta, and other slots/properties in parent container (e.g. merch-card) */
  updateContainer() {
    const container = this.closest(this.getAttribute("container"));
    if (!container || !this.selectedOffer) return;
    this.updateSlot("cta", container);
    this.updateSlot("secondary-cta", container);
    this.updateSlot("price", container);
    if (this.manageableMode) return;
    this.updateSlot("description", container);
    this.updateBadgeText(container);
  }
  render() {
    return x`<fieldset><slot class="${this.variant}"></slot></fieldset>`;
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("focusin", this.handleFocusin);
    this.addEventListener("click", this.handleFocusin);
    this.addEventListener(
      EVENT_MERCH_OFFER_READY,
      this.handleOfferSelectReady
    );
    const quantitySelect = this.closest("merch-quantity-select");
    this.manageableMode = quantitySelect;
    this.offers = [...this.querySelectorAll("merch-offer")];
    __privateSet(this, _handleOfferSelectionByQuantityFn, this.handleOfferSelectionByQuantity.bind(this));
    if (this.manageableMode) {
      quantitySelect.addEventListener(
        EVENT_MERCH_QUANTITY_SELECTOR_CHANGE,
        __privateGet(this, _handleOfferSelectionByQuantityFn)
      );
    } else {
      this.defaults = this.saveContainerDefaultValues();
    }
    this.selectedOffer = this.offers[0];
    if (this.planType) {
      this.updateContainer();
    }
  }
  get miniCompareMobileCard() {
    return this.merchCard?.variant === "mini-compare-chart" && this.isMobile;
  }
  get merchCard() {
    return this.closest("merch-card");
  }
  get isMobile() {
    return window.matchMedia("(max-width: 767px)").matches;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener(
      EVENT_MERCH_QUANTITY_SELECTOR_CHANGE,
      __privateGet(this, _handleOfferSelectionByQuantityFn)
    );
    this.removeEventListener(
      EVENT_MERCH_OFFER_READY,
      this.handleOfferSelectReady
    );
    this.removeEventListener("focusin", this.handleFocusin);
    this.removeEventListener("click", this.handleFocusin);
  }
  get price() {
    return this.querySelector(
      'merch-offer[aria-selected] [is="inline-price"]'
    );
  }
  get customerSegment() {
    return this.selectedOffer?.customerSegment;
  }
  get marketSegment() {
    return this.selectedOffer?.marketSegment;
  }
  handleFocusin(event) {
    if (event.target?.nodeName === "MERCH-OFFER") {
      event.preventDefault();
      event.stopImmediatePropagation();
      this.selectOffer(event.target);
    }
  }
  async handleOfferSelectReady() {
    if (this.planType) return;
    if (this.querySelector("merch-offer:not([plan-type])")) return;
    this.planType = this.selectedOffer.planType;
    await this.updateComplete;
    this.selectOffer(
      this.selectedOffer ?? this.querySelector("merch-offer[aria-selected]") ?? this.querySelector("merch-offer")
    );
    this.dispatchEvent(
      new CustomEvent(EVENT_MERCH_OFFER_SELECT_READY, { bubbles: true })
    );
  }
};
_handleOfferSelectionByQuantityFn = new WeakMap();
__publicField(MerchOfferSelect, "styles", i`
        :host {
            display: inline-block;
        }

        :host .horizontal {
            display: flex;
            flex-direction: row;
        }

        fieldset {
            display: contents;
        }

        :host([variant='subscription-options']) {
            display: flex;
            flex-direction: column;
            gap: var(--consonant-merch-spacing-xs);
        }
    `);
__publicField(MerchOfferSelect, "properties", {
  offers: { type: Array },
  selectedOffer: { type: Object },
  defaults: { type: Object },
  variant: { type: String, attribute: "variant", reflect: true },
  planType: { type: String, attribute: "plan-type", reflect: true },
  stock: { type: Boolean, reflect: true }
});
customElements.define("merch-offer-select", MerchOfferSelect);

// src/merch-offer.js
init_lit();

// src/merch-offer.css.js
init_lit();
var styles3 = i`
    :host {
        --merch-radio: rgba(82, 88, 228);
        --merch-radio-hover: rgba(64, 70, 202);
        --merch-radio-down: rgba(50, 54, 168);
        --merch-radio-selected: rgb(2, 101, 220);
        --merch-hovered-shadow: 0 0 0 1px #aaa;
        --merch-selected-shadow: 0 0 0 2px var(--merch-radio-selected);
        box-sizing: border-box;
    }
    .merch-Radio {
        align-items: flex-start;
        display: flex;
        max-inline-size: 100%;
        margin-inline-end: 19px;
        min-block-size: 32px;
        position: relative;
        vertical-align: top;
    }

    .merch-Radio-input {
        block-size: 100%;
        box-sizing: border-box;
        cursor: pointer;
        font-family: inherit;
        font-size: 100%;
        inline-size: 100%;
        line-height: 1.3;
        margin: 0;
        opacity: 0;
        overflow: visible;
        padding: 0;
        position: absolute;
        z-index: 1;
    }

    .merch-Radio-button {
        block-size: 14px;
        box-sizing: border-box;
        flex-grow: 0;
        flex-shrink: 0;
        inline-size: 14px;
        margin-block-start: 9px;
        position: relative;
    }

    .merch-Radio-button:before {
        border-color: rgb(109, 109, 109);
        border-radius: 50%;
        border-style: solid;
        border-width: 2px;
        box-sizing: border-box;
        content: '';
        display: block;
        height: 14px;
        position: absolute;
        transition:
            border 0.13s ease-in-out,
            box-shadow 0.13s ease-in-out;
        width: 14px;
        z-index: 0;
    }

    .merch-Radio-button:after {
        border-radius: 50%;
        content: '';
        display: block;
        left: 50%;
        position: absolute;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        transition:
            opacity 0.13s ease-out,
            margin 0.13s ease-out;
    }

    :host(:active) .merch-Radio-button:before {
        border-color: var(--merch-radio-down);
    }

    :host(:hover) .merch-Radio-button:before {
        border-color: var(--merch-radio-hover);
    }

    :host([aria-selected]) .merch-Radio-button::before {
        border-color: var(--merch-radio-selected);
        border-width: 5px;
    }

    .merch-Radio-label {
        color: rgb(34, 34, 34);
        font-size: 14px;
        line-height: 18.2px;
        margin-block-end: 9px;
        margin-block-start: 6px;
        margin-inline-start: 10px;
        text-align: start;
        transition: color 0.13s ease-in-out;
    }

    input {
        height: 0;
        outline: none;
        position: absolute;
        width: 0;
        z-index: -1;
    }

    .label {
        background-color: white;
        border: 1px solid transparent;
        border-radius: var(--consonant-merch-spacing-xxxs);
        cursor: pointer;
        display: block;
        margin: var(--consonant-merch-spacing-xs) 0;
        padding: var(--consonant-merch-spacing-xs);
        position: relative;
    }

    label:hover {
        box-shadow: var(--merch-hovered-shadow);
    }

    :host([aria-selected]) label {
        box-shadow: var(--merch-selected-shadow);
    }

    sp-icon-info-outline {
        color: #6e6e6e;
        content: '';
    }

    ::slotted(p),
    ::slotted(h5) {
        margin: 0;
    }

    ::slotted([slot='commitment']) {
        font-size: 14px !important;
        font-weight: normal !important;
        line-height: 17px !important;
    }

    #condition {
        line-height: 15px;
    }

    ::slotted([slot='condition']) {
        display: inline-block;
        font-style: italic;
        font-size: 12px;
    }

    ::slotted([slot='teaser']) {
        color: #2d9d78;
        font-size: 14px;
        font-weight: bold;
        line-height: 17px;
    }

    :host([type='subscription-option']) slot[name='price'] {
        display: flex;
        flex-direction: row-reverse;
        align-self: baseline;
        gap: 6px;
    }

    ::slotted(span[is='inline-price']) {
        font-size: 16px;
        font-weight: bold;
        line-height: 20px;
    }

    ::slotted(span[data-template='strikethrough']) {
        font-weight: normal;
    }

    :host([type='subscription-option']) {
        background-color: #fff;
        box-sizing: border-box;
        border-width: 2px;
        border-radius: 5px;
        border-style: solid;
        border-color: #eaeaea;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 16px;
        min-height: 102px;
    }

    :host([type='subscription-option']:hover) {
        border-color: #cacaca;
    }

    :host([type='subscription-option'][aria-selected]) {
        border-color: #1473e6;
    }

    :host([type='subscription-option']) #condition {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    :host([type='subscription-option'])
        ::slotted([is='inline-price'][data-display-tax='true']) {
        position: relative;
        height: 40px;
    }
`;

// src/merch-offer.js
var TAG_NAME = "merch-offer";
var MerchOffer = class extends s4 {
  constructor() {
    super();
    __publicField(this, "tr");
    this.type = "radio";
    this.selected = false;
  }
  getOptionValue(slotName) {
    return this.querySelector(`[slot="${slotName}"]`);
  }
  // setting attributes can't be done in constructor, so using connectedCallback
  connectedCallback() {
    super.connectedCallback();
    this.initOffer();
    this.configuration = this.closest("quantity-selector");
    if (!this.hasAttribute("tabindex") && !this.configuration) {
      this.tabIndex = 0;
    }
    if (!this.hasAttribute("role") && !this.configuration) {
      this.role = "radio";
    }
  }
  get asRadioOption() {
    return x` <div class="merch-Radio">
            <input tabindex="-1" type="radio" class="merch-Radio-input" />
            <span class="merch-Radio-button"></span>
            <span class="merch-Radio-label">${this.text}</span>
        </div>`;
  }
  get asSubscriptionOption() {
    return x`<slot name="commitment"></slot>
            <slot name="price"></slot>
            <slot name="teaser"></slot>
            <div id="condition">
                <slot name="condition"></slot>
                <span id="info">
                    <sp-icon-info-outline size="s"></sp-icon-info-outline
                ></span>
                <sp-overlay placement="top" trigger="info@hover" type="hint">
                    <sp-tooltip
                        ><slot name="condition-tooltip"></slot
                    ></sp-tooltip>
                </sp-overlay>
            </div>`;
  }
  render() {
    if (this.configuration) return "";
    if (!this.price) return "";
    if (this.type === "subscription-option")
      return this.asSubscriptionOption;
    return this.asRadioOption;
  }
  get price() {
    return this.querySelector(
      'span[is="inline-price"]:not([data-template="strikethrough"])'
    );
  }
  get cta() {
    return this.querySelector(SELECTOR_MAS_CHECKOUT_LINK);
  }
  get prices() {
    return this.querySelectorAll('span[is="inline-price"]');
  }
  get customerSegment() {
    return this.price?.value?.[0].customerSegment;
  }
  get marketSegment() {
    return this.price?.value?.[0].marketSegments[0];
  }
  async initOffer() {
    if (!this.price) return;
    this.prices.forEach((el) => el.setAttribute("slot", "price"));
    await this.updateComplete;
    await Promise.all([...this.prices].map((price2) => price2.onceSettled()));
    const {
      value: [offer]
    } = this.price;
    this.planType = offer.planType;
    await this.updateComplete;
    this.dispatchEvent(
      new CustomEvent(EVENT_MERCH_OFFER_READY, { bubbles: true })
    );
  }
};
__publicField(MerchOffer, "properties", {
  text: { type: String },
  selected: { type: Boolean, attribute: "aria-selected", reflect: true },
  badgeText: { type: String, attribute: "badge-text" },
  type: { type: String, attribute: "type", reflect: true },
  // values: radio, subscription-option
  planType: { type: String, attribute: "plan-type", reflect: true }
});
__publicField(MerchOffer, "styles", [styles3]);
customElements.define(TAG_NAME, MerchOffer);

// src/merch-quantity-select.js
init_lit();

// src/merch-quantity-select.css.js
init_lit();
var styles4 = i`
    :host {
        box-sizing: border-box;
        --background-color: var(--qs-background-color, #f6f6f6);
        --text-color: #000;
        --radius: 5px;
        --border-color: var(--qs-border-color, #e8e8e8);
        --border-width: var(--qs-border-width, 1px);
        --label-font-size: var(--qs-label-font-size, 12px);
        --font-size: var(--qs-font-size, 12px);
        --label-color: var(--qs-lable-color, #000);
        --input-height: var(--qs-input-height, 30px);
        --input-width: var(--qs-input-width, 72px);
        --button-width: var(--qs-button-width, 30px);
        --font-size: var(--qs-font-size, 12px);
        --picker-down-icon: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" height="18" width="18"><path d="M4 7.01a1 1 0 0 1 1.706-.706L8.993 9.59l3.29-3.285A1 1 0 0 1 13.72 7.69l-.024.025L9.7 11.707a1 1 0 0 1-1.413 0L4.293 7.716A.995.995 0 0 1 4 7.01z" fill="%23787878"/></svg>');
        --picker-up-icon: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" height="18" width="18"><path d="M14 10.99a1 1 0 0 1-1.706.706L9.005 8.41l-3.289 3.286a1 1 0 0 1-1.437-1.387l.025-.024L8.3 6.293a1 1 0 0 1 1.413 0l3.994 3.991a.995.995 0 0 1 .293.706z" fill="%23787878"/></svg>');
        --checkmark-icon: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><path d="M8.648 1.613a.922.922 0 0 0-1.294.156L3.794 6.3 2.632 4.906a.922.922 0 0 0-1.416 1.18l1.89 2.269c.02.023.048.032.07.052a.862.862 0 0 0 .07.083.883.883 0 0 0 .128.07.892.892 0 0 0 .095.051.917.917 0 0 0 .345.076h.001a.915.915 0 0 0 .357-.08.897.897 0 0 0 .099-.057.88.88 0 0 0 .134-.077.862.862 0 0 0 .069-.086c.02-.021.047-.03.066-.053l4.264-5.427a.921.921 0 0 0-.156-1.294z" fill="%23787878"/></svg>');
        --qs-transition: var(--transition);

        display: block;
        position: relative;
        color: var(--text-color);
        line-height: var(--qs-line-height, 2);
    }

    .text-field {
        display: flex;
        align-items: center;
        width: var(--input-width);
        position: relative;
        margin-top: 6px;
    }

    .text-field-input {
        font-family: inherit;
        padding: 0;
        font-size: var(--font-size);
        height: var(--input-height);
        width: calc(var(--input-width) - var(--button-width));
        border: var(--border-width) solid var(--border-color);
        border-top-left-radius: var(--radius);
        border-bottom-left-radius: var(--radius);
        border-top-right-radius: 0;
        border-bottom-right-radius: 0;
        border-right: none;
        padding-inline-start: 12px;
        box-sizing: border-box;
        -moz-appearance: textfield;
    }

    .text-field-input::-webkit-inner-spin-button,
    .text-field-input::-webkit-outer-spin-button {
        margin: 0;
        -webkit-appearance: none;
    }

    .label {
        font-size: var(--label-font-size);
        color: var(--label-color);
    }

    .picker-button {
        width: var(--button-width);
        height: var(--input-height);
        position: absolute;
        inset-inline-end: 0;
        border: var(--border-width) solid var(--border-color);
        border-top-right-radius: var(--radius);
        border-bottom-right-radius: var(--radius);
        background-color: var(--background-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        padding: 0;
    }

    .picker-button-fill {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-image: var(--picker-down-icon);
        background-position: center;
        background-repeat: no-repeat;
    }

    .picker-button-fill.closed {
        background-image: var(--picker-up-icon);
    }

    .popover {
        position: absolute;
        left: 0;
        width: var(--input-width);
        border-radius: var(--radius);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        z-index: 100;
        transition: var(--qs-transition);
        visibility: hidden;
        box-sizing: border-box;
    }

    .popover[placement='bottom'] {
        top: var(--input-height);
        margin-top: var(--popover-margin-top, 6px);
    }

    .popover[placement='top'] {
        bottom: var(--input-height);
        margin-bottom: var(--popover-margin-bottom, 6px);
    }

    .popover.open {
        visibility: visible;
        background: #ffffff;
        border: var(--border-width) solid var(--border-color);
    }

    .popover.closed {
        visibility: hidden;
        pointer-events: none;
        transition: none;
    }

    ::slotted(p) {
        margin: 0;
    }

    .item {
        display: flex;
        align-items: center;
        color: var(--text-color);
        font-size: var(--font-size);
        padding-inline-start: 12px;
        box-sizing: border-box;
    }

    .item.highlighted {
        background-color: var(--background-color);
    }

    .item.selected {
        background-image: var(--checkmark-icon);
        background-position: right 7px center;
        background-repeat: no-repeat;
    }
`;

// src/focus.js
var [ARROW_LEFT, ARROW_RIGHT, ARROW_UP, ARROW_DOWN, ENTER, TAB] = [
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "ArrowDown",
  "Enter",
  "Tab"
];

// src/merch-quantity-select.js
var MerchQuantitySelect = class extends s4 {
  static get properties() {
    return {
      closed: { type: Boolean, reflect: true },
      selected: { type: Number },
      min: { type: Number },
      max: { type: Number },
      step: { type: Number },
      maxInput: { type: Number, attribute: "max-input" },
      options: { type: Array },
      highlightedIndex: { type: Number },
      defaultValue: {
        type: Number,
        attribute: "default-value",
        reflect: true
      },
      title: { type: String }
    };
  }
  static get styles() {
    return styles4;
  }
  constructor() {
    super();
    this.options = [];
    this.title = "";
    this.closed = true;
    this.min = 0;
    this.max = 0;
    this.step = 0;
    this.maxInput = void 0;
    this.defaultValue = void 0;
    this.selectedValue = 0;
    this.highlightedIndex = 0;
    this.toggleMenu = this.toggleMenu.bind(this);
    this.closeMenu = this.closeMenu.bind(this);
    this.openMenu = this.openMenu.bind(this);
    this.handleClickOutside = this.handleClickOutside.bind(this);
    this.boundKeydownListener = this.handleKeydown.bind(this);
    this.handleKeyupDebounced = debounce(this.handleKeyup.bind(this), 500);
    this.debouncedQuantityUpdate = debounce(
      this.handleQuantityUpdate.bind(this),
      500
    );
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("keydown", this.boundKeydownListener);
    window.addEventListener("mousedown", this.handleClickOutside);
    this.addEventListener(
      EVENT_MERCH_CARD_QUANTITY_CHANGE,
      this.debouncedQuantityUpdate
    );
  }
  get button() {
    return this.shadowRoot.querySelector("button");
  }
  handleKeyup(e4) {
    if (e4.key === ARROW_DOWN || e4.key === ARROW_UP) return;
    this.handleInput();
    this.sendEvent();
  }
  selectValue() {
    if (!this.closed) {
      const option = this.options[this.highlightedIndex];
      if (!option) {
        this.closed = true;
        return;
      }
      this.selectedValue = option;
      this.handleMenuOption(this.selectedValue);
      this.closed = true;
    }
  }
  handleKeydown(e4) {
    switch (e4.key) {
      case " ":
        this.selectValue();
        break;
      case "Escape":
        this.closed = true;
        break;
      case TAB:
        this.selectValue();
        break;
      case ARROW_DOWN:
        if (!this.closed) {
          this.highlightedIndex = (this.highlightedIndex + 1) % this.options.length;
        } else {
          this.openMenu();
        }
        e4.preventDefault();
        break;
      case ARROW_UP:
        if (!this.closed) {
          this.highlightedIndex = (this.highlightedIndex - 1 + this.options.length) % this.options.length;
        }
        e4.preventDefault();
        break;
      case ENTER:
        this.selectValue();
        if (this.button.classList.contains("focused"))
          e4.preventDefault();
        break;
    }
    if (e4.composedPath().includes(this)) e4.stopPropagation();
  }
  adjustInput(inputField, value) {
    this.selectedValue = value;
    inputField.value = value;
    this.highlightedIndex = this.options.indexOf(value);
  }
  handleInput() {
    const inputField = this.shadowRoot.querySelector(".text-field-input");
    const numericValue = inputField.value.replace(/\D/g, "");
    inputField.value = numericValue;
    const inputValue = parseInt(numericValue);
    if (isNaN(inputValue)) {
      return;
    }
    if (inputValue > 0 && inputValue !== this.selectedValue) {
      let adjustedInputValue = inputValue;
      if (this.maxInput && inputValue > this.maxInput)
        adjustedInputValue = this.maxInput;
      if (this.min && adjustedInputValue < this.min)
        adjustedInputValue = this.min;
      this.adjustInput(inputField, adjustedInputValue);
    } else
      this.adjustInput(inputField, this.selectedValue || this.min || 1);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("mousedown", this.handleClickOutside);
    this.removeEventListener("keydown", this.boundKeydownListener);
    this.removeEventListener(
      EVENT_MERCH_CARD_QUANTITY_CHANGE,
      this.debouncedQuantityUpdate
    );
  }
  generateOptionsArray() {
    const options = [];
    if (this.step > 0) {
      for (let value = this.min; value <= this.max; value += this.step) {
        options.push(value);
      }
    }
    return options;
  }
  update(changedProperties) {
    if (changedProperties.has("min") || changedProperties.has("max") || changedProperties.has("step") || changedProperties.has("defaultValue")) {
      this.options = this.generateOptionsArray();
      this.highlightedIndex = this.defaultValue ? this.options.indexOf(this.defaultValue) : 0;
      this.handleMenuOption(
        this.defaultValue ? this.defaultValue : this.options[0]
      );
    }
    super.update(changedProperties);
  }
  handleClickOutside(event) {
    const path = event.composedPath();
    if (!path.includes(this)) {
      this.closeMenu();
    }
  }
  toggleMenu() {
    this.closed = !this.closed;
    this.adjustPopoverPlacement();
    if (this.closed)
      this.highlightedIndex = this.options.indexOf(this.selectedValue);
  }
  closeMenu() {
    this.closed = true;
    this.highlightedIndex = this.options.indexOf(this.selectedValue);
  }
  openMenu() {
    this.closed = false;
    this.adjustPopoverPlacement();
  }
  adjustPopoverPlacement() {
    const popover = this.shadowRoot.querySelector(".popover");
    if (this.closed || popover.getBoundingClientRect().bottom <= window.innerHeight)
      popover.setAttribute("placement", "bottom");
    else popover.setAttribute("placement", "top");
  }
  handleMouseEnter(index) {
    this.highlightedIndex = index;
  }
  handleMenuOption(option, close) {
    if (option === this.max)
      this.shadowRoot.querySelector(".text-field-input")?.focus();
    this.selectedValue = option;
    this.sendEvent();
    if (close) this.closeMenu();
  }
  sendEvent() {
    const customEvent = new CustomEvent(
      EVENT_MERCH_QUANTITY_SELECTOR_CHANGE,
      {
        detail: { option: this.selectedValue },
        bubbles: true
      }
    );
    this.dispatchEvent(customEvent);
  }
  get offerSelect() {
    return this.querySelector("merch-offer-select");
  }
  get popover() {
    return x` <div
            id="qsPopover"
            class="popover ${this.closed ? "closed" : "open"}"
            placement="bottom"
            role="listbox"
            aria-multiselectable="false"
            aria-labelledby="qsLabel"
            tabindex="-1"
        >
            ${this.options.map(
      (option, index) => x`
                    <div
                        class="item ${index === this.highlightedIndex ? "highlighted" : ""}${this.selectedValue === option ? " selected" : ""}"
                        role="option"
                        id="${`qs-item-${index}`}"
                        aria-selected=${this.selectedValue === option}
                        @click="${() => this.handleMenuOption(option, true)}"
                        @mouseenter="${() => this.handleMouseEnter(index)}"
                    >
                        ${option === this.max ? `${option}+` : option}
                    </div>
                `
    )}
        </div>`;
  }
  handleQuantityUpdate({ detail: { quantity } }) {
    if (quantity && quantity !== this.selectedValue) {
      this.selectedValue = quantity;
      const inputField = this.shadowRoot.querySelector(".text-field-input");
      if (inputField) {
        inputField.value = quantity;
      }
      this.sendEvent();
    }
  }
  onButtonFocus(e4) {
    e4.target.classList.add("focused");
  }
  onButtonBlur(e4) {
    e4.target.classList.remove("focused");
  }
  render() {
    return x`
            <div class="label" id="qsLabel">${this.title}</div>
            <div class="text-field">
                <input
                    class="text-field-input"
                    aria-labelledby="qsLabel"
                    name="quantity"
                    role="combobox"
                    aria-expanded=${!this.closed}
                    aria-controls="qsPopover"
                    aria-activedescendant="${!this.closed ? `qs-item-${this.highlightedIndex}` : A}"
                    .value="${this.selectedValue}"
                    type="text"
                    autocomplete="off"
                    @keydown="${this.handleKeydown}"
                    @keyup="${this.handleKeyupDebounced}"
                />
                <button
                    class="picker-button"
                    aria-activedescendant="${!this.closed ? `qs-item-${this.highlightedIndex}` : A}"
                    @focus="${this.onButtonFocus}"
                    @blur="${this.onButtonBlur}"
                    aria-controls="qsPopover"
                    aria-expanded=${!this.closed}
                    aria-labelledby="qsLabel"
                    @click="${this.toggleMenu}"
                >
                    <div
                        class="picker-button-fill ${this.closed ? "open" : "closed"}"
                    ></div>
                </button>
                ${this.popover}
            </div>
        `;
  }
};
customElements.define("merch-quantity-select", MerchQuantitySelect);

// src/mas.js
init_mas_mnemonic();

// src/variants/ccd-suggested.js
init_lit();

// src/variants/ccd-suggested.css.js
var CSS11 = `

  merch-card[variant="ccd-suggested"] [slot="heading-xs"] {
    font-size: var(--consonant-merch-card-heading-xxs-font-size);
    line-height: var(--consonant-merch-card-heading-xxs-line-height);
  }
  
  merch-card[variant="ccd-suggested"] [slot="body-xs"] a {
    font-size: var(--consonant-merch-card-body-xxs-font-size);
    line-height: var(--consonant-merch-card-body-xxs-line-height);
  }

  merch-card[variant="ccd-suggested"] [slot="price"] em {
      font-size: var(--consonant-merch-card-body-xxs-font-size);
      line-height: var(--consonant-merch-card-body-xxs-line-height);
  }

.spectrum--darkest merch-card[variant="ccd-suggested"] {
  --consonant-merch-card-background-color:rgb(30, 30, 30);
  --consonant-merch-card-heading-xs-color:rgb(239, 239, 239);
  --consonant-merch-card-body-xs-color:rgb(200, 200, 200);
  --consonant-merch-card-border-color:rgb(57, 57, 57);
  --consonant-merch-card-detail-s-color:rgb(162, 162, 162);
  --consonant-merch-card-price-color:rgb(248, 248, 248);
  --merch-color-inline-price-strikethrough:rgb(176, 176, 176);
}

.spectrum--darkest  merch-card[variant="ccd-suggested"]:hover {
  --consonant-merch-card-border-color:rgb(73, 73, 73);
}
`;

// src/variants/ccd-suggested.js
var CCD_SUGGESTED_AEM_FRAGMENT_MAPPING = {
  backgroundImage: { attribute: "background-image" },
  badge: true,
  ctas: { slot: "cta", size: "M" },
  description: { tag: "div", slot: "body-xs" },
  mnemonics: { size: "l" },
  prices: { tag: "p", slot: "price" },
  size: [],
  subtitle: { tag: "h4", slot: "detail-s" },
  title: { tag: "h3", slot: "heading-xs" }
};
var CCDSuggested = class extends VariantLayout {
  getGlobalCSS() {
    return CSS11;
  }
  get stripStyle() {
    if (!this.card.backgroundImage) return "";
    return `
            background: url("${this.card.backgroundImage}");
        background-size: auto 100%;
        background-repeat: no-repeat;
        background-position: ${this.card.dir === "ltr" ? "left" : "right"};
        `;
  }
  renderLayout() {
    return x` <div style="${this.stripStyle}" class="body">
                <div class="header">
                    <div class="top-section">
                        <slot name="icons"></slot>
                        ${this.badge}
                    </div>
                    <div class="headings">
                        <slot name="detail-s"></slot>
                        <slot name="heading-xs"></slot>
                    </div>
                </div>
                <slot name="body-xs"></slot>
                <div class="footer">
                    <slot name="price"></slot>
                    <slot name="cta"></slot>
                </div>
            </div>
            <slot></slot>`;
  }
  postCardUpdateHook(changedProperties) {
    if (changedProperties.has("backgroundImage"))
      this.styleBackgroundImage();
  }
  styleBackgroundImage() {
    this.card.classList.remove("thin-strip");
    this.card.classList.remove("wide-strip");
    if (!this.card.backgroundImage) {
      return;
    }
    const img = new Image();
    img.src = this.card.backgroundImage;
    img.onload = () => {
      if (img.width > 8) {
        this.card.classList.add("wide-strip");
      } else if (img.width === 8) {
        this.card.classList.add("thin-strip");
      }
    };
  }
};
__publicField(CCDSuggested, "variantStyle", i`
        :host([variant='ccd-suggested']) {
            --consonant-merch-card-background-color: rgb(245, 245, 245);
            --consonant-merch-card-body-xs-color: rgb(75, 75, 75);
            --consonant-merch-card-border-color: rgb(225, 225, 225);
            --consonant-merch-card-detail-s-color: rgb(110, 110, 110);
            --consonant-merch-card-heading-xs-color: rgb(44, 44, 44);
            --merch-color-inline-price-strikethrough: var(--spectrum-gray-600);
            --mod-img-height: 38px;

            box-sizing: border-box;
            width: 100%;
            max-width: 305px;
            min-width: 270px;
            min-height: 205px;
            border-radius: 4px;
            display: flex;
            flex-flow: wrap;
            overflow: hidden;
        }

        :host([variant='ccd-slice']) * {
            overflow: hidden;
        }

        :host([variant='ccd-suggested']:hover) {
            --consonant-merch-card-border-color: #cacaca;
        }

        :host([variant='ccd-suggested']) .body {
            height: auto;
            padding: 20px;
            gap: 0;
        }

        :host([variant='ccd-suggested'].thin-strip) .body {
            padding: 20px 20px 20px 28px;
        }

        :host([variant='ccd-suggested']) .header {
            display: flex;
            flex-flow: wrap;
            place-self: flex-start;
            flex-wrap: nowrap;
        }

        :host([variant='ccd-suggested']) .headings {
            padding-inline-start: var(--consonant-merch-spacing-xxs);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        :host([variant='ccd-suggested']) ::slotted([slot='icons']) {
            place-self: center;
        }

        :host([variant='ccd-suggested']) ::slotted([slot='heading-xs']) {
            font-size: var(--consonant-merch-card-heading-xxs-font-size);
            line-height: var(--consonant-merch-card-heading-xxs-line-height);
        }

        :host([variant='ccd-suggested']) ::slotted([slot='detail-m']) {
            line-height: var(--consonant-merch-card-detail-m-line-height);
        }

        :host([variant='ccd-suggested']) ::slotted([slot='body-xs']) {
            color: var(--ccd-gray-700-dark);
            padding-top: 8px;
            flex-grow: 1;
        }

        :host([variant='ccd-suggested'].wide-strip)
            ::slotted([slot='body-xs']) {
            padding-inline-start: 48px;
        }

        :host([variant='ccd-suggested'].wide-strip) ::slotted([slot='price']) {
            padding-inline-start: 48px;
        }

        :host([variant='ccd-suggested']) ::slotted([slot='price']) {
            font-size: var(--consonant-merch-card-body-xs-font-size);
            line-height: var(--consonant-merch-card-body-xs-line-height);
        }

        :host([variant='ccd-suggested']) ::slotted([slot='cta']) {
            display: flex;
            align-items: center;
            min-width: fit-content;
        }

        :host([variant='ccd-suggested']) .footer {
            display: flex;
            justify-content: space-between;
            flex-grow: 0;
            margin-top: 6px;
            align-items: center;
        }

        :host([variant='ccd-suggested']) div[class$='-badge'] {
            position: static;
            border-radius: 4px;
        }

        :host([variant='ccd-suggested']) .top-section {
            align-items: center;
        }
    `);

// src/variants/ccd-slice.js
init_lit();

// src/variants/ccd-slice.css.js
var CSS12 = `

merch-card[variant="ccd-slice"] [slot='image'] img {
  overflow: hidden;
  border-radius: 50%;
}

merch-card[variant="ccd-slice"] [slot='body-s'] {
  display: flex;
  flex-flow: column;
}
  
merch-card[variant="ccd-slice"] [slot='body-s'] a.spectrum-Link {
  font-size: var(--consonant-merch-card-body-xxs-font-size);
  font-style: normal;
  font-weight: 400;
  line-height: var(--consonant-merch-card-body-xxs-line-height);
}

.spectrum--darkest merch-card[variant="ccd-slice"] {
  --consonant-merch-card-background-color:rgb(29, 29, 29);
  --consonant-merch-card-body-s-color:rgb(235, 235, 235);
  --consonant-merch-card-border-color:rgb(48, 48, 48);
  --consonant-merch-card-detail-s-color:rgb(235, 235, 235);
}
`;

// src/variants/ccd-slice.js
var CCD_SLICE_AEM_FRAGMENT_MAPPING = {
  backgroundImage: { tag: "div", slot: "image" },
  badge: true,
  ctas: { slot: "footer", size: "S" },
  description: { tag: "div", slot: "body-s" },
  mnemonics: { size: "m" },
  size: ["wide"]
};
var CCDSlice = class extends VariantLayout {
  getGlobalCSS() {
    return CSS12;
  }
  renderLayout() {
    return x` <div class="content">
                <div class="top-section">
                    <slot name="icons"></slot>
                    ${this.badge}
                </div>
                <slot name="body-s"></slot>
                <slot name="footer"></slot>
            </div>
            <slot name="image"></slot>
            <slot></slot>`;
  }
};
__publicField(CCDSlice, "variantStyle", i`
        :host([variant='ccd-slice']) {
            --consonant-merch-card-background-color: rgb(248, 248, 248);
            --consonant-merch-card-border-color: rgb(230, 230, 230);
            --consonant-merch-card-body-s-color: rgb(34, 34, 34);
            --merch-color-inline-price-strikethrough: var(--spectrum-gray-600);
            --mod-img-height: 29px;
            box-sizing: border-box;
            min-width: 290px;
            max-width: 322px;
            width: 100%;
            max-height: 154px;
            height: 154px;
            border-radius: 4px;
            display: flex;
            flex-flow: wrap;
        }

        :host([variant='ccd-slice']) * {
            overflow: hidden;
        }

        :host([variant='ccd-slice']) ::slotted([slot='body-s']) {
            font-size: var(--consonant-merch-card-body-xs-font-size);
            line-height: var(--consonant-merch-card-body-xxs-line-height);
            min-width: 154px;
            max-width: 171px;
            height: 55px;
            overflow: hidden;
        }

        :host([variant='ccd-slice'][size='wide']) ::slotted([slot='body-s']) {
            max-width: 425px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        :host([variant='ccd-slice'][size='wide']) {
            width: 600px;
            max-width: 600px;
        }

        :host([variant='ccd-slice']) .content {
            display: flex;
            gap: var(--consonant-merch-spacing-xxs);
            padding: 15px;
            padding-inline-end: 0;
            height: 154px;
            box-sizing: border-box;
            min-height: 123px;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            flex: 1 0 0;
        }

        :host([variant='ccd-slice'])
            ::slotted([slot='body-s'])
            ::slotted(a:not(.con-button)) {
            font-size: var(--consonant-merch-card-body-xxs-font-size);
            font-style: normal;
            font-weight: 400;
            line-height: var(--consonant-merch-card-body-xxs-line-height);
            text-decoration-line: underline;
            color: var(--spectrum-gray-800, var(--merch-color-grey-80));
        }

        :host([variant='ccd-slice']) ::slotted([slot='image']) {
            display: flex;
            justify-content: center;
            flex-shrink: 0;
            width: 134px;
            height: 149px;
            overflow: hidden;
            border-radius: 50%;
            padding: 15px;
            align-self: center;
            padding-inline-start: 0;
        }

        :host([variant='ccd-slice']) ::slotted([slot='image']) img {
            overflow: hidden;
            border-radius: 50%;
            width: inherit;
            height: inherit;
        }

        :host([variant='ccd-slice']) div[class$='-badge'] {
            font-size: var(--consonant-merch-card-body-xxs-font-size);
            position: static;
            border-radius: 4px;
            font-style: normal;
            font-weight: 400;
            line-height: normal;
            padding: 4px 9px;
        }

        :host([variant='ccd-slice']) .top-section {
            align-items: center;
            gap: 8px;
        }
    `);

// src/variants/ah-try-buy-widget.js
init_lit();

// src/variants/ah-try-buy-widget.css.js
var CSS13 = `
    merch-card[variant="ah-try-buy-widget"] [slot="body-xxs"] {
        letter-spacing: normal;
        margin-bottom: 16px;
        box-sizing: border-box;
        color: var(--consonant-merch-card-body-xxs-color);
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="badge"] {
        position: absolute;
        top: 18px;
        right: 12px;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="badge"] merch-badge {
        border-radius: 7px;
        font-size: 12px;
        font-weight: normal;
        line-height: normal;
        padding: 4px 9px 5px 9px;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="body-xxs"] a {
        color: var(--consonant-merch-card-body-xxs-color);
    }

    merch-card[variant="ah-try-buy-widget"] [slot="body-xxs"] a:hover {
        color: var(--consonant-merch-card-body-xxs-color);
    }

    merch-card[variant="ah-try-buy-widget"] [slot="heading-xxxs"] {
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        display: -moz-box;
        -webkit-box-orient: vertical;
        -moz-box-orient: vertical;
        line-clamp: 3;
        -webkit-line-clamp: 3;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price {
        display: inline-block;
        height: var(--consonant-merch-card-detail-xl-line-height);
        line-height: var(--consonant-merch-card-detail-xl-line-height);
        font-style: normal;
        margin-top: 4px;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price.price-strikethrough {
        height: var(--consonant-merch-card-detail-l-line-height);
        line-height: var(--consonant-merch-card-detail-l-line-height);
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        text-decoration-thickness: .5px;
        color: var(--ah-gray-500);
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price:not(.price-strikethrough) .price-currency-symbol,
    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price:not(.price-strikethrough) .price-integer,
    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price:not(.price-strikethrough) .price-decimals-delimiter,
    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price:not(.price-strikethrough) .price-decimals {
        color: var(--consonant-merch-card-heading-xxxs-color);
        font-size: var(--consonant-merch-card-heading-xs-font-size);
        font-weight: 700;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price:not(.price-strikethrough) .price-recurrence {
        width: 21px;
        text-align: end;
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        color: var(--consonant-merch-card-body-xxs-color);
        font-weight: 400;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] .price:not(.price-strikethrough) .price-tax-inclusivity {
        font-weight: 400;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] a {
        color: var(--consonant-merch-card-body-xxs-color);
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        font-style: normal;
        line-height: var(--consonant-merch-card-body-xxs-line-height);
        text-decoration: underline;
        text-decoration-thickness: .75px;
        text-underline-offset: 1px;
        width: fit-content;
        margin-top: 4px;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="price"] a:hover {
        color: var(--consonant-merch-card-body-xxs-color);
        font-weight: 700;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="cta"] {
        align-self: end;
        gap: 8px;
        display: flex;
        padding-top: 24px;
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    merch-card[variant="ah-try-buy-widget"] [slot="image"] {
      display: none;
    }
    
    merch-card[variant="ah-try-buy-widget"][size='single'] [slot="image"] {
      display: flex;
      width: 199px;
      overflow: hidden;
      height: 100%;
      border-radius: 16px;
      order: 1;
    }

    merch-card[variant="ah-try-buy-widget"][size='single'] [slot="image"] img {
      width: 100%;
      object-fit: cover;
      border-radius: 16px;
      overflow: hidden;
    }

    .spectrum--dark merch-card[variant="ah-try-buy-widget"][background-color='gray'],
    .spectrum--darkest merch-card[variant="ah-try-buy-widget"][background-color='gray'] {
      --merch-card-ah-try-buy-widget-gray-background: rgb(27, 27, 27);
    }

    .spectrum--dark merch-card[variant="ah-try-buy-widget"],
    .spectrum--darkest merch-card[variant="ah-try-buy-widget"] {
      --consonant-merch-card-background-color:rgb(17, 17, 17);
      --consonant-merch-card-heading-xxxs-color:rgb(242, 242, 242);
      --consonant-merch-card-body-xxs-color:rgb(219, 219, 219);
    }

    .spectrum--dark merch-card[variant="ah-try-buy-widget"]:hover,
    .spectrum--darkest merch-card[variant="ah-try-buy-widget"]:hover {
      --consonant-merch-card-border-color:rgb(73, 73, 73);
    }
`;

// src/variants/ah-try-buy-widget.js
var AH_TRY_BUY_WIDGET_AEM_FRAGMENT_MAPPING = {
  mnemonics: { size: "s" },
  title: { tag: "h3", slot: "heading-xxxs", maxCount: 40, withSuffix: true },
  badge: { tag: "div", slot: "badge", default: "fuchsia" },
  allowedBadgeColors: ["fuchsia"],
  description: {
    tag: "div",
    slot: "body-xxs",
    maxCount: 200,
    withSuffix: false
  },
  prices: { tag: "p", slot: "price" },
  ctas: { slot: "cta", size: "S" },
  backgroundImage: { tag: "div", slot: "image" },
  backgroundColor: { attribute: "background-color" },
  borderColor: { attribute: "border-color", specialValues: {} },
  allowedColors: { gray: "--spectrum-gray-100" },
  size: ["single", "double", "triple"]
};
var AHTryBuyWidget = class extends VariantLayout {
  getGlobalCSS() {
    return CSS13;
  }
  /* c8 ignore next 3 */
  get aemFragmentMapping() {
    return AH_TRY_BUY_WIDGET_AEM_FRAGMENT_MAPPING;
  }
  renderLayout() {
    return x`
            <div class="content">
                <div class="header">
                    <slot name="icons"></slot>
                    <slot name="heading-xxxs"></slot>
                </div>
                <slot name="body-xxs"></slot>
                <div class="price">
                    <slot name="price"></slot>
                </div>
                <div class="footer">
                    <slot name="cta"></slot>
                </div>
            </div>
            <slot name="image"></slot>
            <slot name="badge"></slot>
            <slot></slot>
        `;
  }
};
__publicField(AHTryBuyWidget, "variantStyle", i`
        :host([variant='ah-try-buy-widget']) {
            --merch-card-ah-try-buy-widget-min-width: 156px;
            --merch-card-ah-try-buy-widget-content-min-width: 132px;
            --merch-card-ah-try-buy-widget-header-min-height: 36px;
            --merch-card-ah-try-buy-widget-gray-background: rgba(248, 248, 248);
            --merch-card-ah-try-buy-widget-text-color: rgba(19, 19, 19);
            --merch-card-ah-try-buy-widget-price-line-height: 17px;
            --merch-card-ah-try-buy-widget-outline: transparent;
            --consonant-merch-card-border-width: 1px;
            height: 100%;
            min-width: var(--merch-card-ah-try-buy-widget-min-width);
            background-color: var(
                --merch-card-custom-background-color,
                var(--consonant-merch-card-background-color)
            );
            color: var(--consonant-merch-card-heading-xxxs-color);
            border-radius: 10px;
            border: 1px solid
                var(--consonant-merch-card-border-color, transparent);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 11px !important;
            gap: 16px;
            justify-content: space-between;
            box-sizing: border-box !important;
        }

        :host([variant='ah-try-buy-widget'][size='single']) {
            flex-direction: row;
        }

        :host([variant='ah-try-buy-widget'][size='single'])
            ::slotted(div[slot='cta']) {
            display: flex;
            flex-grow: 0;
        }

        :host([variant='ah-try-buy-widget']) .content {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: var(--merch-card-ah-try-buy-widget-content-min-width);
            flex-basis: var(--merch-card-ah-try-buy-widget-content-min-width);
            flex-grow: 1;
        }

        :host([variant='ah-try-buy-widget']) .header {
            display: flex;
            min-height: var(--merch-card-ah-try-buy-widget-header-min-height);
            flex-direction: row;
            align-items: center;
            gap: var(--consonant-merch-spacing-xxs);
            margin-bottom: 4px;
        }

        :host([variant='ah-try-buy-widget']) .price {
            display: flex;
            flex-grow: 1;
        }

        :host([variant='ah-try-buy-widget']) ::slotted([slot='price']) {
            margin-left: var(--spacing-xs);
            display: flex;
            flex-direction: column;
            justify-content: end;
            font-size: var(--consonant-merch-card-detail-s-font-size);
            font-style: italic;
            line-height: var(--merch-card-ah-try-buy-widget-price-line-height);
            color: var(--consonant-merch-card-heading-xxxs-color);
        }

        :host([variant='ah-try-buy-widget']) .footer {
            display: flex;
            width: fit-content;
            flex-wrap: wrap;
            gap: 8px;
            flex-direction: row;
            align-self: flex-end;
        }
    `);

// src/variants/ah-promoted-plans.js
init_lit();

// src/variants/ah-promoted-plans.css.js
var CSS14 = `
    merch-card[variant="ah-promoted-plans"] [slot="body-xxs"] {
        letter-spacing: normal;
        box-sizing: border-box;
        color: var(--consonant-merch-card-body-xxs-color);
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
    }

    merch-card[variant="ah-promoted-plans"] [slot="body-xxs"] a {
        color: var(--consonant-merch-card-body-xxs-color);
    }

    merch-card[variant="ah-promoted-plans"] [slot="body-xxs"] a:hover {
        color: var(--consonant-merch-card-body-xxs-color);
    }

    merch-card[variant="ah-promoted-plans"] [slot="price"] .price {
        display: inline-block;
        height: var(--consonant-merch-card-detail-xl-line-height);
        line-height: var(--consonant-merch-card-detail-xl-line-height);
        font-style: normal;
    }

    merch-card[variant="ah-promoted-plans"] [slot="price"] .price.price-strikethrough {
        height: var(--consonant-merch-card-detail-l-line-height);
        line-height: var(--consonant-merch-card-detail-l-line-height);
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        text-decoration-thickness: .5px;
        color: var(--merch-card-ah-promoted-plans-strikethrough-color);
    }

    merch-card[variant="ah-promoted-plans"] [slot="price"] .price:not(.price-strikethrough) .price-currency-symbol,
    merch-card[variant="ah-promoted-plans"] [slot="price"] .price:not(.price-strikethrough) .price-integer,
    merch-card[variant="ah-promoted-plans"] [slot="price"] .price:not(.price-strikethrough) .price-decimals-delimiter,
    merch-card[variant="ah-promoted-plans"] [slot="price"] .price:not(.price-strikethrough) .price-decimals {
        color: var(--consonant-merch-card-heading-xxxs-color);
        font-size: var(--consonant-merch-card-heading-xs-font-size);
        font-weight: 700;
    }

    merch-card[variant="ah-promoted-plans"] [slot="price"] .price:not(.price-strikethrough) .price-recurrence {
        display: inline-block;
        width: 21px;
        text-align: end;
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        color: var(--consonant-merch-card-body-xxs-color);
        font-weight: 400;
    }

    merch-card[variant="ah-promoted-plans"] [slot="cta"] {
        gap: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }
    
    merch-card[variant="ah-promoted-plans"] [slot="cta"] .spectrum-Link {
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        line-height: var(--consonant-merch-card-body-xxs-line-height);
        color: var(--consonant-merch-card-body-xxs-color);
    }

    merch-card[variant="ah-promoted-plans"] [slot="cta"] button[is="checkout-button"] {
        margin-inline-start: auto;
    }
    
    merch-card[variant="ah-promoted-plans"] [slot="cta"] button[is="checkout-button"]:last-child {
        margin-inline-start: 0;
    }

    merch-card[variant="ah-promoted-plans"] [slot="price"] em {
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        line-height: var(--consonant-merch-card-body-xxs-line-height);
        color: var(--merch-card-ah-promoted-plans-abm-color);
    }

    .spectrum--dark merch-card[variant="ah-promoted-plans"],
    .spectrum--darkest merch-card[variant="ah-promoted-plans"] {
      --consonant-merch-card-background-color:rgb(34, 34, 34);
      --consonant-merch-card-heading-xxxs-color:rgb(242, 242, 242);
      --merch-card-ah-promoted-plans-abm-color:rgb(175, 175, 175);
      --consonant-merch-card-body-xxs-color:rgb(219, 219, 219);
      --merch-card-ah-promoted-plans-strikethrough-color:rgb(138, 138, 138);
    }
`;

// src/variants/ah-promoted-plans.js
var AH_PROMOTED_PLANS_AEM_FRAGMENT_MAPPING = {
  mnemonics: { size: "s" },
  title: { tag: "h3", slot: "heading-xxxs", maxCount: 40, withSuffix: true },
  description: {
    tag: "div",
    slot: "body-xxs",
    maxCount: 200,
    withSuffix: false
  },
  prices: { tag: "p", slot: "price" },
  ctas: { slot: "cta", size: "S" },
  backgroundImage: { tag: "div", slot: "image" },
  backgroundColor: { attribute: "background-color" },
  borderColor: {
    attribute: "border-color",
    specialValues: {
      gradient: "linear-gradient(135deg, #ff4885 0%, #b272eb 50%, #5d89ff 100%)"
    }
  }
};
var AHPromotedPlans = class extends VariantLayout {
  getGlobalCSS() {
    return CSS14;
  }
  get aemFragmentMapping() {
    return AH_PROMOTED_PLANS_AEM_FRAGMENT_MAPPING;
  }
  renderLayout() {
    return x`
            <div class="content">
                <div class="header">
                    <slot name="icons"></slot>
                    <slot name="heading-xxxs"></slot>
                </div>
                <div class="price">
                    <slot name="price"></slot>
                </div>
                <slot name="body-xxs"></slot>
                <div class="footer">
                    <slot name="cta"></slot>
                </div>
            </div>
            <slot></slot>
        `;
  }
};
__publicField(AHPromotedPlans, "variantStyle", i`
        /* Default styles for the component */
        :host([variant='ah-promoted-plans']) {
            --merch-card-ah-promoted-plans-min-width: 211px;
            --merch-card-ah-promoted-plans-max-width: 384px;
            --merch-card-ah-promoted-plans-header-min-height: 36px;
            --merch-card-ah-promoted-plans-gray-background: rgba(248, 248, 248);
            --merch-card-ah-promoted-plans-text-color: rgba(19, 19, 19);
            --merch-card-ah-promoted-plans-abm-color: rgba(80, 80, 80);
            --merch-card-ah-promoted-plans-strikethrough-color: rgba(
                113,
                113,
                113
            );
            --merch-card-ah-promoted-plans-price-line-height: 17px;
            --merch-card-ah-promoted-plans-outline: transparent;
            --consonant-merch-card-border-width: 1px;
            height: 100%;
            min-width: var(--merch-card-ah-promoted-plans-min-width);
            max-width: var(--merch-card-ah-promoted-plans-max-width);
            background-color: var(
                --merch-card-custom-background-color,
                var(--consonant-merch-card-background-color)
            );
            color: var(--consonant-merch-card-heading-xxxs-color);
            border-radius: 10px;
            border: 1px solid
                var(--consonant-merch-card-border-color, transparent);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 16px !important;
            gap: 16px;
            justify-content: space-between;
            box-sizing: border-box !important;
            position: relative;
        }

        :host([variant='ah-promoted-plans'][gradient-border='true']) {
            border: none;
            padding: 15px !important;
            background-origin: padding-box, border-box;
            background-clip: padding-box, border-box;
            background-image: linear-gradient(
                    to bottom,
                    var(
                        --merch-card-custom-background-color,
                        var(--consonant-merch-card-background-color)
                    ),
                    var(
                        --merch-card-custom-background-color,
                        var(--consonant-merch-card-background-color)
                    )
                ),
                linear-gradient(135deg, #ff4885 0%, #b272eb 50%, #5d89ff 100%);
            border: 1px solid transparent;
        }

        :host([variant='ah-promoted-plans']) .content {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: var(--consonant-merch-spacing-xxs);
            flex-grow: 1;
        }

        :host([variant='ah-promoted-plans']) .header {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--consonant-merch-spacing-xxs);
        }

        :host([variant='ah-promoted-plans']) ::slotted([slot='price']) {
            margin-left: var(--spacing-xs);
            display: flex;
            flex-direction: column;
            justify-content: end;
            font-size: var(--consonant-merch-card-body-m-font-size);
            font-style: italic;
            line-height: var(--consonant-merch-card-body-m-line-height);
            color: var(--consonant-merch-card-heading-xxxs-color);
        }

        :host([variant='ah-promoted-plans']) .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    `);

// src/variants/fries.js
init_lit();

// src/variants/fries.css.js
var CSS15 = `
    merch-card[variant='fries'] {
        background-color: var(
            --merch-card-custom-background-color,
            var(--consonant-merch-card-background-color)
        );
    }

    merch-card[variant='fries'] merch-icon[size='s'] img {
        width: 26px;
        height: 25px;
    }

    merch-card[variant='fries'] [slot="heading-xxs"] {
        color: var(--consonant-merch-card-heading-xxs-color);
    }

    merch-card[variant='fries'] [slot="badge"] {
        position: absolute;
        top: 0;
        right: 24px;
        font-weight: 700;
    }

    merch-card[variant='fries'] [slot="badge"] merch-badge {
        border-radius: 0 0 5px 5px;
    }

    merch-card[variant='fries'] [slot="trial-badge"] {
        min-width: fit-content;
    }

    merch-card[variant='fries'] [slot="trial-badge"] merch-badge {
        display: inline-flex;
        padding: 4px 9px;
        background-color: transparent;
        border-radius: 4px;
        color: var(--merch-badge-background-color, var(--spectrum-global-color-green-700));
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        line-height: var(--consonant-merch-card-body-xxs-line-height);
        max-width: fit-content;
    }

    merch-card[variant='fries'] [slot="body-s"] {
        letter-spacing: normal;
        color: var(--consonant-merch-card-body-s-color);
        font-size: var(--consonant-merch-card-body-s-font-size);
        line-height: var(--consonant-merch-card-body-s-line-height);
    }

    merch-card[variant='fries'] [slot="body-s"] merch-icon {
        display: inline-flex;
        width: 20px;
        height: 20px;
        padding-inline-end: 6px;
        margin-top: 15px;
    }

    merch-card[variant='fries'] [slot="body-s"] .spectrum-Link--primary {
        text-decoration: none;
    }

    merch-card[variant='fries'] [slot="body-s"] .mnemonic-text {
        color: var(--spectrum-gray-900);
        font-size: var(--consonant-merch-card-body-xxs-font-size);
        line-height: var(--consonant-merch-card-body-xxs-line-height);
        font-weight: 400;
        letter-spacing: normal;
        display: inline-flex;
        vertical-align: super;
    }

    merch-card[variant='fries'] [slot="price"] {
        display: flex;
        flex-direction: column;
        align-items: end;
        color: var(--spectrum-gray-900);
    }

    merch-card[variant='fries'] [slot="price"] span.placeholder-resolved[data-template="strikethrough"] {
        text-decoration: none;
    }

    merch-card[variant='fries'] [slot="price"] .price-strikethrough {
        font-size: var(--consonant-merch-card-body-xs-font-size);
        line-height: var(--consonant-merch-card-body-xs-line-height);
        vertical-align: middle;
        text-decoration: line-through;
        text-decoration-color: var(--merch-color-red-promo);
    }

    merch-card[variant='fries'] [slot="price"] .price-strikethrough .price-currency-symbol,
    merch-card[variant='fries'] [slot="price"] .price-strikethrough .price-integer,
    merch-card[variant='fries'] [slot="price"] .price-strikethrough .price-decimals-delimiter,
    merch-card[variant='fries'] [slot="price"] .price-strikethrough .price-decimals,
    merch-card[variant='fries'] [slot="price"] .price-strikethrough .price-recurrence {
        font-size: var(--consonant-merch-card-body-xs-font-size);
        line-height: var(--consonant-merch-card-body-xs-line-height);
        font-weight: 700;
        vertical-align: middle;
    }

    merch-card[variant='fries'] [slot="price"] .price-currency-symbol {
        font-size: var(--consonant-merch-card-body-xs-font-size);
        line-height: var(--consonant-merch-card-body-xs-line-height);
        font-weight: 400;
        vertical-align: super;
    }

    merch-card[variant='fries'] [slot="price"] .price-integer,
    merch-card[variant='fries'] [slot="price"] .price-decimals-delimiter,
    merch-card[variant='fries'] [slot="price"] .price-decimals {
        font-size: var(--consonant-merch-card-heading-m-font-size);
        line-height: var(--consonant-merch-card-heading-m-line-height);
        font-weight: 700;
    }

    merch-card[variant='fries'] [slot="price"] .price-recurrence {
        font-size: var(--consonant-merch-card-body-xs-font-size);
        line-height: var(--consonant-merch-card-body-xs-line-height);
        font-weight: 400;
    }

    merch-card[variant='fries'] [slot="addon-confirmation"] {
        color: var(--spectrum-green-800);
        font-size: 15px;
        font-weight: bold;
        margin-left: 8px;
    }

    .spectrum--dark merch-card[variant="fries"],
    .spectrum--darkest merch-card[variant="fries"] {
      --spectrum-yellow-300:rgb(248, 217, 4);
      --consonant-merch-card-background-color:rgb(19, 19, 19);
      --consonant-merch-card-heading-xxs-color:rgb(253, 253, 253);
      --consonant-merch-card-body-s-color:rgb(128, 128, 128);
      --merch-card-fries-badge-color:rgb(0, 122, 77);
      --consonant-merch-card-body-xxs-color:rgb(219, 219, 219);
      --merch-card-ah-promoted-plans-strikethrough-color:rgb(138, 138, 138);
    }

    .spectrum--dark merch-card[variant="fries"] [slot="body-s"],
    .spectrum--darkest merch-card[variant="fries"] [slot="body-s"] {
        color: rgb(142, 142, 147);
    }
`;

// src/variants/fries.js
var FRIES_AEM_FRAGMENT_MAPPING = {
  mnemonics: { size: "s" },
  title: { tag: "h3", slot: "heading-xxs", maxCount: 250, withSuffix: true },
  description: {
    tag: "div",
    slot: "body-s",
    maxCount: 2e3,
    withSuffix: false
  },
  badge: { tag: "div", slot: "badge", default: "spectrum-yellow-300" },
  trialBadge: {
    tag: "div",
    slot: "trial-badge",
    default: "spectrum-green-800"
  },
  prices: { tag: "p", slot: "price" },
  ctas: { slot: "cta", size: "M" },
  addonConfirmation: { tag: "div", slot: "addon-confirmation" },
  borderColor: {
    attribute: "border-color",
    specialValues: {
      gray: "--spectrum-gray-300"
    }
  }
};
var FriesCard = class extends VariantLayout {
  getGlobalCSS() {
    return CSS15;
  }
  get aemFragmentMapping() {
    return FRIES_AEM_FRAGMENT_MAPPING;
  }
  renderLayout() {
    return x`
            <div class="content">
                <div class="header">
                    <slot name="icons"></slot>
                    <slot name="heading-xxs"></slot>
                    <slot name="trial-badge"></slot>
                </div>
                <slot name="badge"></slot>
                <slot name="body-s"></slot>
                <div class="footer">
                    <div class="cta">
                        <slot name="cta"></slot>
                        <slot name="addon-confirmation"></slot>
                    </div>
                    <slot name="price"></slot>
                </div>
            </div>
            <slot></slot>
        `;
  }
};
__publicField(FriesCard, "variantStyle", i`
        :host([variant='fries']) {
            --merch-card-fries-max-width: 620px;
            --merch-card-fries-padding: 24px;
            --merch-card-fries-min-height: 204px;
            --merch-card-fries-header-min-height: 36px;
            --merch-card-fries-gray-background: rgba(248, 248, 248);
            --merch-card-fries-text-color: rgba(19, 19, 19);
            --merch-card-fries-price-line-height: 17px;
            --merch-card-fries-outline: transparent;
            --consonant-merch-card-border-width: 1px;
            max-width: var(--merch-card-fries-max-width);
            min-height: var(--merch-card-fries-min-height);
            background-color: var(
                --merch-card-custom-background-color,
                var(--spectrum-gray-300)
            );
            color: var(--consonant-merch-card-heading-xxxs-color);
            border-radius: 4px;
            border: 1px solid
                var(--consonant-merch-card-border-color, transparent);
            display: flex;
            flex-direction: row;
            overflow: hidden;
            padding: var(--merch-card-fries-padding) !important;
            gap: 16px;
            justify-content: space-between;
            box-sizing: border-box !important;
        }

        :host([variant='fries']) .content {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            flex-grow: 1;
        }

        :host([variant='fries']) .header {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--consonant-merch-spacing-xxs);
            padding-bottom: 15px;
            padding-top: 5px;
        }

        :host([variant='fries']) .footer {
            display: flex;
            width: fit-content;
            flex-wrap: nowrap;
            gap: 8px;
            flex-direction: row;
            margin-top: auto;
            align-items: end;
            width: 100%;
            justify-content: space-between;
        }

        :host([variant='fries']) .cta {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }
    `);

// src/mas.js
registerVariant(
  "ccd-suggested",
  CCDSuggested,
  CCD_SUGGESTED_AEM_FRAGMENT_MAPPING,
  CCDSuggested.variantStyle
);
registerVariant(
  "ccd-slice",
  CCDSlice,
  CCD_SLICE_AEM_FRAGMENT_MAPPING,
  CCDSlice.variantStyle
);
registerVariant(
  "ah-try-buy-widget",
  AHTryBuyWidget,
  AH_TRY_BUY_WIDGET_AEM_FRAGMENT_MAPPING,
  AHTryBuyWidget.variantStyle
);
registerVariant(
  "ah-promoted-plans",
  AHPromotedPlans,
  AH_PROMOTED_PLANS_AEM_FRAGMENT_MAPPING,
  AHPromotedPlans.variantStyle
);
registerVariant(
  "fries",
  FriesCard,
  FRIES_AEM_FRAGMENT_MAPPING,
  FriesCard.variantStyle
);
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
lit-html/lit-html.js:
lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=mas.js.map
