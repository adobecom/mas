<!doctype html>
<html>
    <head>
        <script>
            window.__swc = { warn: () => {} };
        </script>
        <script type="module">
            window.process = { env: {} };
        </script>
        <title>version-page custom element test page</title>
        <meta name="nofollow-links" content="on" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="../style.css" />
        <style>
            body {
                margin: 32px;
            }
            sp-theme {
                display: contents;
            }
            version-page {
                width: 100%;
                height: 100vh;
            }
        </style>
        <mas-repository base-url="http://localhost:2023/test/mocks"></mas-repository>
    </head>
    <body>
        <script type="module">
            import { runTests } from '@web/test-runner-mocha';
            import { expect } from '@esm-bundle/chai';
            import sinon from 'sinon';
            import { html } from 'lit';
            import { fixture, oneEvent } from '@open-wc/testing-helpers';
            import '../src/swc.js';
            import '../src/version-page.js';
            import '../src/mas-repository.js';
            import '../src/version-repository.js';
            import {
                normalizeFields,
                denormalizeFields,
                calculateDifferences,
                formatFieldValue,
                getFieldLabel,
                getFieldVisible,
                setFieldConfig,
            } from '../src/utils/version-transformer.js';
            import Store from '../src/store.js';

            runTests(() => {
                // Initialize field config for tests
                setFieldConfig({
                    title: { label: 'Fragment Title', isArray: false, visible: false },
                    description: { label: 'Fragment Description', isArray: false, visible: false },
                    tags: { label: 'Tags', isArray: true, visible: false },
                    cardTitle: { label: 'Title', isArray: false, visible: true },
                    prices: { label: 'Prices', isArray: true, visible: true },
                    ctas: { label: 'Footer', isArray: true, visible: true },
                    badge: { label: 'Badge', isArray: false, visible: true },
                });

                describe('version-page', () => {
                    let versionPage;
                    let sandbox;

                    afterEach(() => {
                        if (sandbox) {
                            sandbox.restore();
                        }
                        if (versionPage) {
                            versionPage.remove();
                        }
                    });

                    describe('FIELD_CONFIG', () => {
                        beforeEach(async () => {
                            versionPage = await fixture(html`<version-page></version-page>`);
                        });

                        it('should have all required field configurations', () => {
                            const config = versionPage.constructor.FIELD_CONFIG;
                            expect(config).to.exist;

                            // Check critical fields exist
                            expect(config.title).to.exist;
                            expect(config.cardTitle).to.exist;
                            expect(config.prices).to.exist;
                            expect(config.badge).to.exist;
                            expect(config.tags).to.exist;
                        });

                        it('should have label, isArray, and visible properties for each field', () => {
                            const config = versionPage.constructor.FIELD_CONFIG;
                            Object.entries(config).forEach(([fieldName, fieldConfig]) => {
                                expect(fieldConfig).to.have.property('label');
                                expect(fieldConfig).to.have.property('isArray');
                                expect(fieldConfig).to.have.property('visible');
                                expect(typeof fieldConfig.isArray).to.equal('boolean');
                                expect(typeof fieldConfig.visible).to.equal('boolean');
                            });
                        });

                        it('should mark visible fields correctly', () => {
                            const config = versionPage.constructor.FIELD_CONFIG;

                            // These should be visible (rendered on card)
                            expect(config.cardTitle.visible).to.be.true;
                            expect(config.prices.visible).to.be.true;
                            expect(config.badge.visible).to.be.true;
                            expect(config.ctas.visible).to.be.true;

                            // These should not be visible (metadata)
                            expect(config.title.visible).to.be.false;
                            expect(config.tags.visible).to.be.false;
                            expect(config.variant.visible).to.be.false;
                            expect(config.osi.visible).to.be.false;
                        });

                        it('should mark array fields correctly', () => {
                            const config = versionPage.constructor.FIELD_CONFIG;

                            // These should be arrays
                            expect(config.tags.isArray).to.be.true;
                            expect(config.prices.isArray).to.be.true;
                            expect(config.ctas.isArray).to.be.true;
                            expect(config.mnemonicIcon.isArray).to.be.true;

                            // These should not be arrays
                            expect(config.title.isArray).to.be.false;
                            expect(config.cardTitle.isArray).to.be.false;
                            expect(config.badge.isArray).to.be.false;
                        });
                    });

                    describe('getFieldLabel (utility)', () => {
                        it('should return user-friendly labels for known fields', () => {
                            expect(getFieldLabel('title')).to.equal('Fragment Title');
                            expect(getFieldLabel('cardTitle')).to.equal('Title');
                            expect(getFieldLabel('prices')).to.equal('Prices');
                            expect(getFieldLabel('badge')).to.equal('Badge');
                        });

                        it('should return the field name for unknown fields', () => {
                            expect(getFieldLabel('unknownField')).to.equal('unknownField');
                        });
                    });

                    describe('getFieldVisible (utility)', () => {
                        it('should return true for visible fields', () => {
                            expect(getFieldVisible('cardTitle')).to.be.true;
                            expect(getFieldVisible('prices')).to.be.true;
                            expect(getFieldVisible('badge')).to.be.true;
                        });

                        it('should return false for non-visible fields', () => {
                            expect(getFieldVisible('title')).to.be.false;
                            expect(getFieldVisible('tags')).to.be.false;
                        });

                        it('should return false for unknown fields', () => {
                            expect(getFieldVisible('unknownField')).to.be.false;
                        });
                    });

                    describe('formatFieldValue (utility)', () => {
                        it('should return "N/A" for null or undefined', () => {
                            expect(formatFieldValue(null)).to.equal('N/A');
                            expect(formatFieldValue(undefined)).to.equal('N/A');
                        });

                        it('should join array values with comma', () => {
                            expect(formatFieldValue(['tag1', 'tag2', 'tag3'])).to.equal('tag1, tag2, tag3');
                            expect(formatFieldValue(['single'])).to.equal('single');
                            expect(formatFieldValue([])).to.equal('');
                        });

                        it('should join object values with comma', () => {
                            expect(formatFieldValue({ a: 'value1', b: 'value2' })).to.equal('value1, value2');
                        });

                        it('should convert primitives to string', () => {
                            expect(formatFieldValue('test')).to.equal('test');
                            expect(formatFieldValue(123)).to.equal('123');
                            expect(formatFieldValue(true)).to.equal('true');
                        });
                    });

                    describe('normalizeFields (utility)', () => {
                        it('should return fields object if already normalized', () => {
                            const data = {
                                fields: { title: 'Test', description: 'Description' },
                            };
                            const result = normalizeFields(data);
                            expect(result).to.deep.equal(data.fields);
                        });

                        it('should convert elements array to fields object', () => {
                            const data = {
                                elements: [
                                    { name: 'title', value: 'Test Title' },
                                    { name: 'description', values: ['Test Description'] },
                                    { name: 'prices', values: ['$10', '$20'] },
                                ],
                            };
                            const result = normalizeFields(data);
                            expect(result.title).to.equal('Test Title');
                            expect(result.description).to.equal('Test Description');
                            expect(result.prices).to.be.an('array');
                        });

                        it('should ensure array fields stay as arrays', () => {
                            const data = {
                                elements: [
                                    { name: 'tags', value: 'single-tag' },
                                    { name: 'prices', values: ['$10'] },
                                    { name: 'ctas', values: [] },
                                ],
                            };
                            const result = normalizeFields(data);
                            expect(result.tags).to.be.an('array');
                            expect(result.tags).to.deep.equal(['single-tag']);
                            expect(result.prices).to.be.an('array');
                            expect(result.prices).to.deep.equal(['$10']);
                            expect(result.ctas).to.be.an('array');
                            expect(result.ctas).to.deep.equal([]);
                        });

                        it('should unwrap single-element arrays for non-array fields', () => {
                            const data = {
                                elements: [
                                    { name: 'title', values: ['Single Title'] },
                                    { name: 'badge', values: ['Best Value'] },
                                ],
                            };
                            const result = normalizeFields(data);
                            expect(result.title).to.equal('Single Title');
                            expect(result.badge).to.equal('Best Value');
                        });
                    });

                    describe('calculateDifferences (utility)', () => {
                        it('should return empty array if no data provided', () => {
                            expect(calculateDifferences(null, null)).to.deep.equal([]);
                            expect(calculateDifferences({}, null)).to.deep.equal([]);
                            expect(calculateDifferences(null, {})).to.deep.equal([]);
                        });

                        it('should detect changes in simple fields', () => {
                            const current = {
                                fields: { title: 'Old Title', description: 'Same' },
                            };
                            const selected = {
                                fields: { title: 'New Title', description: 'Same' },
                            };
                            const diffs = calculateDifferences(current, selected);

                            expect(diffs).to.have.lengthOf(1);
                            expect(diffs[0].field).to.equal('title');
                            expect(diffs[0].currentValue).to.equal('Old Title');
                            expect(diffs[0].selectedValue).to.equal('New Title');
                        });

                        it('should extract last segment from tags', () => {
                            const current = {
                                fields: { tags: ['caas:content-type/blog'] },
                            };
                            const selected = {
                                fields: { tags: ['caas:content-type/article'] },
                            };
                            const diffs = calculateDifferences(current, selected);

                            expect(diffs).to.have.lengthOf(1);
                            expect(diffs[0].field).to.equal('tags');
                            expect(diffs[0].selectedValue).to.deep.equal(['article']);
                        });

                        it('should not report unchanged fields', () => {
                            const current = {
                                fields: { title: 'Same', description: 'Same', badge: 'Same' },
                            };
                            const selected = {
                                fields: { title: 'Same', description: 'Same', badge: 'Same' },
                            };
                            const diffs = calculateDifferences(current, selected);

                            expect(diffs).to.have.lengthOf(0);
                        });
                    });

                    describe('rendering', () => {
                        beforeEach(async () => {
                            versionPage = await fixture(html`<version-page></version-page>`);
                            await versionPage.updateComplete;
                        });

                        it('should render version page element', () => {
                            expect(versionPage).to.exist;
                            expect(versionPage.tagName.toLowerCase()).to.equal('version-page');
                        });

                        it('should have static FIELD_CONFIG accessible', () => {
                            expect(versionPage.constructor.FIELD_CONFIG).to.exist;
                            expect(Object.keys(versionPage.constructor.FIELD_CONFIG).length).to.be.greaterThan(0);
                        });

                        it('should have required properties', () => {
                            expect(versionPage).to.have.property('versions');
                            expect(versionPage).to.have.property('fragment');
                            expect(versionPage).to.have.property('loading');
                        });

                        it('should have required methods', () => {
                            expect(versionPage.loadVersionHistory).to.be.a('function');
                            expect(versionPage.loadVersionData).to.be.a('function');
                            expect(versionPage.handleVersionClick).to.be.a('function');
                            expect(versionPage.handleRestoreVersion).to.be.a('function');
                            expect(versionPage.hydrateCard).to.be.a('function');
                        });

                        it('should have versionRepository initialized after connectedCallback', async () => {
                            const masRepo = document.createElement('mas-repository');
                            document.body.appendChild(masRepo);

                            const testPage = await fixture(html`<version-page></version-page>`);
                            await testPage.updateComplete;

                            expect(testPage.versionRepository).to.exist;
                            expect(testPage.versionRepository.constructor.name).to.equal('VersionRepository');

                            testPage.remove();
                            masRepo.remove();
                        });
                    });

                    describe('VersionRepository', () => {
                        let mockRepository;
                        let versionRepo;

                        beforeEach(() => {
                            mockRepository = {
                                aem: {
                                    sites: {
                                        cf: {
                                            fragments: {
                                                getById: sinon.stub(),
                                                getVersions: sinon.stub(),
                                                getVersion: sinon.stub(),
                                                save: sinon.stub(),
                                            },
                                        },
                                    },
                                },
                            };
                            sandbox = sinon.createSandbox();
                        });

                        it('should search versions by query', () => {
                            versionRepo = new (await import('../src/version-repository.js')).VersionRepository(
                                mockRepository,
                            );
                            const versions = [
                                { version: '1.0', createdBy: 'John', comment: 'Initial version' },
                                { version: '2.0', createdBy: 'Jane', comment: 'Updated design' },
                                { version: '3.0', createdBy: 'Bob', comment: 'Bug fix' },
                            ];

                            const results = versionRepo.searchVersions(versions, 'Jane');
                            expect(results).to.have.lengthOf(1);
                            expect(results[0].version).to.equal('2.0');
                        });

                        it('should return all versions when query is empty', () => {
                            versionRepo = new (await import('../src/version-repository.js')).VersionRepository(
                                mockRepository,
                            );
                            const versions = [{ version: '1.0' }, { version: '2.0' }];

                            const results = versionRepo.searchVersions(versions, '');
                            expect(results).to.have.lengthOf(2);
                        });
                    });
                });
            });
        </script>
    </body>
</html>
